<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Capacitor Preferences for robust session persistence on iOS -->
    <script type="module">
      import { Preferences } from '@capacitor/preferences';
      // Restore Supabase session from native storage before anything else
      (async function restoreSupabaseSession() {
        // Only run in native app
        const isNative = !!window.Capacitor || !!window.cordova || !!window.webkit?.messageHandlers?.bridge;
        if (!isNative) return;
        try {
          const { value } = await Preferences.get({ key: 'zencards-auth' });
          if (value) {
            localStorage.setItem('zencards-auth', value);
          }
        } catch (e) {
          console.warn('[Capacitor] Could not restore session from Preferences:', e);
        }
      })();
    </script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <meta charset="UTF-8" />
  <title>ZenCards ‚Äî Hands-Free Audio Flashcards </title>
  <script>
    // --- Persist and Restore Study Settings ---
    function saveStudySettings() {
      const settings = {
        deck: document.getElementById('deckSelect')?.value || '',
        ttsRate: document.getElementById('ttsRateInput')?.value || '',
        ttsVolume: document.getElementById('ttsVolumeInput')?.value || '',
        // Add more as needed (e.g., mode, delay)
      };
      localStorage.setItem('zencards_study_settings', JSON.stringify(settings));
    }

    function restoreStudySettings() {
      const settings = JSON.parse(localStorage.getItem('zencards_study_settings') || '{}');
      if (settings.deck && document.getElementById('deckSelect')) {
        document.getElementById('deckSelect').value = settings.deck;
      }
      if (settings.ttsRate && document.getElementById('ttsRateInput')) {
        document.getElementById('ttsRateInput').value = settings.ttsRate;
      }
      if (settings.ttsVolume && document.getElementById('ttsVolumeInput')) {
        document.getElementById('ttsVolumeInput').value = settings.ttsVolume;
      }
      // Add more as needed
    }

    document.addEventListener('DOMContentLoaded', () => {
      restoreStudySettings();
      // Save on change
      ['deckSelect','ttsRateInput','ttsVolumeInput'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('change', saveStudySettings);
      });
    });
    // Prevent double-tap to zoom on iOS
    (function() {
      let lastTouchEnd = 0;
      document.addEventListener('touchend', function(event) {
        const now = Date.now();
        if (now - lastTouchEnd <= 350) {
          event.preventDefault();
        }
        lastTouchEnd = now;
      }, { passive: false });
    })();
  </script>
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=yes, maximum-scale=5.0"
/>
  <!-- MathJax for rendering LaTeX equations in cards -->
   <script>
    console.log("APP VERSION:", "2026-01-04 10:33am");
    
  window.MathJax = {
    startup: {
      ready: () => {
        console.log("MathJax ready");
        MathJax.startup.defaultReady();
      }
    }
  };
// ===== App background/foreground auto-pause/resume logic =====
document.addEventListener('visibilitychange', function() {
  if (document.hidden) {
    // App is backgrounded
    if (!isPaused && currentMode === 'voice') {
      // Robust pause logic: match button/voice command
      isPaused = true;
      if (currentCard) window.restartCardOnResumeVoice = true;
      stopAllAudio();
      clearStudyAheadGapTimer();
      clearQuestionDelayTimer();
      clearAnswerAfterSpeechDelay();
      if (typeof pauseBtn !== 'undefined') pauseBtn.disabled = true;
      if (typeof resumeBtn !== 'undefined') resumeBtn.disabled = false;
      setStatus('Paused. Say "resume study session" or tap Resume.');
      speakSafe('Paused.', () => {
        listenForCommand(handleVoiceTranscript);
      });
    }
  } else {
    // App is foregrounded
    if (currentMode === 'voice' && isPaused) {
      isPaused = false;
      if (typeof pauseBtn !== 'undefined') pauseBtn.disabled = false;
      if (typeof resumeBtn !== 'undefined') resumeBtn.disabled = true;
      if (window.restartCardOnResumeVoice && currentCard) {
        window.restartCardOnResumeVoice = false;
        restartCurrentCardVoiceFlow();
      } else {
        runVoiceLoop();
      }
    }
  }
});
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  <style>
    :root{
  --bg1:#0f172a;
  --bg2:#020617;
    /* ===== iOS safe-area handling (app only) ===== */
  --appSafeTop: env(safe-area-inset-top, 0px);
  --userBarTopPad: 14px;     /* breathing room below notch */
  --topBarClearance: 110px; /* keeps content from hiding behind fixed bar */


  --card: rgba(15,23,42,0.92);
  --border:#1e293b;

  --text:#e5e7eb;
  --muted:#94a3b8;

  --green:#22c55e;
  --green2:#16a34a;

  --slate:#334155;

  --amber:#f59e0b;
  --amber2:#d97706;

  --link:#60a5fa;
  --link2:#93c5fd;

  --shadow: 0 18px 35px rgba(0,0,0,0.55), 0 0 0 1px rgba(15,23,42,0.7);
}
@media (max-width: 430px){
  :root{
    --userBarTopPad: 18px;
    --topBarClearance: 125px;
  }
}

  .brandLogo{
  height: clamp(56px, 7vw, 92px); /* grows on desktop, safe on small screens */
  width: auto;
  display: block;
}
    /* ===== Top-left signed-in bar ===== */
.topUserBar {
  position: fixed;
  top: calc(env(safe-area-inset-top, 0px) + 12px);
  left: 14px;
  z-index: 12000;

  background: rgba(2, 6, 23, 0.86);
  border: 1px solid #1f2937;
  border-radius: 14px;
  padding: 10px 12px;

  box-shadow: 0 18px 35px rgba(0,0,0,0.55);
  max-width: calc(100% - 28px);
}

.topUserBar .signedInLine {
  margin: 0 0 6px 0;
  font-size: 0.95rem;
  color: #e5e7eb;
}

.topUserBar .btnRow {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
  justify-content: center; /* ‚úÖ centers the buttons */
}


.topUserBar button {
  margin: 0; /* important: override your default button margin */
}

/* app.html only: hide billing portal button */
#manageBillingBtn {
  display: none !important;
}


    /* Hide Sign Up button on app.html (users sign up on landing) */
#signUpBtn {
  display: none !important;
}
#authLoggedOut .row {
  justify-content: center;
}

    body{
  margin:0;
  padding:1rem;
  padding-top: calc(var(--topBarClearance) + env(safe-area-inset-top, 0px));
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  background: radial-gradient(circle at top, var(--bg1) 0, var(--bg2) 55%);
  color: var(--text);
  line-height:1.5;
}
    h1, h2, h3 {
      margin: 0.5rem 0;
    }

    button:disabled {
  opacity: 0.45;
  cursor: not-allowed;
}
   
/* Logo header blending panel */
.appHeader{
  display:flex;
  align-items:center;
  justify-content:center;
  margin-bottom:0.12rem;
  padding: 10px 12px;
  border-radius: 16px;

  /* This is the "match" layer behind the logo */
  background:
    radial-gradient(circle at 50% 20%, rgba(148,163,184,0.14), rgba(2,6,23,0) 60%),
    linear-gradient(90deg, rgba(2,6,23,0.0), rgba(15,23,42,0.55), rgba(2,6,23,0.0));

  border: 1px solid rgba(30,41,59,0.6);
  box-shadow: 0 18px 35px rgba(0,0,0,0.35);
  width: fit-content;
  margin-left:auto;
  margin-right:auto;

  /* helps blend if your logo has subtle edges */
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}

.brandLogo{
  height: clamp(56px, 7vw, 92px);
  width: auto;
  display:block;
  /* mix-blend-mode: lighten;  <-- optional, only if you want it */
}

    .logoMark {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.9);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      background: radial-gradient(circle at 30% 0%, #22c55e 0, #22c55e22 45%, #020617 70%);
      box-shadow: 0 8px 18px rgba(15,23,42,0.9);
      color: #e5e7eb;
      flex-shrink: 0;
    }
    .appTitle {
      text-align: center;
      font-size: 1.9rem;
      letter-spacing: 0.04em;
    }
    .appSubtitle {
      text-align: center;
      font-size: 0.95rem;
      color: #9ca3af;
      margin-top: 0.05rem;
      margin-bottom: 0.6rem;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    .card{
  background: var(--card);
  border-radius: 0.9rem;
  padding: 1rem;
  margin-top: 1rem;
  border: 1px solid var(--border);
  box-shadow: var(--shadow);
}
    label {
      display: inline-block;
      margin: 0.25rem 0;
      font-size: 0.9rem;
    }
    input[type="text"], textarea, select, input[type="number"]{
  width:100%;
  padding:0.55rem 0.65rem;
  border-radius:0.6rem;
  border:1px solid #1f2937;
  background:#0b1220;
  color:var(--text);
  box-sizing:border-box;
  font-size:0.9rem;
}
    input[type="text"]:focus,
textarea:focus,
select:focus,
input[type="number"]:focus{
  outline:none;
  border-color: rgba(34,197,94,0.55);
  box-shadow: 0 0 0 3px rgba(34,197,94,0.12);
}
    textarea {
      min-height: 60px;
    }
    textarea.drag-hover {
  outline: 2px dashed #22c55e;
}

    button {
      margin: 0.25rem 0.25rem 0.25rem 0;
      padding: 0.5rem 1.2rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: #10b981;
      color: #020617;
      font-weight: 600;
      font-size: 0.95rem;
      transition:
        background 0.15s ease,
        transform 0.08s ease,
        box-shadow 0.12s ease;
      box-shadow: 0 8px 18px rgba(16,185,129,0.28);
    }
    button:hover:not(:disabled) {
      background: #22c55e;
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(34,197,94,0.35);
    }
    button:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(15,23,42,0.6);
    }
    button.secondary {
      background: #374151;
      color: #e5e7eb;
      box-shadow: none;
    }
    button.secondary:hover:not(:disabled) {
      background: #4b5563;
      box-shadow: 0 6px 14px rgba(15,23,42,0.65);
    }
    button.small {
      padding: 0.25rem 0.7rem;
      font-size: 0.8rem;
    }
    button:disabled {
      background: #374151;
      cursor: default;
      box-shadow: none;
      opacity: 0.7;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
    }
/* Decks layout fix for mobile */
.deckRow {
  align-items: flex-start;
}

@media (max-width: 600px) {
  .deckRow {
    flex-direction: column;
  }
  .deckRow > * {
    width: 100%;
  }
}

    .row > * {
      flex: 1;
      min-width: 0;
    }
    .inline {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      margin-right: 0.75rem;
    }
    .badge {
      display: inline-block;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      background: #1f2937;
      font-size: 0.75rem;
      margin-left: 0.25rem;
    }
    #status {
      margin-top: 0.75rem;
      font-size: 0.9rem;
      color: #9ca3af;
      min-height: 1.2em;
    }
    #cardsList {
      max-height: 180px;
      overflow-y: auto;
      margin-top: 0.5rem;
      border-top: 1px solid #111827;
      padding-top: 0.5rem;
    }
    .cardRow {
      padding: 0.35rem 0;
      border-bottom: 1px solid #020617;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
    }
    /* Horizontal rating layout */
.ratingRow {
  display: flex;
  gap: 0.6rem;
  flex-wrap: wrap;          /* wraps nicely on small screens */
  align-items: flex-start;
  margin-top: 0.5rem;
}

.ratingItem {
  display: flex;
  flex-direction: column;   /* button on top, hint under it */
  gap: 0.25rem;
}

.ratingItem .dueHint {
  margin: 0;                /* remove extra spacing */
}

    #cardsHeader {
  padding: 0.25rem 0;
  border-top: 1px solid #111827;
  border-bottom: 1px solid #111827;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.8rem;
  color: #9ca3af;
  text-transform: uppercase;
  letter-spacing: 0.06em;
}

#cardsHeader span:first-child {
  flex: 1;
  min-width: 0;
}

#cardsHeader .dueDateCell {
  flex: 0 0 130px;
  text-align: center;
  white-space: nowrap;
}

.cardRow .dueDateCell {
  flex: 0 0 130px;
  text-align: center;
  white-space: nowrap;
  font-size: 0.75rem;
  color: #9ca3af;
}
/* Visually mark overdue cards in the card list */
.cardRow.overdue .dueDateCell {
  color: #f97373;
  font-weight: 600;
}

.cardRow.overdue span:first-child {
  color: #f97373;
}

.cardActions {
  display: flex;
  gap: 0.25rem;
  flex: 0 0 auto;
}
    .cardRow span {
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: #e5e7eb;
    }
    .cardRow:hover span {
      color: #a5b4fc;
    }
    .hidden {
      display: none;
    }
    /* ===== Modal styling ===== */
.modal {
  position: fixed;
  inset: 0;
  z-index: 9999;
}
/* Prevent iOS zoom on input focus in modals */
.modal input, .modal select, .modal textarea {
  font-size: 16px !important;
}

.modalBackdrop {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.6);
}

.modalCard {
  position: relative;
  width: min(720px, calc(100% - 2rem));
  margin: 10vh auto;
  background: #020617;
  border: 1px solid #1f2937;
  border-radius: 0.9rem;
  padding: 1rem;
  box-shadow: 0 25px 60px rgba(0,0,0,0.6);
}
    #studySection {
      margin-top: 1rem;
    }
    /* Shared visual style for both silent + voice question/answer blocks */
    #silentQuestion, #silentAnswer, #voiceQuestion, #voiceAnswer {
      margin-top: 0.75rem;
      padding: 0.75rem;
      background: #020617;
      border-radius: 0.6rem;
      min-height: 3rem;
      border: 1px solid #1f2937;
    }
    #modeBadge {
      font-size: 0.8rem;
      margin-left: 0.5rem;
    }
    .dueHint {
      display: block;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.35rem;
    }
/* ===== app.html: make the top signed-in bar feel clean on small screens ===== */
@media (max-width: 430px){
  .topUserBar{
  top: calc(env(safe-area-inset-top, 0px) + 10px);
    left: 10px;
    right: 10px;                 /* allows it to size nicely */
    max-width: none;             /* override max-width calc */
    padding: 8px 10px;
    border-radius: 14px;
  }

  .topUserBar .signedInLine{
    font-size: 0.85rem;
    margin: 0 0 6px 0;
    line-height: 1.2;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;     /* prevents long emails from blowing layout */
  }

  .topUserBar .btnRow{
    gap: 6px;
  }

  .topUserBar .btnRow button{
    padding: 0.28rem 0.7rem;     /* smaller pill buttons */
    font-size: 0.82rem;
  }

  /* Important: remove your global button margins inside this bar
     so it never "double spaces" and pushes off-screen */
  .topUserBar button{
    margin: 0 !important;
  }
}

/* ===== app.html: prevent top UI from covering your header content ===== */
:root{
  --topBarClearance: 86px;  /* default space reserved for fixed top bar */
}

@media (max-width: 430px){
  :root{
    --topBarClearance: 98px; /* a bit more room because buttons may wrap */
  }
}

/* Push the main app content down so the fixed bar doesn't overlap */

  </style>
</head>
<body>
    <div>
  </div>
</div>

  <!-- Top-left signed-in bar -->

<div id="authLoggedIn" class="topUserBar hidden">
  <p class="signedInLine">
    Signed in as <strong id="userEmailLabel"></strong>
  </p>
  <div class="btnRow">
    <button id="logOutBtn" class="secondary small">Log Out</button>
    <button id="manageBillingBtn" class="small">Manage Billing</button>
    <button class="btn danger small" id="deleteAccountBtn" type="button" style="background:#dc2626;color:#fff;">Delete Account</button>
  </div>
</div>

   <div class="appHeader">
  <img src="zencards-logo.png" alt="ZenCards logo" class="brandLogo" />
</div>

    <p class="appSubtitle">Hands-free & silent spaced&nbsp;repetition flashcards</p>

    <!-- ========== MAIN SETTINGS / MENU ========== -->
    <div id="mainMenu" class="card">
      <h2>Main Menu</h2>

      <!-- Deck controls -->
      <div class="card">
        <h3>Decks</h3>
          <div class="row deckRow">
          <div>
            <label for="deckSelect">Select deck:</label>
            <select id="deckSelect"></select>
          </div>
          <div style="flex:0 0 auto;">
            <button id="editDeckNameBtn" class="secondary">Edit Deck Name</button>
          </div>
          <div>
            <label for="newDeckName">New deck name:</label>
            <input id="newDeckName" type="text" placeholder="e.g. Bio, Anatomy, etc." />
          </div>
          <div style="flex:0 0 auto;">
            <button id="addDeckBtn">Add Deck</button>
            <!-- Delete deck button -->
            <button id="deleteDeckBtn" class="secondary">Delete Deck</button>
          </div>
        </div>
        <!-- Legend for counts -->
        <p style="font-size:0.8rem;color:#9ca3af;margin-top:0.35rem;">
  Legend: <em>Deck name (new / learning / review)</em>
</p>
      </div>

      <!-- Card editor / viewer -->
      <div class="card">
        <h3>Cards (Viewer & Editor)</h3>
        <div class="row">
         <div>
  <div>
  <label for="cardQuestionLang">Question language (TTS):</label>
  <select id="cardQuestionLang"></select>

  <label for="cardQuestion">Question:</label>
  <textarea id="cardQuestion" placeholder="Enter question" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>

  <div style="margin-top:0.25rem;font-size:0.8rem;">
    <button type="button" class="secondary small" data-insert-image data-target="cardQuestion">
      Insert image‚Ä¶
    </button>
    <span style="color:#9ca3af;">
      (Paste URL, choose file, or drag &amp; drop an image here)
    </span>
  </div>
</div>

<div>
  <label for="cardAnswerLang">Answer language (TTS):</label>
  <select id="cardAnswerLang"></select>

  <label for="cardAnswer">Answer:</label>
  <textarea id="cardAnswer" placeholder="Enter answer" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>

  <div style="margin-top:0.25rem;font-size:0.8rem;">
    <button type="button" class="secondary small" data-insert-image data-target="cardAnswer">
      Insert image‚Ä¶
    </button>
    <span style="color:#9ca3af;">
      (Paste URL, choose file, or drag &amp; drop an image here)
    </span>
  </div>
</div>

</div>
  <!-- Only one Insert image button for answer field -->
        </div>
        <div class="row">
          <div style="flex:0 0 auto;">
            <button id="addCardBtn">Add Card</button>
            <button id="updateCardBtn" class="secondary" disabled>Update Selected Card</button>
          </div>
          <div>
            <span id="selectedCardInfo" style="font-size:0.85rem;color:#9ca3af;"></span>
          </div>
        </div>
        <!-- Move card to another deck -->
<div class="row" style="margin-top:0.5rem;">
  <div>
    <label for="moveDeckSelect">Move selected card to deck (edit a card to select it):</label>
    <select id="moveDeckSelect"></select>
  </div>
  <div style="flex:0 0 auto;">
    <button id="moveCardBtn" class="secondary" disabled>Move Card</button>
  </div>
</div>
                <!-- Cards table header -->
        <div id="cardsHeader">
          <span>Question</span>
          <span class="dueDateCell">Due date</span>
          <span style="flex:0 0 auto;text-align:right;">Actions</span>
        </div>
        <div id="cardsList"></div>

        <!-- NEW: Import from Anki block -->
        <div style="margin-top:0.75rem;border-top:1px solid #111827;padding-top:0.5rem;">
          <label for="ankiImport" style="display:block;margin-bottom:0.25rem;">
            Import from Anki (TSV export):
          </label>
          <input id="ankiImport" type="file" accept=".txt,.tsv,.csv" />
          <button id="ankiImportHelpBtn" class="secondary small" type="button">How?</button>
          <span id="ankiImportStatus" style="font-size:0.8rem;color:#9ca3af;margin-left:0.5rem;"></span>
        </div>
      </div>

      <!-- Study options -->
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;">
          <h3>Study Options</h3>
          <div style="flex:0 0 auto;text-align:right;">
            <button id="toggleStudyOptionsBtn" class="secondary small" type="button">Show</button>
          </div>
        </div>
        <div id="studyOptionsPanel" class="hidden" style="margin-top:0.5rem;">
          <div>
            <label class="inline">
              <input type="checkbox" id="skipInstructionsAfterFirst" checked />
              Skip detailed difficulty instructions after first card
            </label>
          </div>
          <!-- Automatic mode -->
          <div>
            <label class="inline">
              <input type="checkbox" id="autoGoodToggle" />
              Can't give voice commands? Enable automatic mode so each card is assigned
              <select id="autoRatingSelect" style="width:auto;min-width:120px;">
                <option value="again">Again</option>
                <option value="hard">Hard</option>
                <option value="good" selected>Good</option>
                <option value="easy">Easy</option>
                <option value="tomorrow">Show again tomorrow</option>
              </select>
              rating automatically
              <span class="badge">New</span>
            </label>
          </div>
          <div style="margin-top:0.5rem;">
            <label class="inline" for="handsFreeNextDelaySeconds">
              Delay after rating before next question
            </label>
            <input type="number" id="handsFreeNextDelaySeconds" min="0" max="30" value="2" style="width:60px;" />
            <span>seconds</span>
          </div>
          <!-- NEW: auto study-ahead options -->
          <div style="margin-top:0.5rem;">
            <label class="inline">
              <input type="checkbox" id="autoEnterStudyAhead" />
              After I finish all due cards, automatically enter study-ahead mode
            </label>
          </div>
          <div>
            <label class="inline">
              <input type="checkbox" id="loopStudyAhead" />
              In study-ahead mode, keep looping the deck automatically
            </label>
          </div>
          <div style="margin-top:0.5rem;">
            <strong>Hands-free answer behavior:</strong>
            <div class="row" style="margin-top:0.25rem;">
              <div class="inline">
                <input type="radio" name="answerMode" id="answerModeDelay" value="delay" checked />
                <label for="answerModeDelay">Wait</label>
                <input type="number" id="answerDelaySeconds" min="1" max="60" value="4" style="width:60px;" />
                <span>seconds before answer</span>
              </div>
              <div class="inline">
                <input type="radio" name="answerMode" id="answerModeVoice" value="voice" />
                <label for="answerModeVoice">Play answer after I speak</label>
              </div>
            </div>
          </div>
          <!-- NEW: study-ahead answer gap control -->
          <div style="margin-top:0.5rem;">
            <label class="inline" for="studyAheadGapSeconds">
              Study-ahead: delay after answer before next question
            </label>
            <input type="number" id="studyAheadGapSeconds" min="1" max="60" value="4" style="width:60px;" />
            <span>seconds</span>
          </div>
        </div>
      </div>

      <!-- NEW: Audio & Voice Settings (collapsible section) -->
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;">
          <h3>Audio &amp; Voice Settings</h3>
          <div style="flex:0 0 auto;text-align:right;">
            <button id="toggleAudioSettingsBtn" class="secondary small" type="button">Show</button>
          </div>
        </div>
        <div id="audioSettingsPanel" class="hidden" style="margin-top:0.5rem;">
          <div>
            <label for="ttsRateInput">
              TTS speed (0.5 = slower, 1.0 = normal, 2.0 = faster)
            </label>
            <input
              type="number"
              id="ttsRateInput"
              min="0.5"
              max="2"
              step="0.1"
              value="1.0"
            />
          </div>

          <div style="margin-top:0.5rem;">
  <label for="answerDelayAfterSpeechSecInput">
    Answer delay after I stop speaking (seconds)
    <br />
    <small style="opacity:0.7;">
      0 = instant (default). Any speech resets the timer.
    </small>
  </label>
  <input
    type="number"
    id="answerDelayAfterSpeechSecInput"
    min="0"
    max="30"
    step="1"
    value="0"
  />
</div>

          <div style="margin-top:0.5rem;">
            <label for="ttsVolumeInput">
              TTS volume (0 = mute, 1 = max)
            </label>
            <input
              type="number"
              id="ttsVolumeInput"
              min="0"
              max="1"
              step="0.05"
              value="1.0"
            />
          </div>
        </div>
      </div>

      <!-- Study mode buttons -->
      <div class="card">
        <h3>Start Studying</h3>
        <div class="row">
          <button id="startVoiceBtn">Start Hands-Free Study</button>
          <button id="startSilentBtn" class="secondary">Start Silent Study</button>

        </div>


        <button id="openInstructionsBtn" class="secondary small" type="button">
  Instructions / Voice Commands
</button>

        <p style="font-size:0.85rem;color:#9ca3af;margin-top:0.5rem;">
          Voice commands (hands-free): "again", "hard", "good", "easy", "go to the next card",
          "repeat question", "repeat answer", "pause study session",
          "resume study session", "go to the main menu", "mute microphone".
        </p>
      </div>
    </div>

    <!-- ========== STUDY SECTION ========== -->
    <div id="studySection" class="card hidden">
      <div class="row" style="justify-content:space-between;">
        <h2 style="margin:0;">
  Study Session
  <span id="modeBadge" class="badge"></span>
  <span id="deckBadge" class="badge" style="margin-left:0.5rem;"></span>
</h2>
        <div>
            <button id="studyAddCardBtn" class="secondary small">Add Card</button>
          <button id="backToMenuBtn" class="secondary small">Main Menu</button>
          <button id="pauseBtn" class="secondary small">Pause</button>
          <button id="resumeBtn" class="secondary small" disabled>Resume</button>
          <button id="studyInstructionsBtn" class="secondary small">Instructions</button>
        </div>
      </div>
      <div id="status"></div>

      <!-- Voice mode UI (visual front/back during hands-free) -->
      <div id="voiceUI" class="hidden">
        <div id="voiceQuestion">
          <strong>Question:</strong> <span id="voiceQuestionText"></span>
        </div>
        <div id="voiceAnswer" class="hidden">
          <strong>Answer:</strong> <span id="voiceAnswerText"></span>
        </div>
        <div id="micMuteTimer" class="hidden" style="margin-top:0.5rem;">
  <span class="badge">
    Mic muted: <span id="micMuteSeconds">0</span>s
  </span>
</div>

        <!-- Inline edit for voice mode -->
        <div style="margin-top:0.5rem;">
          <button id="voiceEditToggleBtn" class="secondary small">Edit Card</button>
        </div>
        <div id="voiceEditPanel" class="hidden" style="margin-top:0.75rem;">
          <label for="voiceEditQuestionLang">Question language (TTS):</label>
<select id="voiceEditQuestionLang"></select>

<label for="voiceEditQuestion">Edit question:</label>
<textarea id="voiceEditQuestion" ...></textarea>

<label for="voiceEditAnswerLang">Answer language (TTS):</label>
<select id="voiceEditAnswerLang"></select>

<label for="voiceEditAnswer">Edit answer:</label>
<textarea id="voiceEditAnswer" ...></textarea>

          <label for="voiceEditQuestion">Edit question:</label>
          <textarea id="voiceEditQuestion" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>
          <label for="voiceEditAnswer">Edit answer:</label>
          <textarea id="voiceEditAnswer" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>
          <div style="margin-top:0.5rem;">
            <button id="voiceSaveEditBtn">Save</button>
            <button id="voiceCancelEditBtn" class="secondary">Cancel</button>
          </div>
        </div>
                <!-- Rating buttons for hands-free mode (optional tap) -->
        <div id="voiceRatingButtons" class="hidden" style="margin-top:0.5rem;">
          <span>How was that?</span><br />
          <button data-voice-rating="again">Again</button>
          <button data-voice-rating="hard">Hard</button>
          <button data-voice-rating="good">Good</button>
          <button data-voice-rating="easy">Easy</button>
        </div>
      </div> <!-- end of #voiceUI -->

      <!-- Silent mode UI -->
      <div id="silentUI" class="hidden">
        <div id="silentQuestion">
          <strong>Question:</strong> <span id="silentQuestionText"></span>
        </div>
        <div id="silentAnswer" class="hidden">
          <strong>Answer:</strong> <span id="silentAnswerText"></span>
        </div>

        <!-- Inline edit for silent mode -->
        <div style="margin-top:0.5rem;">
          <button id="silentEditToggleBtn" class="secondary small">Edit Card</button>
        </div>
        <div id="silentEditPanel" class="hidden" style="margin-top:0.75rem;">
          <label for="silentEditQuestion">Edit question:</label>
          <textarea id="silentEditQuestion" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>
          <label for="silentEditQuestionLang">Question language (TTS):</label>
<select id="silentEditQuestionLang"></select>

<label for="silentEditQuestion">Edit question:</label>
<textarea id="silentEditQuestion" ...></textarea>

<label for="silentEditAnswerLang">Answer language (TTS):</label>
<select id="silentEditAnswerLang"></select>

<label for="silentEditAnswer">Edit answer:</label>
<textarea id="silentEditAnswer" ...></textarea>

          <label for="silentEditAnswer">Edit answer:</label>
          <textarea id="silentEditAnswer" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>
          <div style="margin-top:0.5rem;">
            <button id="silentSaveEditBtn">Save</button>
            <button id="silentCancelEditBtn" class="secondary">Cancel</button>
          </div>
        </div>

        <div style="margin-top:0.75rem;">
          <button id="showAnswerBtn">Show Answer</button>
          <!-- next card button for silent study-ahead -->
          <button id="silentNextCardBtn" class="secondary hidden">Next Card</button>
        </div>
        <div id="silentRatingButtons" class="hidden" style="margin-top:0.5rem;">
  <span>How was that?</span>

  <div class="ratingRow">
    <div class="ratingItem">
      <button data-rating="again">Again</button>
      <span id="hint-again" class="dueHint"></span>
    </div>

    <div class="ratingItem">
      <button data-rating="hard">Hard</button>
      <span id="hint-hard" class="dueHint"></span>
    </div>

    <div class="ratingItem">
      <button data-rating="good">Good</button>
      <span id="hint-good" class="dueHint"></span>
    </div>

    <div class="ratingItem">
      <button data-rating="easy">Easy</button>
      <span id="hint-easy" class="dueHint"></span>
    </div>
  </div>
</div>
        <!-- Completion controls for silent mode -->
        <div id="silentCompletionControls" class="hidden" style="margin-top:0.75rem;">
          <button id="silentMainMenuBtn">Main Menu</button>
          <button id="silentStudyAheadBtn" class="secondary">Study Ahead in this Deck</button>
        </div>
      </div>
    </div>
  </div>
<!-- ===== Add Card Modal (during study) ===== -->
<div id="addCardModal" class="modal hidden" aria-hidden="true">
  <div class="modalBackdrop"></div>

  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="addCardModalTitle">
    <div class="row" style="justify-content:space-between;align-items:center;">
      <h3 id="addCardModalTitle" style="margin:0;">Add a card to this deck</h3>
      <button id="addCardModalCloseBtn" class="secondary small" type="button">Close</button>
    </div>

    <div style="margin-top:0.75rem;">
  <label for="addCardModalQuestionLang">Question language (TTS)</label>
  <select id="addCardModalQuestionLang"></select>

  <label for="addCardModalQuestion">Question</label>
  <textarea id="addCardModalQuestion" placeholder="Enter question" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>
</div>

<div style="margin-top:0.75rem;">
  <label for="addCardModalAnswerLang">Answer language (TTS)</label>
  <select id="addCardModalAnswerLang"></select>

  <label for="addCardModalAnswer">Answer</label>
  <textarea id="addCardModalAnswer" placeholder="Enter answer" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>
</div>

    <div class="row" style="margin-top:0.75rem;">
      <button id="addCardModalSaveBtn" type="button">Save Card</button>
      <button id="addCardModalCancelBtn" class="secondary" type="button">Cancel</button>
      <span id="addCardModalStatus" style="font-size:0.85rem;color:#9ca3af;"></span>
    </div>
  </div>
</div>

<!-- ===== Instructions Modal ===== -->
<div id="instructionsModal" class="modal hidden" aria-hidden="true">
  <div class="modalBackdrop"></div>

  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="instructionsModalTitle">
    <div class="row" style="justify-content:space-between;align-items:center;">
      <h3 id="instructionsModalTitle" style="margin:0;">How ZenCards Works</h3>
      <button id="instructionsCloseBtn" class="secondary small" type="button">Close</button>
    </div>

    <div style="margin-top:0.75rem;max-height:70vh;overflow:auto;">

      <h3>üìä Ratings (Again / Hard / Good / Easy)</h3>
      <p style="color:#9ca3af;margin-top:0.25rem;">
        Ratings decide when you‚Äôll see the card again. ‚ÄúAgain‚Äù brings it back soonest, ‚ÄúEasy‚Äù pushes it out the farthest.
      </p>
      <ul style="margin-top:0.5rem;">
        <li><strong>Again</strong> ‚Äî you didn‚Äôt remember it (restarts the learning ladder).</li>
        <li><strong>Hard</strong> ‚Äî you remembered, but it was tough (slower progress).</li>
        <li><strong>Good</strong> ‚Äî you remembered normally (standard progress).</li>
        <li><strong>Easy</strong> ‚Äî you remembered instantly (faster progress).</li>
      </ul>

      <hr style="border:0;border-top:1px solid #111827;margin:1rem 0;" />

      <h3>üé§ When to say voice commands</h3>
      <ul>
        <li><strong>After the question</strong>: you can say <em>repeat question</em> or <em>go to next card</em>.</li>
        <li><strong>After the answer</strong>: say your rating (<em>again / hard / good / easy</em>).</li>
        <li><strong>Any time</strong>: <em>pause study session</em>, <em>resume study session</em>, <em>go to the main menu</em>.</li>
      </ul>

      <hr style="border:0;border-top:1px solid #111827;margin:1rem 0;" />

      <h3>‚û°Ô∏è Next Card</h3>
      <p style="color:#9ca3af;margin-top:0.25rem;">
        Say <strong>‚Äúgo to next card‚Äù</strong> to skip the current card and immediately move forward.
      </p>

      <hr style="border:0;border-top:1px solid #111827;margin:1rem 0;" />

      <h3>üîá Mute Microphone (Hands-Free mode)</h3>
      <p style="color:#9ca3af;margin-top:0.25rem;">
        If you need time to think or you‚Äôre in a noisy place, you can temporarily stop listening.
      </p>
      <ul>
        <li>Say <strong>‚Äúmute microphone‚Äù</strong></li>
        <li>Then say a duration: <strong>10 / 20 / 30 / 40 / 50 / 60</strong> seconds</li>
        <li>While muted, ZenCards will not process commands until the timer ends.</li>
      </ul>

      <hr style="border:0;border-top:1px solid #111827;margin:1rem 0;" />

      <h3>üó£Ô∏è Full voice command list</h3>
      <ul>
        <li><strong>again</strong>, <strong>hard</strong>, <strong>good</strong>, <strong>easy</strong> ‚Äî rate the card</li>
        <li><strong>go to next card</strong> ‚Äî skip ahead</li>
        <li><strong>repeat question</strong></li>
        <li><strong>repeat answer</strong></li>
        <li><strong>pause study session</strong></li>
        <li><strong>resume study session</strong></li>
        <li><strong>go to the main menu</strong></li>
        <li><strong>mute microphone</strong> (then say: 10/20/30/40/50/60)</li>
      </ul>

    </div>
  </div>
</div>

  <script>

    // ===================== SUPABASE CONFIG =====================
const SUPABASE_URL = "https://elpfcnnrripftxoqeckv.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVscGZjbm5ycmlwZnR4b3FlY2t2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4NTk5MzQsImV4cCI6MjA4MDQzNTkzNH0.uiLHVcRfMXu0V7QRW41TARMIy-Hbhovc4h9uYFzzGLQ";
    const { createClient } = window.supabase;
    window.supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
        storage: window.localStorage,
        storageKey: "zencards-auth",
      },
    });

    // ===== Delete Account Modal =====
    function showDeleteAccountModal() {
      const modal = document.createElement('div');
      modal.style.position = 'fixed';
      modal.style.top = '0';
      modal.style.left = '0';
      modal.style.width = '100vw';
      modal.style.height = '100vh';
      modal.style.background = 'rgba(0,0,0,0.45)';
      modal.style.display = 'flex';
      modal.style.alignItems = 'center';
      modal.style.justifyContent = 'center';
      modal.style.zIndex = '20000';
      modal.innerHTML = `
        <div style="background:#1e293b;padding:2rem 2.5rem;border-radius:1rem;max-width:95vw;width:350px;box-shadow:0 8px 32px #000a;">
          <h2 style="color:#fff;margin-bottom:1rem;">Delete Account</h2>
          <p style="color:#f87171;margin-bottom:1rem;">This will permanently delete your account and all your data. This cannot be undone.</p>
          <input id="deleteAccountPassword" type="password" placeholder="Enter your password" style="width:100%;padding:0.6rem;margin-bottom:1rem;border-radius:0.5rem;border:1px solid #334155;background:#0f172a;color:#fff;" />
          <div id="deleteAccountError" style="color:#f87171;font-size:0.95em;margin-bottom:0.5rem;display:none;"></div>
          <button id="confirmDeleteAccountBtn" class="btn danger" style="width:100%;margin-bottom:0.5rem;">Delete My Account</button>
          <button id="cancelDeleteAccountBtn" class="btn secondary" style="width:100%;background:#334155;color:#fff;">Cancel</button>
        </div>
      `;
      document.body.appendChild(modal);

      document.getElementById('cancelDeleteAccountBtn').onclick = () => modal.remove();
      document.getElementById('deleteAccountPassword').onkeydown = (e) => { if (e.key === 'Enter') document.getElementById('confirmDeleteAccountBtn').click(); };
      document.getElementById('confirmDeleteAccountBtn').onclick = async () => {
        const password = document.getElementById('deleteAccountPassword').value;
        const errorDiv = document.getElementById('deleteAccountError');
        errorDiv.style.display = 'none';
        if (!password) {
          errorDiv.textContent = 'Password required.';
          errorDiv.style.display = 'block';
          return;
        }
        // Re-authenticate user
        const { data: { user }, error: userError } = await supabaseClient.auth.getUser();
        if (!user || userError) {
          errorDiv.textContent = 'Could not verify user.';
          errorDiv.style.display = 'block';
          return;
        }
        const { error: signInError } = await supabaseClient.auth.signInWithPassword({ email: user.email, password });
        if (signInError) {
          errorDiv.textContent = 'Incorrect password.';
          errorDiv.style.display = 'block';
          return;
        }
        // Confirm deletion
        if (!confirm('Are you sure you want to permanently delete your account and cancel your subscription? This cannot be undone.')) return;
        // Call Supabase Edge Function to delete account and cancel subscription
        try {
          console.log('[DeleteAccount] Attempting to call edge function...');
          const { data: sessionData } = await supabaseClient.auth.getSession();
          const accessToken = sessionData?.session?.access_token || '';
          const resp = await fetch('https://elpfcnnrripftxoqeckv.supabase.co/functions/v1/delete-account', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${accessToken}`
            },
            body: JSON.stringify({ user_id: user.id, email: user.email })
          });
          console.log('[DeleteAccount] Response status:', resp.status);
          const text = await resp.text();
          console.log('[DeleteAccount] Raw response:', text);
          let result = {};
          try { result = JSON.parse(text); } catch (err) { result = { error: 'Invalid JSON response', raw: text }; }
          if (!resp.ok || result.error) {
            errorDiv.textContent = result.error || 'Failed to delete account. Please contact support.';
            errorDiv.style.display = 'block';
            return;
          }
          await supabaseClient.auth.signOut();
          modal.remove();
          alert('Your account and subscription have been deleted.');
          window.location.reload();
        } catch (e) {
          console.error('[DeleteAccount] Exception:', e);
          errorDiv.textContent = 'Failed to delete account. Please contact support.';
          errorDiv.style.display = 'block';
        }
      };
    }

    document.getElementById('deleteAccountBtn')?.addEventListener('click', showDeleteAccountModal);

    // On every session change, sync to Capacitor Preferences (native only)
    (async function setupSessionSync() {
      const isNative = !!window.Capacitor || !!window.cordova || !!window.webkit?.messageHandlers?.bridge;
      if (!isNative) return;
      try {
        const { Preferences } = await import('@capacitor/preferences');
        window.supabaseClient.auth.onAuthStateChange(async (_event, session) => {
          try {
            if (session) {
              await Preferences.set({ key: 'zencards-auth', value: localStorage.getItem('zencards-auth') || '' });
            } else {
              await Preferences.remove({ key: 'zencards-auth' });
            }
          } catch (e) {
            console.warn('[Capacitor] Could not sync session to Preferences:', e);
          }
        });
      } catch (e) {
        console.warn('[Capacitor] Could not set up Preferences sync:', e);
      }
    })();
// ===================== BFCache SAFETY (Safari/iOS, back button) =====================
// If Safari restores this page from BFCache, JS state can be stale.
// Force a hard reload so auth + UI + listeners re-bootstrap cleanly.
window.addEventListener("pageshow", (event) => {
  const nav = performance.getEntriesByType?.("navigation")?.[0];
  const isBFCache =
    event.persisted === true ||
    (nav && nav.type === "back_forward") ||
    (performance && performance.navigation && performance.navigation.type === 2);

  if (isBFCache) {
    console.warn("[BFCache] pageshow restore detected -> hard reload");
    window.location.reload();
  }
});

// ‚úÖ Prevent double-init on iOS BFCache / pageshow
window.__zc_app_inited = window.__zc_app_inited || false;
window.__zc_auth_sub = window.__zc_auth_sub || null;
window.__zc_last_healthcheck_ms = window.__zc_last_healthcheck_ms || 0;


window.setSyncLock = window.setSyncLock || function () {};
window.lockUI = window.lockUI || function () {};

let currentUser = null;
let isSigningOut = false;
async function signOutFromApp() {
  if (isSigningOut) return;
  isSigningOut = true;

  try {
    console.log("[LOGOUT] signing out...");

    // Stop any study audio/listening
    try { stopAllAudio(); } catch (_) {}

    // Supabase sign out
    await supabaseClient.auth.signOut();

    // Clear ONLY your app‚Äôs local state (not everything)
    localStorage.removeItem("srsDecks");
    localStorage.removeItem("srsSchedule");

    // Clear Supabase session storage key
    localStorage.removeItem("zencards-auth");

    currentUser = null;
    hasLoadedRemote = false;
    pendingSaveBeforeRemote = false;

    console.log("[LOGOUT] done, redirecting to index.html");
    window.location.replace("index.html"); // Only redirect on explicit logout
  } catch (e) {
    console.error("[LOGOUT] failed:", e);
    alert("Logout failed. Check console.");
  } finally {
    isSigningOut = false;
  }
}



// ===== AUTH DOM REFERENCES =====
const deckBadge = document.getElementById("deckBadge");
// ===== AUTH UI refs =====
const authLoggedIn = document.getElementById("authLoggedIn");
const userEmailLabel = document.getElementById("userEmailLabel");
const signOutBtn = document.getElementById("logOutBtn");

// Optional buttons (keep if you use them)
const manageBillingBtn = document.getElementById("manageBillingBtn");
const studyAddCardBtn = document.getElementById("studyAddCardBtn");
const addCardModal = document.getElementById("addCardModal");
const addCardModalCloseBtn = document.getElementById("addCardModalCloseBtn");
const addCardModalCancelBtn = document.getElementById("addCardModalCancelBtn");
const addCardModalSaveBtn = document.getElementById("addCardModalSaveBtn");
const addCardModalQuestion = document.getElementById("addCardModalQuestion");
const addCardModalAnswer = document.getElementById("addCardModalAnswer");
const addCardModalStatus = document.getElementById("addCardModalStatus");
// ===== Instructions modal refs =====
const openInstructionsBtn = document.getElementById("openInstructionsBtn");
const instructionsModal = document.getElementById("instructionsModal");
const instructionsCloseBtn = document.getElementById("instructionsCloseBtn");

// ===== BUTTON EVENT HOOKS =====

if (signOutBtn) {
  signOutBtn.addEventListener("click", () => {
    signOutFromApp();
  });
}
// ===================== BILLING (STRIPE PORTAL) =====================

async function openStripeCustomerPortal() {
  try {
    // Make sure we have a session token to authorize the edge function
    const { data: sessionData, error: sessErr } = await supabaseClient.auth.getSession();
    if (sessErr) throw sessErr;

    const session = sessionData?.session;
    if (!session?.access_token) {
      alert("No active session. Please log in again.");
      window.location.replace("index.html");
      return;
    }

    // Call your edge function: create-portal-link
    const fnUrl = `${SUPABASE_URL}/functions/v1/create-portal-link`;

    const res = await fetch(fnUrl, {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "apikey": SUPABASE_ANON_KEY,
    Authorization: `Bearer ${session.access_token}`,
  },
  body: JSON.stringify({
    return_url: getBaseUrlForSameFolder() + "app.html",
  }),
});

    const json = await res.json().catch(() => ({}));

    if (!res.ok) {
      console.error("[PORTAL] Edge function error:", json);
      alert("Could not open billing portal. Check console.");
      return;
    }

    const url = json?.url;
    if (!url) {
      console.error("[PORTAL] No url returned:", json);
      alert("Billing portal link not returned. Check console.");
      return;
    }

    // Redirect to Stripe portal
    window.location.assign(url);
  } catch (e) {
    console.error("[PORTAL] Failed:", e);
    alert("Could not open billing portal. Check console.");
  }
}

// Hook up the button
if (manageBillingBtn) {
  manageBillingBtn.addEventListener("click", openStripeCustomerPortal);
}


    // ===================== DATA & STORAGE =====================
    let decks = [];
    // schedule[deckId_cardId] = {
    //   phase: "ladder" | "mature1" | "mature2",
    //   level: 1..5 (only for ladder),
    //   intervalMinutes: number,
    //   timesGraduated: number,
    //   dueTime: ms since epoch
    // }
    let schedule = {};
    let hasLoadedRemote = false;

function getCurrentState() {
  return {
    decks,
    schedule,
  };
}

    const MINUTES_PER_DAY = 1440;
    const LADDER_LEVEL_MINUTES = {
      1: 5,                 // level 1: ~5 minutes
      2: 10,                // level 2: 10 minutes
      3: 1 * MINUTES_PER_DAY,   // 1 day
      4: 3 * MINUTES_PER_DAY,   // 3 days
      5: 7 * MINUTES_PER_DAY    // 7 days
    };

    // threshold for "show again in this session" behavior
    const SHORT_REVIEW_THRESHOLD_MINUTES = 10;

    function loadFromStorage() {
  try {
    const d = localStorage.getItem("srsDecks");
    decks = d ? JSON.parse(d) : [];
  } catch (_) {
    decks = [];
  }
  if (!Array.isArray(decks)) decks = [];

  try {
    const s = localStorage.getItem("srsSchedule");
    schedule = s ? JSON.parse(s) : {};
  } catch (_) {
    schedule = {};
  }
  if (typeof schedule !== "object" || schedule === null) schedule = {};

  // ‚úÖ Only create sample deck if NOT logged in
  if (decks.length === 0 && !currentUser) {
    decks = [{
      id: "deck1",
      name: "Sample Deck",
      qLang: "en-US",
aLang: "en-US",
      cards: [
        { id: "c1", question: "What does DOMS stand for?", answer: "Delayed onset muscle soreness." },
        { id: "c2", question: "In a dumbbell incline press, what area of the chest is emphasized?", answer: "The upper chest, especially the clavicular head of the pectoralis major." }
      ]
    }];
  }
}

// ===================== SUPABASE SAVE QUEUE (prevents overlaps) =====================
let saveInFlight = false;
let saveQueued = false;
let pendingSaveBeforeRemote = false;

async function queueSaveToSupabase() {
  if (!currentUser) {
  pendingSaveBeforeRemote = true;
  console.warn("[QUEUE] No currentUser yet; deferring save");
  return;
}
  console.log("[QUEUE] queueSaveToSupabase() hit", {
    hasLoadedRemote,
    saveInFlight,
    saveQueued
  });

  try {
    // If remote hasn't loaded yet, allow a write ONLY if user exists
    if (!hasLoadedRemote) {
      const { data: u, error: userErr } = await supabaseClient.auth.getUser();

      console.log("[QUEUE] hasLoadedRemote=false; getUser check:", {
        userErr: userErr ? { message: userErr.message, name: userErr.name } : null,
        hasUser: !!u?.user,
        userId: u?.user?.id || null
      });

      if (userErr) {
        console.error("‚ùå [QUEUE] getUser error (this is why saves stop):", userErr);
        pendingSaveBeforeRemote = true;
        return;
      }

      if (!u?.user) {
        pendingSaveBeforeRemote = true;
        console.warn("‚è≥ [QUEUE] Deferring save until remote is loaded (no user yet)");
        return;
      }

      console.warn("‚úÖ [QUEUE] User exists; allowing save before remote load");
    }

    if (saveInFlight) {
      saveQueued = true;
      console.log("[QUEUE] saveInFlight=true -> queued next save");
      return;
    }

    saveInFlight = true;

    const res = await saveStateToSupabase();
    console.log("[QUEUE] saveStateToSupabase result:", res);
  } catch (e) {
    console.error("‚ùå [QUEUE] queueSaveToSupabase crashed:", e);
  } finally {
    saveInFlight = false;

    if (saveQueued) {
      saveQueued = false;
      console.log("[QUEUE] running queued save now‚Ä¶");
      // important: await so errors don‚Äôt get swallowed again
      await queueSaveToSupabase();
    }
  }
}


  function saveDecks() {
  console.log("üíæ saveDecks() firing. decks.length =", decks.length);

  localStorage.setItem("srsDecks", JSON.stringify(decks));

  // THIS is the critical wiring line:
 queueSaveToSupabase().catch(e => console.error("‚ùå queueSaveToSupabase rejected:", e));
}


function saveSchedule() {
  console.log("üü© saveSchedule() firing. schedule keys =", Object.keys(schedule || {}).length);
  localStorage.setItem("srsSchedule", JSON.stringify(schedule));

  queueSaveToSupabase().catch(e => console.error("‚ùå queueSaveToSupabase rejected:", e));
}

// ===================== SUPABASE SYNC HELPERS =====================
async function saveStateToSupabase() {
  console.log("[SAVE] called", new Date().toISOString(), {
    hasLoadedRemote,
    decksLen: Array.isArray(decks) ? decks.length : null,
    hasSchedule: !!schedule
  });

  try {
    // MUST have a logged-in user
    const { data: userData, error: userErr } = await supabaseClient.auth.getUser();

    console.log("[SAVE] getUser()", {
      userErr: userErr
        ? { message: userErr.message, name: userErr.name, status: userErr.status }
        : null,
      userId: userData?.user?.id || null,
      email: userData?.user?.email || null
    });

    if (userErr) {
      console.error("[SAVE] getUser error:", userErr);
      return { ok: false, step: "getUser", error: userErr };
    }

    const user = userData?.user;
    if (!user) {
      console.warn("[SAVE] No user ‚Äî skipping Supabase save");
      return { ok: false, step: "no_user" };
    }

    const payload = {
      user_id: user.id,
      state_json: { decks, schedule },
      updated_at: new Date().toISOString()
    };

    console.log("[SAVE] about to upsert payload", {
      table: "zencards_state",
      user_id: payload.user_id,
      stateSize: JSON.stringify(payload.state_json || {}).length
    });

    const { data, error, status } = await supabaseClient
      .from("zencards_state")
      .upsert(payload, { onConflict: "user_id" });

    console.log("[SAVE] upsert response", {
      status,
      error: error
        ? { message: error.message, code: error.code, details: error.details, hint: error.hint }
        : null,
      data
    });

    if (error) {
      console.error("[SAVE] Supabase save failed:", error);
      if (typeof setAuthStatus === "function") {
        setAuthStatus("Supabase save failed: " + (error.message || "unknown"));
      }
      return { ok: false, step: "upsert", error };
    }

    console.log("‚úÖ [SAVE] Supabase save OK");
    return { ok: true, status, data };
  } catch (e) {
    console.error("[SAVE] crashed:", e);
    return { ok: false, step: "crash", error: e };
  }
}

async function loadStateFromSupabase() {
  console.log("‚úÖ loadStateFromSupabase called");

  console.log("üì• loadStateFromSupabase() start");

  try {
    // Make sure token is fresh
    try { await supabaseClient.auth.refreshSession(); } catch (_) {}

    // Get user
    const { data: userData, error: userErr } = await supabaseClient.auth.getUser();
    const user = userData?.user;

    console.log("üü¶ loadStateFromSupabase getUser()", { user, userErr });

    // ‚úÖ If no user, we still "unlock" in finally.
    if (!user) {
      console.warn("üü® No user in loadStateFromSupabase(). Skipping remote load.");
      return;
    }

    // Load row
    const { data, error } = await supabaseClient
      .from("zencards_state")
      .select("state_json, updated_at")
      .eq("user_id", user.id)
      .maybeSingle();

    if (error) {
      console.error("üü• Supabase load error:", error);
      setAuthStatus("Supabase load error: " + (error.message || "unknown"));
      return;
    }

    console.log("üü¶ Supabase load row:", data);

    // ‚úÖ FIRST-TIME USER CASE: no row yet
    if (!data?.state_json) {
      console.log("üü® No remote state yet; creating from local‚Ä¶");
      await queueSaveToSupabase();     // create their row via queue/locking
return;                        // ‚úÖ still safe because finally runs
    }

    // Apply remote -> memory
    const remote = data.state_json;

    if (Array.isArray(remote.decks)) decks = remote.decks;
    if (remote.schedule && typeof remote.schedule === "object") schedule = remote.schedule;

    // Persist remote -> local
    localStorage.setItem("srsDecks", JSON.stringify(decks));
    localStorage.setItem("srsSchedule", JSON.stringify(schedule));

    console.log("‚úÖ Loaded remote state into app + localStorage");
  } catch (e) {
    console.error("‚ùå loadStateFromSupabase crashed:", e);
  } finally {
    // ‚úÖ CRITICAL: ALWAYS release the gate so saves can proceed
    hasLoadedRemote = true;
    console.log("‚úÖ hasLoadedRemote = true");

    setSyncLock(false); // unlock UI if you use this lock

    // ‚úÖ CRITICAL: flush any deferred save that happened before remote loaded
    if (pendingSaveBeforeRemote) {
      pendingSaveBeforeRemote = false;
      console.log("‚è© Flushing deferred save now that remote is loaded/checked");
     queueSaveToSupabase().catch(e => console.error("‚ùå queueSaveToSupabase rejected:", e));
    }
  }
}
initAppSession().catch(e => console.error("‚ùå initAppSession crashed:", e));
function restoreLastDeckSelection() {
  const lastDeckId = getLastDeckId();
  if (!lastDeckId) return;

  if (decks && decks.some(d => d.id === lastDeckId)) {
    selectedDeckId = lastDeckId;
    if (deckSelect) deckSelect.value = lastDeckId;
  }
}
async function ensureSessionHealthy({ reason = "unknown", redirectOnFail = true } = {}) {
  // throttle: don't spam refresh calls
  const now = Date.now();
  if (now - (window.__zc_last_healthcheck_ms || 0) < 1500) return true;
  window.__zc_last_healthcheck_ms = now;

  try {
    // Try to refresh tokens (safe even if already fresh)
    try { await supabaseClient.auth.refreshSession(); } catch (_) {}

    const { data: sessData } = await supabaseClient.auth.getSession();
    const session = sessData?.session || null;

    if (!session) {
      console.warn("[AUTH] ensureSessionHealthy: no session", { reason });
      // Do not redirect to index.html on app version; show message instead
      showSessionError("No session found. Please log in again.");
      return false;
    }

    const { data: userData, error: userErr } = await supabaseClient.auth.getUser();
    if (userErr || !userData?.user) {
      console.warn("[AUTH] ensureSessionHealthy: getUser failed", {
        reason,
        userErr: userErr ? { message: userErr.message, name: userErr.name, status: userErr.status } : null
      });

      // If the session is present but user lookup fails, it's usually a broken token state.
      // Clear all Supabase auth tokens and force relogin.
      try {
        for (let i = localStorage.length - 1; i >= 0; i--) {
          const k = localStorage.key(i);
          if (k && (k.endsWith("-auth-token") || k === "zencards-auth")) {
            localStorage.removeItem(k);
          }
        }
      } catch (_) {}
      try { await supabaseClient.auth.signOut(); } catch (_) {}

      // Do not redirect to index.html on app version; show message instead
      showSessionError("Session invalid or expired. Please log in again.");
      return false;
    }

    // Good state: keep globals aligned
    currentUser = userData.user;
    return true;
  } catch (e) {
    console.warn("[AUTH] ensureSessionHealthy crashed", { reason, e });
    // Do not redirect to index.html on app version; show message instead
    showSessionError("Session error. Please log in again.");
    return false;
  }
}

async function initAppSession() {
    // ‚úÖ install auth listener once
  if (!window.__zc_auth_sub) {
    const { data } = supabaseClient.auth.onAuthStateChange((event, session) => {
      console.log("[AUTH] event:", event, { hasSession: !!session });

      if (event === "SIGNED_OUT") {
         if (isSigningOut) return; 
        currentUser = null;
        hasLoadedRemote = false;
        window.location.replace("index.html");
        return;
      }

      if (session?.user) {
        currentUser = session.user;
        if (userEmailLabel) userEmailLabel.textContent = currentUser.email || "";
        if (authLoggedIn) authLoggedIn.classList.remove("hidden");
      }
    });

    window.__zc_auth_sub = data?.subscription || null;
  }

  console.log("[BOOT] initAppSession()");
 
  // 1) Check session first (fast)
  // ‚úÖ Heal / verify session before deciding
const ok = await ensureSessionHealthy({ reason: "boot", redirectOnFail: false });
if (!ok) {
  console.warn("[BOOT] Session not healthy. Not redirecting to index.html (app mode)");
  // showSessionError will handle UI
  return;
}

// Session is healthy here
const { data: sessionData } = await supabaseClient.auth.getSession();
const session = sessionData?.session || null;

if (!session?.user) {
  console.warn("[BOOT] No session user after healthy check. Not redirecting to index.html (app mode)");
  showSessionError("No user found in session. Please log in again.");
  return;
}

currentUser = session.user;

  if (userEmailLabel) userEmailLabel.textContent = currentUser.email || "";
  if (authLoggedIn) authLoggedIn.classList.remove("hidden");

  // 4) Load local immediately so app feels instant
  loadFromStorage();
  refreshDeckSelect();
  restoreLastDeckSelection();
  refreshCardsList();
  refreshCardLanguageDropdownsForCurrentDeck(null);


  // 5) Load remote once (this will set hasLoadedRemote=true in finally)
  await loadStateFromSupabase();

  // 6) After remote load, re-render (remote may overwrite local)
  refreshDeckSelect();
  restoreLastDeckSelection();
  refreshCardsList();
  refreshCardLanguageDropdownsForCurrentDeck(null);


  console.log("[BOOT] done", { hasLoadedRemote, userId: currentUser?.id });
}

    function scheduleKey(deckId, cardId) {
      return `${deckId}_${cardId}`;
    }

    // NEW: simple Fisher-Yates shuffle helper (returns a new array)
    function shuffleArray(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
      }
      return a;
    }

    // Normalize old/new schedule entries into our new shape
    function normalizeScheduleEntry(raw) {
      const now = Date.now();
      if (!raw || typeof raw !== "object") {
        return {
          phase: "ladder",
          level: 1,
          intervalMinutes: LADDER_LEVEL_MINUTES[1],
          timesGraduated: 0,
          dueTime: now
        };
      }
      let phase = raw.phase || "ladder";
      let level = typeof raw.level === "number" ? raw.level : 1;
      let timesGraduated =
        typeof raw.timesGraduated === "number" ? raw.timesGraduated : 0;
      let intervalMinutes =
        typeof raw.intervalMinutes === "number" && raw.intervalMinutes > 0
          ? raw.intervalMinutes
          : (LADDER_LEVEL_MINUTES[level] || LADDER_LEVEL_MINUTES[1]);

      let dueTime;
      if (typeof raw.dueTime === "number") {
        dueTime = raw.dueTime;
      } else if (raw.dueDate) {
        const t = Date.parse(raw.dueDate);
        dueTime = isNaN(t) ? now : t;
      } else {
        dueTime = now;
      }

      return { phase, level, intervalMinutes, timesGraduated, dueTime };
    }

    // Core scheduling logic implementing your rules
    function computeNextState(entry, ratingKey) {
      const s = normalizeScheduleEntry(entry);
      const result = { ...s };

      // "again" always: reset to level 1, ladder, 5 minutes
      if (ratingKey === "again") {
        result.phase = "ladder";
        result.level = 1;
        result.intervalMinutes = LADDER_LEVEL_MINUTES[1];
        // keep timesGraduated so we know if it was ever mature before
        return result;
      }

      // Ladder phase: 5 levels
      if (s.phase === "ladder") {
        let lvl = s.level || 1;

        if (ratingKey === "hard") {
          // Stay on same level, same interval as that level
          result.level = lvl;
          result.intervalMinutes = LADDER_LEVEL_MINUTES[lvl];
          return result;
        }

        if (ratingKey === "good" || ratingKey === "easy") {
          const jump = ratingKey === "good" ? 1 : 2;
          let target = lvl + jump;

          // Still within ladder (1‚Äì5)
          if (target <= 5) {
            result.level = target;
            result.intervalMinutes = LADDER_LEVEL_MINUTES[target];
            return result;
          }

          // We are "past level 5" -> enter mature phase
          const prevInterval = LADDER_LEVEL_MINUTES[lvl];
          const alreadyGraduated = (s.timesGraduated || 0) > 0;

          result.level = 0;
          result.phase = alreadyGraduated ? "mature2" : "mature1";
          result.timesGraduated = (s.timesGraduated || 0) + 1;

          if (result.phase === "mature1") {
            // First time past level 5:
            // hard: 1x, good: 1.75x, easy: 2.5x
            if (ratingKey === "good") {
              result.intervalMinutes = prevInterval * 1.75;
            } else {
              // easy from level 5 into mature1
              result.intervalMinutes = prevInterval * 2.5;
            }
          } else {
            // mature2 = after you've already been mature before,
            // passed through the ladder again and gone past level 5:
            // hard: 1.2x, good: 2x, easy: 2.5x
            const base = prevInterval;
            if (ratingKey === "hard") {
              result.intervalMinutes = base * 1.2;
            } else if (ratingKey === "good") {
              result.intervalMinutes = base * 2.0;
            } else {
              result.intervalMinutes = base * 2.5;
            }
          }

          return result;
        }
      }

      // Mature phases
      const base = s.intervalMinutes || MINUTES_PER_DAY;

      if (s.phase === "mature1") {
        // First mature phase: hard=1x, good=1.75x, easy=2.5x
        if (ratingKey === "hard") {
          result.intervalMinutes = base * 1.0;
        } else if (ratingKey === "good") {
          result.intervalMinutes = base * 1.75;
        } else if (ratingKey === "easy") {
          result.intervalMinutes = base * 2.5;
        }
        return result;
      }

      if (s.phase === "mature2") {
        // Second+ mature phase: hard=1.2x, good=2x, easy=2.5x
        if (ratingKey === "hard") {
          result.intervalMinutes = base * 1.2;
        } else if (ratingKey === "good") {
          result.intervalMinutes = base * 2.0;
        } else if (ratingKey === "easy") {
          result.intervalMinutes = base * 2.5;
        }
        return result;
      }

      // Fallback: keep same interval
      return result;
    }

    // Apply scheduling (mutates global schedule) ‚Äî now returns the new entry
    function applyAnkiScheduling(deckId, cardId, ratingKey) {
      const key = scheduleKey(deckId, cardId);
      const existing = schedule[key] || {};
      const nextState = computeNextState(existing, ratingKey);
      const now = Date.now();
      nextState.dueTime = now + nextState.intervalMinutes * 60000;
      schedule[key] = nextState;
      saveSchedule();
      // Update deck dropdown counts when schedule changes
      refreshDeckSelect();
      return nextState;
    }

    // NEW: apply "show again tomorrow" behavior for automatic mode
    function applyTomorrowScheduling(deckId, cardId) {
      const key = scheduleKey(deckId, cardId);
      const existing = normalizeScheduleEntry(schedule[key] || {});
      const now = Date.now();
      const nextState = { ...existing };
      // Keep phase/level/interval the same, just snooze dueTime by 1 day
      nextState.dueTime = now + MINUTES_PER_DAY * 60000;
      schedule[key] = nextState;
      saveSchedule();
      refreshDeckSelect();
      return nextState;
    }

    // Preview next interval (in minutes) without changing schedule
    function previewIntervalMinutes(deckId, cardId, ratingKey) {
      const key = scheduleKey(deckId, cardId);
      const existing = schedule[key] || {};
      const nextState = computeNextState(existing, ratingKey);

      const minutes =
        typeof nextState.intervalMinutes === "number" && nextState.intervalMinutes > 0
          ? nextState.intervalMinutes
          : LADDER_LEVEL_MINUTES[1]; // default to 5 minutes

      return minutes;
    }

    // ===================== DECK & CARD UI =====================
    const editDeckNameBtn = document.getElementById("editDeckNameBtn");

function updateEditDeckNameBtnState() {
  if (!editDeckNameBtn) return;
  // Disable if no deck is selected or no decks exist
  editDeckNameBtn.disabled = !selectedDeckId || !getDeckById(selectedDeckId);
}

if (editDeckNameBtn) {
  editDeckNameBtn.addEventListener("click", () => {
    if (!selectedDeckId) return;
    const deck = getDeckById(selectedDeckId);
    if (!deck) return;
    const newName = prompt("Edit deck name:", deck.name);
    if (newName && newName.trim() && newName.trim() !== deck.name) {
      deck.name = newName.trim();
      saveDecks();
      refreshDeckSelect();
      refreshCardsList();
    }
    updateEditDeckNameBtnState();
  });
}

// Call this after deck select is refreshed
const _origRefreshDeckSelect = refreshDeckSelect;
refreshDeckSelect = function() {
  _origRefreshDeckSelect.apply(this, arguments);
  updateEditDeckNameBtnState();
};
    const deckSelect = document.getElementById("deckSelect");
    const newDeckNameInput = document.getElementById("newDeckName");
    const addDeckBtn = document.getElementById("addDeckBtn");
    const deleteDeckBtn = document.getElementById("deleteDeckBtn");

    // Disable/enable Add Deck button based on input
function updateAddDeckButtonState() {
  const name = (newDeckNameInput?.value || "").trim();
  if (addDeckBtn) addDeckBtn.disabled = name.length === 0;
}

// Run once on load
updateAddDeckButtonState();

// Update live while typing
if (newDeckNameInput) {
  newDeckNameInput.addEventListener("input", updateAddDeckButtonState);
}

    const cardQuestionInput = document.getElementById("cardQuestion");
    const cardAnswerInput = document.getElementById("cardAnswer");
    const addCardBtn = document.getElementById("addCardBtn");
    const updateCardBtn = document.getElementById("updateCardBtn");
    const cardsListDiv = document.getElementById("cardsList");
    const selectedCardInfo = document.getElementById("selectedCardInfo");
    // Main editor language selects
const cardQuestionLangSelect = document.getElementById("cardQuestionLang");
const cardAnswerLangSelect = document.getElementById("cardAnswerLang");

// Add Card Modal language selects
const addCardModalQuestionLangSelect = document.getElementById("addCardModalQuestionLang");
const addCardModalAnswerLangSelect = document.getElementById("addCardModalAnswerLang");

// Inline edit language selects (if you added them)
const silentEditQuestionLangSelect = document.getElementById("silentEditQuestionLang");
const silentEditAnswerLangSelect   = document.getElementById("silentEditAnswerLang");
const voiceEditQuestionLangSelect  = document.getElementById("voiceEditQuestionLang");
const voiceEditAnswerLangSelect    = document.getElementById("voiceEditAnswerLang");

    // ===== Move card UI =====
const moveDeckSelect = document.getElementById("moveDeckSelect");
const moveCardBtn = document.getElementById("moveCardBtn");

function refreshCardLanguageDropdownsForCurrentDeck(cardObj = null) {
  const deck = getDeckById(selectedDeckId);

  // Main editor
  fillLangSelect(cardQuestionLangSelect, getDefaultQLangFor(deck, cardObj));
  fillLangSelect(cardAnswerLangSelect, getDefaultALangFor(deck, cardObj));

  // Add modal
  fillLangSelect(addCardModalQuestionLangSelect, getDefaultQLangFor(deck, cardObj));
  fillLangSelect(addCardModalAnswerLangSelect, getDefaultALangFor(deck, cardObj));

  // Inline edit (optional)
  fillLangSelect(silentEditQuestionLangSelect, getDefaultQLangFor(deck, cardObj));
  fillLangSelect(silentEditAnswerLangSelect, getDefaultALangFor(deck, cardObj));
  fillLangSelect(voiceEditQuestionLangSelect, getDefaultQLangFor(deck, cardObj));
  fillLangSelect(voiceEditAnswerLangSelect, getDefaultALangFor(deck, cardObj));
}


function refreshMoveDeckSelect() {
  if (!moveDeckSelect) return;
  moveDeckSelect.innerHTML = "";

  decks.forEach(deck => {
    const opt = document.createElement("option");
    opt.value = deck.id;
    opt.textContent = deck.name;
    moveDeckSelect.appendChild(opt);
  });

  // Default to current deck (or first deck)
  if (selectedDeckId) moveDeckSelect.value = selectedDeckId;

  // Enable button only when a card is selected and there's at least 1 other deck
  const hasOtherDeck =
    decks.filter(d => d.id !== selectedDeckId).length > 0;

  if (moveCardBtn) {
    moveCardBtn.disabled = !selectedCardId || !hasOtherDeck;
  }
}

    // ================= IMAGE INSERT HELPERS =================
function insertImageTagInto(textarea, imgSrc) {
  if (!textarea || !imgSrc) return;

  const tag = `\n<img src="${imgSrc}" alt="" style="max-width:100%;height:auto;" />\n`;

  const start = textarea.selectionStart ?? textarea.value.length;
  const end   = textarea.selectionEnd ?? textarea.value.length;

  textarea.value =
    textarea.value.slice(0, start) +
    tag +
    textarea.value.slice(end);

  textarea.focus();
  const pos = start + tag.length;
  textarea.selectionStart = textarea.selectionEnd = pos;
}

// Allow dragging & dropping images directly onto a textarea
function makeTextareaAcceptImageDrops(textarea) {
  if (!textarea) return;

  textarea.addEventListener("dragover", (e) => {
    e.preventDefault();
    textarea.classList.add("drag-hover");
  });

  textarea.addEventListener("dragenter", (e) => {
    e.preventDefault();
    textarea.classList.add("drag-hover");
  });

  textarea.addEventListener("dragleave", (e) => {
    e.preventDefault();
    textarea.classList.remove("drag-hover");
  });

  textarea.addEventListener("drop", (e) => {
    e.preventDefault();
    textarea.classList.remove("drag-hover");

    const dt = e.dataTransfer;
    if (!dt || !dt.files || dt.files.length === 0) return;

    const file = dt.files[0];
    if (!file.type.startsWith("image/")) return;

    const reader = new FileReader();
    reader.onload = (ev) => {
      insertImageTagInto(textarea, ev.target.result);
    };
    reader.readAsDataURL(file);
  });
}

// Enable drag/drop on the main editor textareas
makeTextareaAcceptImageDrops(cardQuestionInput);
makeTextareaAcceptImageDrops(cardAnswerInput);

// Insert image button: paste URL or pick a file (stored as data: URL)
document.querySelectorAll("[data-insert-image]").forEach(btn => {
  btn.addEventListener("click", () => {
    const targetId = btn.getAttribute("data-target");
    const textarea = document.getElementById(targetId);
    if (!textarea) return;

    const url = prompt(
      "Paste an image URL, or leave blank to choose a file from your device."
    );

    if (url && url.trim()) {
      insertImageTagInto(textarea, url.trim());
      return;
    }

    // If no URL, open a file picker and embed as data URL
    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = "image/*";
    fileInput.onchange = () => {
      const file = fileInput.files && fileInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        insertImageTagInto(textarea, e.target.result); // data:image/...
      };
      reader.readAsDataURL(file);
    };
    fileInput.click();
  });
});

    // NEW: Anki import elements
    const ankiImportInput   = document.getElementById("ankiImport");
    const ankiImportStatus  = document.getElementById("ankiImportStatus");
    const ankiImportHelpBtn = document.getElementById("ankiImportHelpBtn");

    let selectedDeckId = null;
    let selectedCardId = null;
    // ===================== CONTINUE WHERE I LEFT OFF =====================
const LAST_DECK_KEY = "zc_lastDeckId";
const LAST_MODE_KEY = "zc_lastMode";
const AUTO_RESUME_KEY = "zc_autoResume"; // optional toggle (default false)

function saveLastDeckId(deckId) {
  if (!deckId) return;
  localStorage.setItem(LAST_DECK_KEY, String(deckId));
}

function saveLastMode(mode) {
  if (!mode) return;
  localStorage.setItem(LAST_MODE_KEY, String(mode));
}

function getLastDeckId() {
  return localStorage.getItem(LAST_DECK_KEY);
}

function getLastMode() {
  return localStorage.getItem(LAST_MODE_KEY);
}


    function getDeckById(id) {
      return decks.find(d => d.id === id) || null;
    }
    // ===== Languages for TTS dropdowns =====
const ZC_LANGS = [
  ["en-US", "English (US)"],
  ["en-GB", "English (UK)"],
  ["es-ES", "Spanish (Spain)"],
  ["es-MX", "Spanish (Mexico)"],
  ["fr-FR", "French"],
  ["de-DE", "German"],
  ["it-IT", "Italian"],
  ["pt-PT", "Portuguese (Portugal)"],
  ["pt-BR", "Portuguese (Brazil)"],
  ["ru-RU", "Russian"],
  ["ja-JP", "Japanese"],
  ["zh-CN", "Chinese (Mandarin)"],
  ["ko-KR", "Korean"],
  ["ar-SA", "Arabic"],
  ["hi-IN", "Hindi"],
];

function fillLangSelect(selectEl, defaultValue = "en-US") {
  if (!selectEl) return;
  selectEl.innerHTML = "";
  for (const [code, label] of ZC_LANGS) {
    const opt = document.createElement("option");
    opt.value = code;
    opt.textContent = label;
    selectEl.appendChild(opt);
  }
  selectEl.value = defaultValue;
  if (selectEl.value !== defaultValue) {
    // fallback if default isn't in list
    selectEl.value = "en-US";
  }
}

// returns the best default based on deck/card
function getDefaultQLangFor(deck, card) {
  return (card && card.qLang) || (deck && deck.qLang) || "en-US";
}
function getDefaultALangFor(deck, card) {
  return (card && card.aLang) || (deck && deck.aLang) || "en-US";
}


   // New: compute TOTAL counts per deck (new / learning / review)
// - new: no schedule yet
// - learning: phase === "ladder" (levels 1‚Äì5)
// - review: phase === "mature1" or "mature2" (i.e. past level 5)
function getDeckPhaseCounts(deck) {
  let newCount = 0;
  let learningCount = 0;
  let reviewCount = 0;

  deck.cards.forEach(card => {
    const key = scheduleKey(deck.id, card.id);
    const s = schedule[key];

    // New card: never scheduled
    if (!s) {
      newCount++;
      return;
    }

    const normalized = normalizeScheduleEntry(s);
    const level = typeof normalized.level === "number" ? normalized.level : 1;

    if (normalized.phase === "ladder" && level <= 5) {
      // Learning cards (still in the 5-step ladder)
      learningCount++;
    } else {
      // Anything past the ladder is treated as review
      reviewCount++;
    }
  });

  return { newCount, learningCount, reviewCount };
}

// ===== Rebuild entire deck UI (called on init and after remote load) =====
function rebuildDeckUI() {
  console.log("[REBUILD] rebuildDeckUI called", { decksLen: decks.length });
  refreshDeckSelect();
  refreshCardsList();
}

    function refreshDeckSelect() {
  const currentValue = selectedDeckId;
  deckSelect.innerHTML = "";

  decks.forEach(deck => {
    const opt = document.createElement("option");
    opt.value = deck.id;

    const counts = getDeckPhaseCounts(deck);
    opt.textContent = `${deck.name} (${counts.newCount}/${counts.learningCount}/${counts.reviewCount})`;
    deckSelect.appendChild(opt);
  });

  // ‚úÖ Preserve previously selected deck if possible
  if (!selectedDeckId && decks.length > 0) {
    selectedDeckId = decks[0].id;
  }

  if (currentValue && decks.some(d => d.id === currentValue)) {
    selectedDeckId = currentValue;
  }

  if (selectedDeckId && decks.some(d => d.id === selectedDeckId)) {
    deckSelect.value = selectedDeckId;
  } else if (decks.length > 0) {
    selectedDeckId = decks[0].id;
    deckSelect.value = selectedDeckId;
  } else {
    selectedDeckId = null;
  }

  refreshMoveDeckSelect();
}

// --- Web Speech API TTS for cards ---
// --- Daniel voice cache ---
window._danielVoice = null;
function cacheDanielVoice() {
  const voices = window.speechSynthesis.getVoices();
  for (let v of voices) {
    if (v.name && v.name.toLowerCase().includes('daniel')) {
      window._danielVoice = v;
      break;
    }
  }
}

function getCardLangs(deck, card) {
  const qLang = (card && card.qLang) || (deck && deck.qLang) || "en-US";
  const aLang = (card && card.aLang) || (deck && deck.aLang) || "en-US";
  return { qLang, aLang };
}

if (typeof window.speechSynthesis !== 'undefined') {
  window.speechSynthesis.onvoiceschanged = cacheDanielVoice;
  cacheDanielVoice();
}

window.speakCardText = function(questionRaw, answerRaw, deckId, cardObj) {
  const deck = deckId ? getDeckById(deckId) : null;
  const { qLang, aLang } = getCardLangs(deck, cardObj);

  const question = getPlainTextFromCard(questionRaw);
  const answer = getPlainTextFromCard(answerRaw);

  // Speak question, then answer after 3s pause, using your unified TTS with correct languages
  speakWithWebTts(question, () => {
    if (answer && answer.trim()) {
      setTimeout(() => {
        speakWithWebTts(answer, null, { lang: aLang });
      }, 3000); // 3 second pause
    }
  }, { lang: qLang });
};


    // Format the next due date for a given card
    function formatDueDate(deckId, cardId) {
      const key = scheduleKey(deckId, cardId);
      const entry = schedule[key];
      if (!entry) {
        // Never scheduled = brand new card
        return "New";
      }

      const normalized = normalizeScheduleEntry(entry);
      const dueMs = normalized.dueTime;
      if (typeof dueMs !== "number") return "New";

      const nowMs = Date.now();
      const due = new Date(dueMs);
      if (Number.isNaN(due.getTime())) return "New";

      const now = new Date();
      const todayStr = now.toDateString();
      const dueStr = due.toDateString();

      if (dueMs <= nowMs) {
        return "Due now";
      }

      // Today later
      if (dueStr === todayStr) {
        return "Today " + due.toLocaleTimeString([], {
          hour: "numeric",
          minute: "2-digit"
        });
      }

      // Otherwise just show date (local)
      return due.toLocaleDateString();
    }

        function refreshCardsList() {
      const deck = getDeckById(selectedDeckId);
      cardsListDiv.innerHTML = "";
      selectedCardId = null;
      selectedCardInfo.textContent = "";
      updateCardBtn.disabled = true;
      if (!deck) return;

      [...deck.cards].reverse().forEach(card => {
        const row = document.createElement("div");
        row.className = "cardRow";

        // Question column
        const questionSpan = document.createElement("span");
        questionSpan.textContent = getPlainTextFromCard(card.question);
        row.appendChild(questionSpan);

        // Due date column
        const dueSpan = document.createElement("span");
        dueSpan.className = "dueDateCell";
        dueSpan.textContent = formatDueDate(selectedDeckId, card.id);
        row.appendChild(dueSpan);

        // Actions column (Edit / Delete)

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "cardActions";

        // Play (TTS) button
        const playBtn = document.createElement("button");
        playBtn.textContent = "üîä";
        playBtn.title = "Play card (TTS)";
        playBtn.className = "secondary small";
       playBtn.addEventListener("click", () => {
  window.speakCardText(card.question, card.answer, selectedDeckId, card);
});
        actionsDiv.appendChild(playBtn);

        const editBtn = document.createElement("button");
        editBtn.textContent = "Edit";
        editBtn.className = "secondary small";
        editBtn.addEventListener("click", () => {
  selectedCardId = card.id;
  cardQuestionInput.value = card.question;
  cardAnswerInput.value = card.answer;

  refreshCardLanguageDropdownsForCurrentDeck(card);

  selectedCardInfo.textContent = `Editing card: ${card.id}`;
  updateCardBtn.disabled = false;
  refreshMoveDeckSelect();
});

        actionsDiv.appendChild(editBtn);

        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "Delete";
        deleteBtn.className = "secondary small";
        deleteBtn.addEventListener("click", () => {
          if (!confirm("Delete this card?")) return;
          const d = getDeckById(selectedDeckId);
          if (!d) return;
          const idx = d.cards.findIndex(c => c.id === card.id);
          if (idx !== -1) {
            d.cards.splice(idx, 1);
          }
          const key = scheduleKey(selectedDeckId, card.id);
          delete schedule[key];
          saveDecks();
          saveSchedule();
          if (selectedCardId === card.id) {
            selectedCardId = null;
            cardQuestionInput.value = "";
            cardAnswerInput.value = "";
            selectedCardInfo.textContent = "";
            updateCardBtn.disabled = true;
          }
          refreshCardsList();
          refreshDeckSelect();
        });
        actionsDiv.appendChild(deleteBtn);

        row.appendChild(actionsDiv);
        cardsListDiv.appendChild(row);
      });
    }

    addDeckBtn.addEventListener("click", () => {
  console.log("‚úÖ Add Deck clicked");

  const raw = newDeckNameInput.value;
  console.log("Deck name raw:", raw);

  if (!raw || !raw.trim()) {
    console.warn("‚ùå No deck name; aborting");
    return;
  }

  const name = raw.trim();
  const id = "deck_" + Date.now();

  console.log("Creating deck:", { id, name });

 decks.push({ id, name, qLang: "en-US", aLang: "en-US", cards: [] });

  console.log("Decks after push:", decks);

  saveDecks();

  console.log("‚úÖ saveDecks() called");

  newDeckNameInput.value = "";
  updateAddDeckButtonState();
  selectedDeckId = id;
  saveLastDeckId(selectedDeckId);
  refreshDeckSelect();
  refreshCardsList();
});

    deleteDeckBtn.addEventListener("click", () => {
      if (!selectedDeckId) return;
      const deck = getDeckById(selectedDeckId);
      if (!deck) return;
      if (!confirm(`Delete deck "${deck.name}" and all its cards?`)) return;

      decks = decks.filter(d => d.id !== selectedDeckId);
      saveDecks();

      const prefix = selectedDeckId + "_";
      Object.keys(schedule).forEach(key => {
        if (key.startsWith(prefix)) {
          delete schedule[key];
        }
      });
      saveSchedule();

      if (decks.length > 0) {
        selectedDeckId = decks[0].id;
      } else {
        selectedDeckId = null;
      }
      refreshDeckSelect();
      refreshCardsList();
    });

    deckSelect.addEventListener("change", () => {
  selectedDeckId = deckSelect.value;
  saveLastDeckId(selectedDeckId);
  refreshCardsList();
  refreshCardLanguageDropdownsForCurrentDeck(null);
});

    addCardBtn.addEventListener("click", () => {
      const q = cardQuestionInput.value.trim();
      const a = cardAnswerInput.value.trim();
      if (!q || !a) return;
      const deck = getDeckById(selectedDeckId);
      if (!deck) return;
      const id = "c_" + Date.now();
const qLang = cardQuestionLangSelect?.value || null;
const aLang = cardAnswerLangSelect?.value || null;

deck.cards.push({ id, question: q, answer: a, qLang, aLang });

      saveDecks();
      cardQuestionInput.value = "";
      cardAnswerInput.value = "";
      selectedCardId = null;
      selectedCardInfo.textContent = "";
      updateCardBtn.disabled = true;
      refreshCardsList();
      refreshDeckSelect();
    });

    updateCardBtn.addEventListener("click", () => {
      if (!selectedCardId) return;
      const q = cardQuestionInput.value.trim();
      const a = cardAnswerInput.value.trim();
      if (!q || !a) return;
      const deck = getDeckById(selectedDeckId);
      if (!deck) return;
      const card = deck.cards.find(c => c.id === selectedCardId);
      if (!card) return;
      card.question = q;
      card.qLang = cardQuestionLangSelect?.value || null;
card.aLang = cardAnswerLangSelect?.value || null;
      card.answer = a;
      saveDecks();
      refreshCardsList();
      cardQuestionInput.value = "";
      cardAnswerInput.value = "";
      selectedCardId = null;
      selectedCardInfo.textContent = "";
      updateCardBtn.disabled = true;
    });
    if (moveCardBtn) {
  moveCardBtn.addEventListener("click", () => {
    if (!selectedCardId) return;
    const fromDeckId = selectedDeckId;
    const toDeckId = moveDeckSelect ? moveDeckSelect.value : null;

    if (!fromDeckId || !toDeckId) return;
    if (fromDeckId === toDeckId) return;

    const fromDeck = getDeckById(fromDeckId);
    const toDeck = getDeckById(toDeckId);
    if (!fromDeck || !toDeck) return;

    const idx = fromDeck.cards.findIndex(c => c.id === selectedCardId);
    if (idx === -1) return;

    // Move the card object
    const [movedCard] = fromDeck.cards.splice(idx, 1);
    toDeck.cards.push(movedCard);

    // Move schedule entry (because key includes deckId)
    const oldKey = scheduleKey(fromDeckId, movedCard.id);
    const newKey = scheduleKey(toDeckId, movedCard.id);

    if (schedule[oldKey]) {
      schedule[newKey] = schedule[oldKey];
      delete schedule[oldKey];
      saveSchedule();
    }

    // Persist + reset editor selection
    saveDecks();

    selectedCardId = null;
    cardQuestionInput.value = "";
    cardAnswerInput.value = "";
    selectedCardInfo.textContent = "";
    updateCardBtn.disabled = true;

    refreshCardsList();
    refreshDeckSelect();     // also refreshes move dropdown + counts
  });
}

    // NEW: Anki import help button
    ankiImportHelpBtn.addEventListener("click", () => {
      alert(
        "How to export from Anki:\n\n" +
        "1. Open Anki on desktop and select settings next to the deck you would like to export.\n" +
        "2. Hit export.\n" +
        "3. Set export format to 'notes in plain text', include the deck you wish to export, and select 'include HTML and media references' as well as 'include tags'.\n" +
        "4. Hit Export... and then save to your computer.\n" +
        "5. Choose that file from your computer to import.\n\n" +
        "You're done!"
      );
    });

    // NEW: Anki import handler
    ankiImportInput.addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      if (!selectedDeckId) {
        alert("Please select a deck first, so I know where to import the cards.");
        ankiImportInput.value = "";
        return;
      }

      const deck = getDeckById(selectedDeckId);
      if (!deck) {
        alert("Selected deck not found.");
        ankiImportInput.value = "";
        return;
      }

      const reader = new FileReader();
      reader.onload = (ev) => {
        const text = ev.target.result || "";
        const lines = text.split(/\r?\n/).filter((l) => l.trim().length > 0);

        let imported = 0;
        const timestamp = Date.now();

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];

          // Try TAB first (typical Anki export), fall back to comma
          let parts = line.split("\t");
          if (parts.length < 2) {
            parts = line.split(",");
          }
          if (parts.length < 2) continue;

          const q = parts[0].trim();
          const a = parts[1].trim();
          if (!q || !a) continue;

          const id = "c_" + timestamp + "_" + imported;
          deck.cards.push({ id, question: q, answer: a, qLang: null, aLang: null });
          imported++;
        }

        if (imported > 0) {
          saveDecks();
          refreshCardsList();
          refreshDeckSelect();
          ankiImportStatus.textContent = `Imported ${imported} cards.`;
        } else {
          ankiImportStatus.textContent = "No valid cards found in file.";
        }

        // Reset file input so you can import the same file again if needed
        ankiImportInput.value = "";
      };

      reader.onerror = () => {
        alert("Error reading file.");
        ankiImportInput.value = "";
      };

      reader.readAsText(file);
    });

    // ===================== TTS & STT =====================
    const statusDiv = document.getElementById("status");

// Takes card text (which may contain HTML/LaTeX) and renders it into an element.
// Then asks MathJax to typeset any equations in that element.
function setCardContent(el, raw) {
  if (!el) return;
  el.innerHTML = raw || "";

  // Let MathJax typeset any LaTeX in this element
  if (window.MathJax && window.MathJax.typesetPromise) {
    MathJax.typesetPromise([el]).catch(err => {
      console.error("MathJax error:", err);
    });
  }
}

// Strip HTML tags so TTS doesn't try to read "<img ...>" etc
function getPlainTextFromCard(raw) {
  const tmp = document.createElement("div");
  tmp.innerHTML = raw || "";
  return tmp.textContent || tmp.innerText || "";
}
    function setStatus(text) {
      statusDiv.textContent = text;
    }

    let isSpeaking = false;
    // Every time we start or forcibly stop TTS, bump this.
// Old TTS callbacks check this and no-op if they're "stale".
let speakGeneration = 0;


    // ===== Browser Web SpeechRecognition fallback =====
    const SpeechRecognition =
      window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let speechSupported = !!SpeechRecognition;

    // NEW: track whether we *expect* recognition to keep listening
    let keepListening = false;

    if (speechSupported) {
      recognition = new SpeechRecognition();
      recognition.lang = "en-US";
      recognition.interimResults = false;
      recognition.continuous = false;
      recognition.maxAlternatives = 3; // tiny robustness boost, still using top result
    }

    // >>> NEW: explicit microphone permission helper (kept as-is, though not called now) <<<
    function requestMicrophoneAccess() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        console.warn("getUserMedia not supported in this browser.");
        return;
      }
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          // Immediately stop the stream; we just needed the permission prompt.
          stream.getTracks().forEach(track => track.stop());
          console.log("Microphone permission granted.");
        })
        .catch(err => {
          console.error("Microphone permission denied:", err);
          setStatus("Please allow microphone access in your browser to use hands-free mode.");
        });
    }
    // <<< END MIC HELPER <<<

    // NEW: TTS settings (rate & volume)
    let ttsRate = 1.0;
    let ttsVolume = 1.0;
    const TTS_SETTINGS_KEY = "srsTtsSettings";
    function clamp(n, min, max) {
  return Math.max(min, Math.min(max, n));
}

// Reads the full settings object (rate, volume, + new delay)
function getTtsSettingsObj() {
  const raw = localStorage.getItem(TTS_SETTINGS_KEY);
  let s = {};
  try { s = raw ? JSON.parse(raw) : {}; } catch { s = {}; }

  if (typeof s.rate !== "number") s.rate = 0.8;
  if (typeof s.volume !== "number") s.volume = 1.0;
  if (typeof s.answerDelayAfterSpeechSec !== "number") s.answerDelayAfterSpeechSec = 0;

  s.rate = clamp(s.rate, 0.5, 2.0);
  s.volume = clamp(s.volume, 0.0, 1.0);
  s.answerDelayAfterSpeechSec = clamp(Math.round(s.answerDelayAfterSpeechSec), 0, 30);

  return s;
}

function saveTtsSettingsObj(s) {
  const out = {
    rate: clamp(Number(s.rate ?? 1.0), 0.5, 2.0),
    volume: clamp(Number(s.volume ?? 1.0), 0.0, 1.0),
    answerDelayAfterSpeechSec: clamp(Math.round(Number(s.answerDelayAfterSpeechSec ?? 0)), 0, 30),
  };
  localStorage.setItem(TTS_SETTINGS_KEY, JSON.stringify(out));
}

    const toggleStudyOptionsBtn = document.getElementById("toggleStudyOptionsBtn");
    const studyOptionsPanel = document.getElementById("studyOptionsPanel");
    const toggleAudioSettingsBtn = document.getElementById("toggleAudioSettingsBtn");
    const audioSettingsPanel = document.getElementById("audioSettingsPanel");
    const ttsRateInput = document.getElementById("ttsRateInput");
    const ttsVolumeInput = document.getElementById("ttsVolumeInput");
    const answerDelayAfterSpeechSecInput = document.getElementById("answerDelayAfterSpeechSecInput");
    
if (answerDelayAfterSpeechSecInput) {
  answerDelayAfterSpeechSecInput.addEventListener("change", () => {
    const v = Math.max(
      0,
      Math.min(30, parseInt(answerDelayAfterSpeechSecInput.value, 10) || 0)
    );

    answerDelayAfterSpeechSecInput.value = String(v);

    const s = getTtsSettingsObj();
    s.answerDelayAfterSpeechSec = v;
    saveTtsSettingsObj(s);
  });
}
    // Load TTS settings from storage
    (function loadTtsSettings() {
  const s = getTtsSettingsObj();
  ttsRate = s.rate;
  ttsVolume = s.volume;

  if (ttsRateInput) ttsRateInput.value = String(ttsRate);
  if (ttsVolumeInput) ttsVolumeInput.value = String(ttsVolume);

  const delayInput = document.getElementById("answerDelayAfterSpeechSecInput");
  if (delayInput) delayInput.value = String(s.answerDelayAfterSpeechSec ?? 0);
})();


    function saveTtsSettings() {
  const current = getTtsSettingsObj();
  current.rate = ttsRate;
  current.volume = ttsVolume;

  // keep existing value unless you set it elsewhere
  saveTtsSettingsObj(current);
}

    if (toggleStudyOptionsBtn && studyOptionsPanel) {
      toggleStudyOptionsBtn.addEventListener("click", () => {
        const isHidden = studyOptionsPanel.classList.contains("hidden");
        if (isHidden) {
          studyOptionsPanel.classList.remove("hidden");
          toggleStudyOptionsBtn.textContent = "Hide";
        } else {
          studyOptionsPanel.classList.add("hidden");
          toggleStudyOptionsBtn.textContent = "Show";
        }
      });
    }

    if (toggleAudioSettingsBtn && audioSettingsPanel) {
      toggleAudioSettingsBtn.addEventListener("click", () => {
        const isHidden = audioSettingsPanel.classList.contains("hidden");
        if (isHidden) {
          audioSettingsPanel.classList.remove("hidden");
          toggleAudioSettingsBtn.textContent = "Hide";
        } else {
          audioSettingsPanel.classList.add("hidden");
          toggleAudioSettingsBtn.textContent = "Show";
        }
      });
    }

    if (ttsRateInput) {
      ttsRateInput.addEventListener("change", () => {
        let v = parseFloat(ttsRateInput.value);
        if (isNaN(v)) v = 1.0;
        v = Math.max(0.5, Math.min(2, v));
        ttsRate = v;
        ttsRateInput.value = String(v);
        saveTtsSettings();
      });
    }

    if (ttsVolumeInput) {
      ttsVolumeInput.addEventListener("change", () => {
        let v = parseFloat(ttsVolumeInput.value);
        if (isNaN(v)) v = 1.0;
        v = Math.max(0, Math.min(1, v));
        ttsVolume = v;
        ttsVolumeInput.value = String(v);
        saveTtsSettings();
      });
    }
    if (answerDelayAfterSpeechSecInput) {
  answerDelayAfterSpeechSecInput.addEventListener("change", () => {
    const v = Math.max(
      0,
      Math.min(30, parseInt(answerDelayAfterSpeechSecInput.value, 10) || 0)
    );

    answerDelayAfterSpeechSecInput.value = String(v);

    const s = getTtsSettingsObj();
    s.answerDelayAfterSpeechSec = v;
    saveTtsSettingsObj(s);
  });
}

    // Helper: stop all audio + listening
    async function stopAllAudio() {
  // Invalidate any in-flight TTS callbacks
  speakGeneration++;
  clearAnswerAfterSpeechDelay();

  // Stop browser TTS
  if (window.speechSynthesis) {
  try { window.speechSynthesis.cancel(); } catch (_) {}
  // ‚úÖ iOS Safari/WebView sometimes needs a second cancel on next tick
  setTimeout(() => {
    try { window.speechSynthesis.cancel(); } catch (_) {}
  }, 0);
}

  isSpeaking = false;

  // Stop browser speech recognition
  if (recognition) {
    try {
      keepListening = false;
      recognition.onresult = null;
      recognition.onerror = null;
      recognition.onend = null;
      recognition.stop();
    } catch (e) {}
  }
}

  // Wrapper: choose NativeTTS (iOS app) or browser TTS (web)
function speak(text, onEnd) {
  speakWithWebTts(text, onEnd);
}

function speakSafe(text, onEnd) {
  speakWithWebTts(text, onEnd);
}

// Pure browser TTS (this is basically your old speak() body)
function speakWithWebTts(text, onEnd, opts = {}) {
  const { lang = "en-US" } = opts;

  if (!window.speechSynthesis) {
    setStatus("Text-to-speech not supported in this browser.");
    if (onEnd) onEnd();
    return;
  }

  // Clear any queued / half-finished utterances
  try { window.speechSynthesis.cancel(); } catch (_) {}

  // New TTS generation
  speakGeneration++;
  const myGeneration = speakGeneration;

  function expandAcronyms(str) {
    return String(str || "").replace(/\b([A-Z]{2,})\b/g, (m) => m.split("").join(" "));
  }

  const processedText = expandAcronyms(text);

  // Split text into segments
  const segments = [];
  const regex = /([^.,]+)([.,]?)/g;
  let match;
  while ((match = regex.exec(processedText)) !== null) {
    const phrase = match[1].trim();
    const delim = match[2];
    if (phrase) {
      segments.push({
        text: phrase + (delim || ""),
        pause: delim === "." ? 500 : delim === "," ? 250 : 0,
      });
    }
  }

  function getPreferredVoice() {
    const voices = window.speechSynthesis.getVoices();
    const langPrefix = String(lang).split("-")[0];

    const matching = voices.filter(v => {
      if (!v || !v.lang) return false;
      const vPrefix = v.lang.split("-")[0];
      return v.lang === lang || vPrefix === langPrefix;
    });

    if (langPrefix === "en") {
      let preferred =
        matching.find(v => v.name === "Daniel") ||
        matching.find(v => v.name === "Daniel (Enhanced)") ||
        matching.find(v => !String(v.name || "").toLowerCase().includes("samantha")) ||
        matching[0] ||
        null;
      return preferred;
    }

    return matching[0] || voices[0] || null;
  }

  function startSpeaking() {
    const preferredVoice = getPreferredVoice();
    let idx = 0;

    function speakSegment() {
      // HARD STOP: if cancelled, stop immediately
      if (myGeneration !== speakGeneration) return;

      if (idx >= segments.length) {
        isSpeaking = false;
        setStatus("");
        if (onEnd) onEnd();
        return;
      }

      const seg = segments[idx++];

      // HARD STOP: check again right before speaking
      if (myGeneration !== speakGeneration) return;

      const utt = new SpeechSynthesisUtterance(seg.text);
      utt.lang = lang;
      if (preferredVoice) utt.voice = preferredVoice;

      utt.rate = typeof ttsRate === "number" ? ttsRate : 0.8;
      utt.pitch = 1.0;
      utt.volume = typeof ttsVolume === "number" ? ttsVolume : 1.0;

      utt.onstart = () => {
        if (myGeneration !== speakGeneration) return;
        isSpeaking = true;
        setStatus("Speaking...");
      };

      utt.onend = () => {
        if (myGeneration !== speakGeneration) return;
        setTimeout(() => {
          if (myGeneration !== speakGeneration) return;
          speakSegment();
        }, seg.pause);
      };

      utt.onerror = (err) => {
        if (myGeneration !== speakGeneration) return;
        console.error("TTS error:", err);
        setTimeout(() => {
          if (myGeneration !== speakGeneration) return;
          speakSegment();
        }, seg.pause);
      };

      if (myGeneration !== speakGeneration) return;
      window.speechSynthesis.speak(utt);
    }

    speakSegment();
  }

  // Ensure voices are loaded before speaking
  if (window.speechSynthesis.getVoices().length === 0) {
    window.speechSynthesis.onvoiceschanged = function handler() {
      window.speechSynthesis.onvoiceschanged = null;
      startSpeaking();
    };
  } else {
    startSpeaking();
  }
}



    function listenForCommand(callback) {
      if (isMicMuted) {
  // Don‚Äôt listen while muted
  return;
}

      // 2) Fallback: Browser Web SpeechRecognition
      if (!speechSupported || !recognition) {
        setStatus("Speech recognition not supported in this browser.");
        return;
      }
      setStatus("Listening...");
      keepListening = true;

      recognition.onresult = (event) => {
  keepListening = false;

  const res = event.results && event.results[0];
  if (!res) return callback("");

  // Collect all alternatives (you set recognition.maxAlternatives = 3)
  const alts = [];
  for (let i = 0; i < res.length; i++) {
    if (res[i] && res[i].transcript) alts.push(res[i].transcript);
  }
  if (alts.length === 0) return callback("");

  // Pick the first alternative that parses into a rating command
  for (const alt of alts) {
    if (parseRatingFromText(alt)) {
      callback(alt);
      return;
    }
  }

  // Otherwise fall back to the top alternative for global commands, etc.
  callback(alts[0]);
};
      recognition.onerror = (event) => {
        console.error("STT error:", event.error);
        keepListening = false;
        if (event.error !== "not-allowed") {
          setTimeout(() => listenForCommand(callback), 800);
        } else {
          setStatus("Microphone access blocked.");
        }
      };
      recognition.onend = () => {
  if (keepListening && currentMode === "voice" && !isMicMuted) {
    try {
      recognition.start();
    } catch (e) {
      console.error("Error restarting recognition:", e);
    }
  }
};
      try {
        recognition.start();
      } catch (e) {
        console.error("Error starting recognition:", e);
      }
    }

    // ===================== STUDY LOGIC (DUE / AHEAD) =====================
    function splitOverdueAndDue(deckId, cards) {
  const now = Date.now();
  const overdue = [];
  const due = [];

  cards.forEach(card => {
    const key = scheduleKey(deckId, card.id);
    const s = schedule[key];

    // New cards = due today (not overdue)
    if (!s) {
      due.push(card);
      return;
    }

    const { dueTime } = normalizeScheduleEntry(s);
    if (dueTime <= now) {
      // Overdue if it was due before *today*
      if (now - dueTime > 60 * 1000) {
        overdue.push(card);
      } else {
        due.push(card);
      }
    }
  });

  return { overdue, due };
}

    function getDueCardsForDeck(deckId, allowAhead, includeOverdue) {
      const deck = getDeckById(deckId);
      if (!deck) return [];
      const now = Date.now();

      const filtered = deck.cards.filter(card => {
        const key = scheduleKey(deckId, card.id);
        const s = schedule[key];

        // New cards: treat as due now
        if (!s) {
          if (!allowAhead) return true;
          if (includeOverdue) return true;
          return true;
        }

        const normalized = normalizeScheduleEntry(s);
        const due = normalized.dueTime || now;
        const isDueOrOverdue = due <= now;
        const isFuture = due > now;

        if (!allowAhead) {
          return isDueOrOverdue;
        }

        if (isFuture) return true;
        if (includeOverdue && isDueOrOverdue) return true;
        return false;
      });

      // Still sort by dueTime so earlier due cards are "earlier" in the day,
      // but we will add randomness at selection time.
      return filtered.sort((a, b) => {
        const ka = scheduleKey(deckId, a.id);
        const kb = scheduleKey(deckId, b.id);
        const sa = schedule[ka];
        const sb = schedule[kb];
        const na = sa ? normalizeScheduleEntry(sa).dueTime : 0;
        const nb = sb ? normalizeScheduleEntry(sb).dueTime : 0;
        return na - nb;
      });
    }

    function getNextCardForDeck(deckId, allowAhead, includeOverdue) {
      const dueCards = getDueCardsForDeck(deckId, allowAhead, includeOverdue);
      if (dueCards.length === 0) return null;
      return dueCards[0];
    }
    // ===================== STUDY PREFS (persist across sessions) =====================
const STUDY_PREFS_KEY = "zc_studyPrefs";

function getStudyPrefs() {
  let p = {};
  try { p = JSON.parse(localStorage.getItem(STUDY_PREFS_KEY) || "{}"); } catch { p = {}; }

  // Defaults (match your current defaults)
  if (typeof p.skipInstructionsAfterFirst !== "boolean") p.skipInstructionsAfterFirst = true;
  if (typeof p.answerMode !== "string") p.answerMode = "delay"; // "delay" | "voice"
  if (typeof p.answerDelaySec !== "number") p.answerDelaySec = 4;
  if (typeof p.autoGoodMode !== "boolean") p.autoGoodMode = false;
  if (typeof p.autoModeBehavior !== "string") p.autoModeBehavior = "good"; // again|hard|good|easy|tomorrow
  if (typeof p.handsFreeNextDelaySec !== "number") p.handsFreeNextDelaySec = 2;
  if (typeof p.studyAheadGapSec !== "number") p.studyAheadGapSec = 4;
  if (typeof p.autoEnterStudyAhead !== "boolean") p.autoEnterStudyAhead = false;
  if (typeof p.loopStudyAhead !== "boolean") p.loopStudyAhead = false;

  // Clamp numeric values
  p.answerDelaySec = Math.max(1, Math.min(60, Math.floor(p.answerDelaySec)));
  p.handsFreeNextDelaySec = Math.max(0, Math.min(30, Math.floor(p.handsFreeNextDelaySec)));
  p.studyAheadGapSec = Math.max(1, Math.min(60, Math.floor(p.studyAheadGapSec)));

  return p;
}

function saveStudyPrefs(patch = {}) {
  const cur = getStudyPrefs();
  const next = { ...cur, ...patch };
  localStorage.setItem(STUDY_PREFS_KEY, JSON.stringify(next));
  return next;
}


    // ===================== STUDY SESSION STATE =====================
    const mainMenuDiv = document.getElementById("mainMenu");
    const studySectionDiv = document.getElementById("studySection");
    const modeBadge = document.getElementById("modeBadge");
    const backToMenuBtn = document.getElementById("backToMenuBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const resumeBtn = document.getElementById("resumeBtn");
    const studyInstructionsBtn = document.getElementById("studyInstructionsBtn");

    const skipInstructionsAfterFirstCheckbox = document.getElementById("skipInstructionsAfterFirst");
    const autoGoodToggle = document.getElementById("autoGoodToggle");
    const autoRatingSelect = document.getElementById("autoRatingSelect");
    const answerModeDelayRadio = document.getElementById("answerModeDelay");
    const answerModeVoiceRadio = document.getElementById("answerModeVoice");
    const answerDelaySecondsInput = document.getElementById("answerDelaySeconds");
      const handsFreeNextDelaySecondsInput = document.getElementById("handsFreeNextDelaySeconds");
    const studyAheadGapSecondsInput = document.getElementById("studyAheadGapSeconds");
const autoEnterStudyAheadCheckbox = document.getElementById("autoEnterStudyAhead");
const loopStudyAheadCheckbox = document.getElementById("loopStudyAhead");
    const startVoiceBtn = document.getElementById("startVoiceBtn");

    const startSilentBtn = document.getElementById("startSilentBtn");


    const silentUI = document.getElementById("silentUI");
    const silentQuestion = document.getElementById("silentQuestion");
    const silentQuestionText = document.getElementById("silentQuestionText");
    const silentAnswer = document.getElementById("silentAnswer");
    const silentAnswerText = document.getElementById("silentAnswerText");
    const showAnswerBtn = document.getElementById("showAnswerBtn");
    const silentRatingButtons = document.getElementById("silentRatingButtons");

    const hintAgain = document.getElementById("hint-again");
    const hintHard = document.getElementById("hint-hard");
    const hintGood = document.getElementById("hint-good");
    const hintEasy = document.getElementById("hint-easy");

    const voiceUI = document.getElementById("voiceUI");
    const voiceQuestion = document.getElementById("voiceQuestion");
    const voiceQuestionText = document.getElementById("voiceQuestionText");
    const voiceAnswer = document.getElementById("voiceAnswer");
    const voiceAnswerText = document.getElementById("voiceAnswerText");
        const voiceRatingButtons = document.getElementById("voiceRatingButtons");
        function setVoiceRatingButtonsEnabled(enabled) {
  if (!voiceRatingButtons) return;
  voiceRatingButtons
    .querySelectorAll('button[data-voice-rating]')
    .forEach(b => (b.disabled = !enabled));
}

    const silentNextCardBtn = document.getElementById("silentNextCardBtn");

    const silentEditToggleBtn = document.getElementById("silentEditToggleBtn");
    const silentEditPanel = document.getElementById("silentEditPanel");
    const silentEditQuestion = document.getElementById("silentEditQuestion");
    const silentEditAnswer = document.getElementById("silentEditAnswer");
    const silentSaveEditBtn = document.getElementById("silentSaveEditBtn");
    const silentCancelEditBtn = document.getElementById("silentCancelEditBtn");

    const voiceEditToggleBtn = document.getElementById("voiceEditToggleBtn");
    const voiceEditPanel = document.getElementById("voiceEditPanel");
    const voiceEditQuestion = document.getElementById("voiceEditQuestion");
    const voiceEditAnswer = document.getElementById("voiceEditAnswer");
    const voiceSaveEditBtn = document.getElementById("voiceSaveEditBtn");
    const voiceCancelEditBtn = document.getElementById("voiceCancelEditBtn");

    const silentCompletionControls = document.getElementById("silentCompletionControls");
    const silentMainMenuBtn = document.getElementById("silentMainMenuBtn");
    const silentStudyAheadBtn = document.getElementById("silentStudyAheadBtn");

    let currentMode = null;
    let currentDeckId = null;
    let currentCard = null;

    function applyStudyPrefsToUIAndState() {
  const p = getStudyPrefs();

  // UI controls
  if (skipInstructionsAfterFirstCheckbox) skipInstructionsAfterFirstCheckbox.checked = !!p.skipInstructionsAfterFirst;

  if (answerModeVoiceRadio && answerModeDelayRadio) {
    answerModeVoiceRadio.checked = (p.answerMode === "voice");
    answerModeDelayRadio.checked = (p.answerMode !== "voice");
  }

  if (answerDelaySecondsInput) answerDelaySecondsInput.value = String(p.answerDelaySec);

  if (autoGoodToggle) autoGoodToggle.checked = !!p.autoGoodMode;

  if (autoRatingSelect) autoRatingSelect.value = p.autoModeBehavior || "good";

  if (handsFreeNextDelaySecondsInput) handsFreeNextDelaySecondsInput.value = String(p.handsFreeNextDelaySec);

  if (studyAheadGapSecondsInput) studyAheadGapSecondsInput.value = String(p.studyAheadGapSec);

  if (autoEnterStudyAheadCheckbox) autoEnterStudyAheadCheckbox.checked = !!p.autoEnterStudyAhead;
  if (loopStudyAheadCheckbox) loopStudyAheadCheckbox.checked = !!p.loopStudyAhead;

  // Make auto rating select enabled/disabled correctly
  if (autoRatingSelect && autoGoodToggle) {
    autoRatingSelect.disabled = !autoGoodToggle.checked;
  }

  // Hands-free next delay disabled when autoGoodMode is enabled (your existing behavior)
  if (handsFreeNextDelaySecondsInput && autoGoodToggle) {
    handsFreeNextDelaySecondsInput.disabled = autoGoodToggle.checked;
  }

  // State variables (these are what your runtime uses)
  skipInstructionsAfterFirst = !!p.skipInstructionsAfterFirst;
  answerMode = p.answerMode === "voice" ? "voice" : "delay";
  answerDelayMs = p.answerDelaySec * 1000;

  autoGoodMode = !!p.autoGoodMode;
  autoModeBehavior = p.autoModeBehavior || "good";

  handsFreeNextDelayMs = p.handsFreeNextDelaySec * 1000;
  studyAheadGapMs = p.studyAheadGapSec * 1000;

  autoEnterStudyAhead = !!p.autoEnterStudyAhead;
  loopStudyAhead = !!p.loopStudyAhead;
}
function wireStudyPrefsListeners() {
  if (skipInstructionsAfterFirstCheckbox) {
    skipInstructionsAfterFirstCheckbox.addEventListener("change", () => {
      const next = saveStudyPrefs({ skipInstructionsAfterFirst: !!skipInstructionsAfterFirstCheckbox.checked });
      applyStudyPrefsToUIAndState();
    });
  }

  if (answerModeVoiceRadio) {
    answerModeVoiceRadio.addEventListener("change", () => {
      if (answerModeVoiceRadio.checked) {
        saveStudyPrefs({ answerMode: "voice" });
        applyStudyPrefsToUIAndState();
      }
    });
  }

  if (answerModeDelayRadio) {
    answerModeDelayRadio.addEventListener("change", () => {
      if (answerModeDelayRadio.checked) {
        saveStudyPrefs({ answerMode: "delay" });
        applyStudyPrefsToUIAndState();
      }
    });
  }

  if (answerDelaySecondsInput) {
    answerDelaySecondsInput.addEventListener("change", () => {
      const sec = Math.max(1, Math.min(60, parseInt(answerDelaySecondsInput.value, 10) || 4));
      answerDelaySecondsInput.value = String(sec);
      saveStudyPrefs({ answerDelaySec: sec });
      applyStudyPrefsToUIAndState();
    });
  }

  if (autoGoodToggle) {
    autoGoodToggle.addEventListener("change", () => {
      saveStudyPrefs({ autoGoodMode: !!autoGoodToggle.checked });
      applyStudyPrefsToUIAndState();
    });
  }

  if (autoRatingSelect) {
    autoRatingSelect.addEventListener("change", () => {
      saveStudyPrefs({ autoModeBehavior: autoRatingSelect.value || "good" });
      applyStudyPrefsToUIAndState();
    });
  }

  if (handsFreeNextDelaySecondsInput) {
    handsFreeNextDelaySecondsInput.addEventListener("change", () => {
      const sec = Math.max(0, Math.min(30, parseInt(handsFreeNextDelaySecondsInput.value, 10) || 0));
      handsFreeNextDelaySecondsInput.value = String(sec);
      saveStudyPrefs({ handsFreeNextDelaySec: sec });
      applyStudyPrefsToUIAndState();
    });
  }

  if (studyAheadGapSecondsInput) {
    studyAheadGapSecondsInput.addEventListener("change", () => {
      const sec = Math.max(1, Math.min(60, parseInt(studyAheadGapSecondsInput.value, 10) || 4));
      studyAheadGapSecondsInput.value = String(sec);
      saveStudyPrefs({ studyAheadGapSec: sec });
      applyStudyPrefsToUIAndState();
    });
  }

  if (autoEnterStudyAheadCheckbox) {
    autoEnterStudyAheadCheckbox.addEventListener("change", () => {
      saveStudyPrefs({ autoEnterStudyAhead: !!autoEnterStudyAheadCheckbox.checked });
      applyStudyPrefsToUIAndState();
    });
  }

  if (loopStudyAheadCheckbox) {
    loopStudyAheadCheckbox.addEventListener("change", () => {
      saveStudyPrefs({ loopStudyAhead: !!loopStudyAheadCheckbox.checked });
      applyStudyPrefsToUIAndState();
    });
  }
}



    // ***** STATE MACHINE FOR CARD FLOW *****
    const StudyState = {
      IDLE: "idle",
      SHOWING_QUESTION: "showing_question",
      WAITING_FOR_ANSWER: "waiting_for_answer",
      SHOWING_ANSWER: "showing_answer",
      WAITING_FOR_RATING: "waiting_for_rating"
    };

    let studyState = StudyState.IDLE;

    function setStudyState(newState) {
      studyState = newState;
      // You can comment this out later if you don't want console noise:
      console.log("Study state:", newState);
    }
    // ***** END STATE MACHINE DEFINITIONS *****

    let studyAheadSession = false;
    let noScheduleChanges = false;
    let studyAheadPromptedOnceVoice = false;
    let autoEnterStudyAhead = false;  // from Study Options
let loopStudyAhead = false;       // from Study Options
    let skipInstructionsAfterFirst = true;
    let hasSpokenInstructionsOnce = false;
    let answerMode = "delay";
    let answerDelayMs = 4000;
    let autoGoodMode = false;
    let handsFreeNextDelayMs = 2000;
    // Disable handsFreeNextDelaySecondsInput when autoGood is enabled
    if (handsFreeNextDelaySecondsInput && autoGoodToggle) {
      function updateHandsFreeDelayEnabled() {
        handsFreeNextDelaySecondsInput.disabled = autoGoodToggle.checked;
      }
      autoGoodToggle.addEventListener('change', updateHandsFreeDelayEnabled);
      updateHandsFreeDelayEnabled();
      handsFreeNextDelaySecondsInput.addEventListener('input', () => {
        handsFreeNextDelayMs = Math.max(0, Math.min(30, Number(handsFreeNextDelaySecondsInput.value))) * 1000;
      });
      // Initialize value
      handsFreeNextDelayMs = Math.max(0, Math.min(30, Number(handsFreeNextDelaySecondsInput.value))) * 1000;
    }
    let autoModeBehavior = "good"; // again | hard | good | easy | tomorrow

    let studyAheadGapMs = 4000;
    let inStudyAheadAnswerGap = false;
    let answerAfterSpeechTimerId = null;
let answerAfterSpeechDueMs = 0;
let inAnswerAfterSpeechDelay = false;

function clearAnswerAfterSpeechDelay() {
  if (answerAfterSpeechTimerId !== null) {
    clearTimeout(answerAfterSpeechTimerId);
    answerAfterSpeechTimerId = null;
  }
  inAnswerAfterSpeechDelay = false;
  answerAfterSpeechDueMs = 0;
}
function startOrResetAnswerAfterSpeechDelay() {
  const s = getTtsSettingsObj();
  const sec = clamp(Number(s.answerDelayAfterSpeechSec || 0), 0, 30);

  if (sec === 0) {
    clearAnswerAfterSpeechDelay();
    speakAnswerThenAskDifficulty();
    return;
  }

  clearAnswerAfterSpeechDelay();
  inAnswerAfterSpeechDelay = true;
  answerAfterSpeechDueMs = Date.now() + sec * 1000;

  // ‚úÖ keep the mic open during this window so any speech resets the timer
  if (currentMode === "voice" && !isPaused) {
    listenForCommand(handleVoiceTranscript);
  }

  answerAfterSpeechTimerId = setTimeout(() => {
    inAnswerAfterSpeechDelay = false;
    answerAfterSpeechTimerId = null;
    speakAnswerThenAskDifficulty();
  }, sec * 1000);
}

    let studyAheadGapTimerId = null;

    let isPaused = false;
    let restartCardOnResumeVoice = false; // NEW: when resuming voice mode, replay current card
    let awaitingDifficulty = false;
    let awaitingAnswerSignal = false;
    let awaitingPostCompletionChoice = false;

    let reviewQueue = [];
    let aheadQueue = [];
    let aheadQueueIndex = 0;
// ===== Mic mute feature (voice-answer gap only) =====
let isMicMuted = false;
let micMutedUntilMs = 0;
let micMuteIntervalId = null;
let awaitingMuteSeconds = false;

// DOM refs (safe here because index.html already loaded)
const micMuteTimerEl = document.getElementById("micMuteTimer");
const micMuteSecondsEl = document.getElementById("micMuteSeconds");


    // NEW: track if question/answer have been spoken for current card
    let hasSpokenCurrentQuestion = false;
    let hasSpokenCurrentAnswer = false;

    // NEW: track delay window between question and answer in delay mode
    let questionDelayTimerId = null;

    function clearStudyAheadGapTimer() {
      if (studyAheadGapTimerId !== null) {
        clearTimeout(studyAheadGapTimerId);
        studyAheadGapTimerId = null;
      }
      inStudyAheadAnswerGap = false;
    }

    function clearQuestionDelayTimer() {
      if (questionDelayTimerId !== null) {
        clearTimeout(questionDelayTimerId);
        questionDelayTimerId = null;
      }
    }
    function clearMicMuteTimer() {
  if (micMuteIntervalId !== null) {
    clearInterval(micMuteIntervalId);
    micMuteIntervalId = null;
  }
  isMicMuted = false;
  micMutedUntilMs = 0;
  awaitingMuteSeconds = false;
  if (micMuteTimerEl) micMuteTimerEl.classList.add("hidden");
}

function updateMicMuteCountdownUI() {
  if (!micMuteTimerEl || !micMuteSecondsEl) return;
  const remainingMs = Math.max(0, micMutedUntilMs - Date.now());
  const remainingSec = Math.ceil(remainingMs / 1000);
  micMuteSecondsEl.textContent = String(remainingSec);
}

function startMicMute(seconds) {
  const sec = Math.max(0, Math.min(60, Number(seconds || 0)));
  isMicMuted = true;
  setStatus("Mic temporarily muted...");
  micMutedUntilMs = Date.now() + sec * 1000;

  // Stop any live listening immediately
  keepListening = false;
  if (recognition) {
    try { recognition.stop(); } catch (_) {}
  }

  if (micMuteTimerEl) micMuteTimerEl.classList.remove("hidden");
  updateMicMuteCountdownUI();

  if (micMuteIntervalId !== null) clearInterval(micMuteIntervalId);
  micMuteIntervalId = setInterval(() => {
    const remaining = micMutedUntilMs - Date.now();
    if (remaining <= 0) {
      clearInterval(micMuteIntervalId);
      micMuteIntervalId = null;
      isMicMuted = false;
      if (micMuteTimerEl) micMuteTimerEl.classList.add("hidden");

      // If we are STILL in the answer gap, resume listening for the ‚Äúanswer to show answer‚Äù
      if (!isPaused && currentMode === "voice" && awaitingAnswerSignal) {
        setStatus("Listening for your answer...");
        listenForCommand(handleVoiceTranscript);
      }
      return;
    }
    updateMicMuteCountdownUI();
  }, 250);
}

    function queueCardForAgain(deckId, cardObj) {
      if (!cardObj) return;
      const key = scheduleKey(deckId, cardObj.id);
      const exists = reviewQueue.some((c) => scheduleKey(deckId, c.id) === key);
      if (!exists) {
        reviewQueue.push(cardObj);
      }
    }

    async function showMainMenu() {
    await stopAllAudio();
      clearStudyAheadGapTimer();
      clearQuestionDelayTimer();

      // Do NOT clear currentCard here, so it is preserved for resuming study
      currentMode = null;
      mainMenuDiv.classList.remove("hidden");
      studySectionDiv.classList.add("hidden");
      setStatus("");
      isPaused = false;
      awaitingDifficulty = false;
      awaitingAnswerSignal = false;
      awaitingPostCompletionChoice = false;
      resumeBtn.disabled = true;
      pauseBtn.disabled = false;
      pauseBtn.classList.remove("hidden");
      resumeBtn.classList.remove("hidden");
      silentNextCardBtn.classList.add("hidden");
      studyAheadSession = false;
      noScheduleChanges = false;
      studyAheadPromptedOnceVoice = false;
      reviewQueue = [];
      aheadQueue = [];
      aheadQueueIndex = 0;
      hasSpokenCurrentQuestion = false;
      hasSpokenCurrentAnswer = false;
      silentCompletionControls.classList.add("hidden");
      if (voiceQuestionText) voiceQuestionText.textContent = "";
      if (voiceAnswerText) voiceAnswerText.textContent = "";
      if (voiceAnswer) voiceAnswer.classList.add("hidden");
      silentEditPanel.classList.add("hidden");
      voiceEditPanel.classList.add("hidden");
            if (voiceRatingButtons) voiceRatingButtons.classList.add("hidden");
      setStudyState(StudyState.IDLE);
    }
function updateDeckBadge() {
  if (!deckBadge) return;
  const deck = getDeckById(currentDeckId);
  deckBadge.textContent = deck ? `Deck: ${deck.name}` : "";
}

async function openAddCardModal() {
  // Stop audio/listening so the modal is calm in hands-free mode
  await stopAllAudio();
  clearStudyAheadGapTimer();
  clearQuestionDelayTimer();
  refreshCardLanguageDropdownsForCurrentDeck(null);


  if (addCardModalStatus) addCardModalStatus.textContent = "";
  if (addCardModalQuestion) addCardModalQuestion.value = "";
  if (addCardModalAnswer) addCardModalAnswer.value = "";

  addCardModal.classList.remove("hidden");
  addCardModal.setAttribute("aria-hidden", "false");
  if (addCardModalQuestion) addCardModalQuestion.focus();
}

function closeAddCardModal() {
  addCardModal.classList.add("hidden");
  addCardModal.setAttribute("aria-hidden", "true");

  // If you were in voice mode, resume your normal loop
  if (currentMode === "voice" && !isPaused) runVoiceLoop();
  if (currentMode === "silent" && !isPaused) runSilentLoop();
}
async function openInstructionsModal() {
  // pause audio/listening so the modal isn‚Äôt chaotic in hands-free mode
 await stopAllAudio();
  clearStudyAheadGapTimer();
  clearQuestionDelayTimer();
  clearAnswerAfterSpeechDelay();

  if (!instructionsModal) return;
  instructionsModal.classList.remove("hidden");
  instructionsModal.setAttribute("aria-hidden", "false");
}

function closeInstructionsModal() {
  if (!instructionsModal) return;
  instructionsModal.classList.add("hidden");
  instructionsModal.setAttribute("aria-hidden", "true");

  // If you were studying, resume the correct loop
  if (currentMode === "voice" && !isPaused) runVoiceLoop();
  if (currentMode === "silent" && !isPaused) runSilentLoop();
}

if (openInstructionsBtn) {
  openInstructionsBtn.addEventListener("click", openInstructionsModal);
}

if (instructionsCloseBtn) {
  instructionsCloseBtn.addEventListener("click", closeInstructionsModal);
}

// click backdrop to close
if (instructionsModal) {
  instructionsModal.addEventListener("click", (e) => {
    if (e.target && e.target.classList && e.target.classList.contains("modalBackdrop")) {
      closeInstructionsModal();
    }
  });
}

// ESC to close
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && instructionsModal && !instructionsModal.classList.contains("hidden")) {
    closeInstructionsModal();
  }
});


    function showStudySection(mode) {
      currentMode = mode;
      mainMenuDiv.classList.add("hidden");
      studySectionDiv.classList.remove("hidden");
      modeBadge.textContent = mode === "voice" ? "Hands-Free Mode" : "Silent Mode";
      isPaused = false;
      resumeBtn.disabled = true;
      pauseBtn.disabled = false;
      pauseBtn.classList.remove("hidden");
      resumeBtn.classList.remove("hidden");
      updateDeckBadge();
    }

    backToMenuBtn.addEventListener("click", async () => {
  await showMainMenu();
});

    pauseBtn.addEventListener("click", async () => {
  isPaused = true;

  // NEW: make Resume replay the SAME card in hands-free mode
  if (currentMode === "voice" && currentCard) {
    restartCardOnResumeVoice = true;
  }
await stopAllAudio(); 
  clearStudyAheadGapTimer();
  clearQuestionDelayTimer();

  pauseBtn.disabled = true;
  resumeBtn.disabled = false;
  setStatus("Paused. Say 'resume study session' or tap Resume.");

  // keep listening while paused when paused via button
  if (currentMode === "voice" && speechSupported && recognition) {
    listenForCommand(handleVoiceTranscript);
  }
});

    resumeBtn.addEventListener("click", () => {
  if (!currentMode) return;

  isPaused = false;
  pauseBtn.disabled = false;
  resumeBtn.disabled = true;

  if (currentMode === "voice") {
    // NEW: replay the paused card instead of advancing
    if (restartCardOnResumeVoice && currentCard) {
      restartCardOnResumeVoice = false;
      restartCurrentCardVoiceFlow();
      return;
    }
    runVoiceLoop();
  } else {
    runSilentLoop();
  }
});

if (studyAddCardBtn) {
  studyAddCardBtn.addEventListener("click", () => {
    if (!currentDeckId) return;
    openAddCardModal();
  });
}

if (addCardModalCloseBtn) addCardModalCloseBtn.addEventListener("click", closeAddCardModal);
if (addCardModalCancelBtn) addCardModalCancelBtn.addEventListener("click", closeAddCardModal);

// Close when clicking backdrop
if (addCardModal) {
  addCardModal.addEventListener("click", (e) => {
    if (e.target && e.target.classList && e.target.classList.contains("modalBackdrop")) {
      closeAddCardModal();
    }
  });
}

// Save card into CURRENT deck
if (addCardModalSaveBtn) {
  addCardModalSaveBtn.addEventListener("click", () => {
    const q = (addCardModalQuestion?.value || "").trim();
    const a = (addCardModalAnswer?.value || "").trim();

    if (!q || !a) {
      if (addCardModalStatus) addCardModalStatus.textContent = "Please enter both a question and an answer.";
      return;
    }

    const deck = getDeckById(currentDeckId);
    if (!deck) {
      if (addCardModalStatus) addCardModalStatus.textContent = "Deck not found.";
      return;
    }

    const id = "c_" + Date.now();
const qLang = cardQuestionLangSelect?.value || null;
const aLang = cardAnswerLangSelect?.value || null;

deck.cards.push({ id, question: q, answer: a, qLang, aLang });


    saveDecks();
    refreshDeckSelect();
    refreshCardsList();

    if (addCardModalStatus) addCardModalStatus.textContent = "Saved!";
    closeAddCardModal();
  });
}

// ESC to close
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && addCardModal && !addCardModal.classList.contains("hidden")) {
    closeAddCardModal();
  }
});
    
    function endStudySession() {
  clearStudyAheadGapTimer();
  clearQuestionDelayTimer();
  clearAnswerAfterSpeechDelay();
  if (voiceRatingButtons) {
    voiceRatingButtons.classList.add("hidden");
  }
  showMainMenu();
  setStatus("Study session ended.");
}

    // ===================== INLINE EDIT HELPERS =====================
    function updateCardTextInDeck(deckId, cardId, newQ, newA, newQLang = null, newALang = null) {
  const deck = getDeckById(deckId);
  if (!deck) return null;
  const card = deck.cards.find(c => c.id === cardId);
  if (!card) return null;

  card.question = newQ;
  card.answer = newA;

  // Save per-card language overrides (null means ‚Äúuse deck default‚Äù)
  card.qLang = newQLang;
  card.aLang = newALang;

  saveDecks();
  refreshDeckSelect();
  return card;
}

    // Silent mode inline edit
    silentEditToggleBtn.addEventListener("click", () => {
  if (!currentCard) return;
  silentEditQuestion.value = currentCard.question;
  silentEditAnswer.value = currentCard.answer;

  refreshCardLanguageDropdownsForCurrentDeck(currentCard);

  silentEditPanel.classList.remove("hidden");
});

    silentCancelEditBtn.addEventListener("click", () => {
      silentEditPanel.classList.add("hidden");
    });

    silentSaveEditBtn.addEventListener("click", () => {
      if (!currentCard) return;
      const q = silentEditQuestion.value.trim();
      const a = silentEditAnswer.value.trim();
      if (!q || !a) return;
const qLang = silentEditQuestionLangSelect?.value || null;
const aLang = silentEditAnswerLangSelect?.value || null;
const updated = updateCardTextInDeck(currentDeckId, currentCard.id, q, a, qLang, aLang);

      if (!updated) return;
      currentCard = updated;
      setCardContent(silentQuestionText, currentCard.question);
setCardContent(silentAnswerText, currentCard.answer);
      setCardContent(voiceQuestionText, currentCard.question);
setCardContent(voiceAnswerText, currentCard.answer);

      // refresh main card list so changes are visible there too
      refreshCardsList();

      silentEditPanel.classList.add("hidden");
      setStatus("Card updated.");
    });

    // Voice mode inline edit
    voiceEditToggleBtn.addEventListener("click", () => {
      if (!currentCard) return;
      voiceEditQuestion.value = currentCard.question;
      voiceEditAnswer.value = currentCard.answer;
      voiceEditPanel.classList.remove("hidden");
    });

    voiceCancelEditBtn.addEventListener("click", () => {
      voiceEditPanel.classList.add("hidden");
    });

    voiceSaveEditBtn.addEventListener("click", () => {
      if (!currentCard) return;
      const q = voiceEditQuestion.value.trim();
      const a = voiceEditAnswer.value.trim();
      if (!q || !a) return;
const qLang = voiceEditQuestionLangSelect?.value || null;
const aLang = voiceEditAnswerLangSelect?.value || null;
const updated = updateCardTextInDeck(currentDeckId, currentCard.id, q, a, qLang, aLang);

      if (!updated) return;
      currentCard = updated;
      setCardContent(voiceQuestionText, currentCard.question);
setCardContent(voiceAnswerText, currentCard.answer);

      setCardContent(silentQuestionText, currentCard.question);
setCardContent(silentAnswerText, currentCard.answer);

      // refresh main card list so changes are visible there too
      refreshCardsList();

      voiceEditPanel.classList.add("hidden");
      setStatus("Card updated.");
    });

    // ===================== VOICE MODE =====================

   // NEW: stop any current audio, then confirm + go to main menu
async function speakAndGoToMainMenu() {
  await stopAllAudio();
 speakSafe("Going to the main menu.", () => { endStudySession(); });
}


    // NEW helper: fully restart current card flow in hands-free mode
    function restartCurrentCardVoiceFlow() {
      if (!currentCard) return;

      // Reset timers and state for this card
      clearStudyAheadGapTimer();
      clearQuestionDelayTimer();
      clearAnswerAfterSpeechDelay();
      awaitingDifficulty = false;
      awaitingAnswerSignal = false;
      awaitingPostCompletionChoice = false;
      inStudyAheadAnswerGap = false;

      // Hide answer again and reset flags
      if (voiceAnswer) {
        voiceAnswer.classList.add("hidden");
      }
      hasSpokenCurrentAnswer = false;
      hasSpokenCurrentQuestion = false;

      setStatus("Repeating card...");
      setStudyState(StudyState.SHOWING_QUESTION);

      hasSpokenCurrentQuestion = true;
speakWithWebTts(getPlainTextFromCard(currentCard.question), () => {
  if (isPaused) return;

  if (answerMode === "delay") {
    const delay = Math.max(
      1,
      Math.min(60, Math.floor(answerDelayMs / 1000))
    );

    setStudyState(StudyState.WAITING_FOR_ANSWER);
    questionDelayTimerId = setTimeout(() => {
      if (!isPaused) {
        speakAnswerThenAskDifficulty();
      }
    }, delay * 1000);
  } else {
    // Voice answer mode: listen for user's speech to trigger answer playback
    awaitingAnswerSignal = true;
    setStudyState(StudyState.WAITING_FOR_ANSWER);
    setStatus("Listening for your answer...");
    
    // Add small delay on iOS to allow audio to fully release and voice recognition to activate
    listenForCommand(handleVoiceTranscript);
  }
});
    }

    async function handleNextCardSkip() {
  if (!currentCard || !currentDeckId) return;

  // 1) Hard stop anything that could still fire the answer later
 await stopAllAudio();               // cancels TTS + mic
  clearQuestionDelayTimer();      // kills delay-mode timer
  clearStudyAheadGapTimer();      // kills study-ahead gap window
  clearAnswerAfterSpeechDelay();  // kills ‚Äúanswer after I stop speaking‚Äù timer
  clearMicMuteTimer();            // optional safety

  // 2) Reset flow flags so nothing thinks we‚Äôre mid-step
  awaitingAnswerSignal = false;
  awaitingDifficulty = false;
  inAnswerAfterSpeechDelay = false;

  // 3) Hide answer UI (we‚Äôre skipping it)
  if (voiceAnswer) voiceAnswer.classList.add("hidden");
  if (voiceRatingButtons) voiceRatingButtons.classList.add("hidden");

  // 4) Apply EASY only when schedule changes are enabled
  if (!noScheduleChanges) {
    const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, "easy");
    if (nextState && nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES) {
      queueCardForAgain(currentDeckId, currentCard);
    }
  }

  // 5) Advance
  setStudyState(StudyState.IDLE);
  runVoiceLoop();
}


    function normalizeCmdText(x) {
  return String(x || "")
    .toLowerCase()
    // ‚úÖ allow digits too, so "10" survives
    .replace(/[^a-z0-9\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}
function isNextCardCommand(text) {
  const t = normalizeCmdText(text);
  return (
    t === "go to next card" ||
    t === "go next card" ||       // optional: forgiving variation
    t === "go to the next card"   // optional: forgiving variation
  );
}


// tiny Levenshtein distance (fast enough for 1‚Äì2 word commands)
function levenshtein(a, b) {
  if (a === b) return 0;
  const al = a.length, bl = b.length;
  if (!al) return bl;
  if (!bl) return al;

  const dp = Array.from({ length: al + 1 }, () => new Array(bl + 1).fill(0));
  for (let i = 0; i <= al; i++) dp[i][0] = i;
  for (let j = 0; j <= bl; j++) dp[0][j] = j;

  for (let i = 1; i <= al; i++) {
    for (let j = 1; j <= bl; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[i][j] = Math.min(
        dp[i - 1][j] + 1,
        dp[i][j - 1] + 1,
        dp[i - 1][j - 1] + cost
      );
    }
  }
  return dp[al][bl];
}
function parseMuteSeconds(text) {
  const t = normalizeCmdText(text);

  // Accept ‚Äú10‚Äù, ‚Äúten‚Äù, ‚Äú20‚Äù, ‚Äútwenty‚Äù, etc.
  const map = {
    "10": 10, "ten": 10,
    "20": 20, "twenty": 20,
    "30": 30, "thirty": 30,
    "40": 40, "forty": 40,
    "50": 50, "fifty": 50,
    "60": 60, "sixty": 60,
  };

  // Look for any token that matches
  const parts = t.split(" ");
  for (const p of parts) {
    if (map[p]) return map[p];
  }

  // Handle phrases like "20 seconds"
  if (t.includes("10")) return 10;
  if (t.includes("20")) return 20;
  if (t.includes("30")) return 30;
  if (t.includes("40")) return 40;
  if (t.includes("50")) return 50;
  if (t.includes("60")) return 60;

  return null;
}

function parseRatingFromText(text) {
  const t = normalizeCmdText(text);
  if (!t) return null;

  // Prefer matching the FIRST word for rating commands (reduces false hits)
  const first = t.split(" ")[0] || "";

  // Direct phrase matches
  if (t.includes("repeat question") || t.includes("repeat answer")) return null; // handled elsewhere
  if (t.includes("main menu") || t.includes("go to the main menu")) return null; // handled elsewhere

  // Easy wins
  if (t.includes("again")) return "again";
  if (t.includes("hard")) return "hard";
  if (t.includes("easy")) return "easy";

  // ‚ÄúGood‚Äù synonyms / common mishears
  // (Web Speech often returns could/hood/gud/go when you say "good")
  const goodLike = new Set([
    "good", "fine", "okay", "ok", "k",
    "could", "hood", "gud", "go", "goo", "gould"
  ]);
  if (goodLike.has(first) || t.includes(" good ") || t.endsWith(" good")) return "good";

  // Fuzzy match the FIRST word to the 4 commands
  const targets = ["again", "hard", "good", "easy"];
  let best = null;
  let bestDist = 999;

  for (const cmd of targets) {
    const d = levenshtein(first, cmd);
    if (d < bestDist) {
      bestDist = d;
      best = cmd;
    }
  }

  // Thresholds: short words need tighter thresholds
  // - good/easy/hard: allow distance 1 (e.g., gud -> good)
  // - again: allow distance 2 (it‚Äôs longer)
  if (best === "again" && bestDist <= 2) return "again";
  if (best !== "again" && bestDist <= 1) return best;

  return null;
}

    // Helper: detect "main menu" style commands
function isMainMenuCommand(text) {
  const t = text.toLowerCase();
  return (
    t.includes("main menu") ||
    (t.includes("menu") && t.includes("main")) ||
    t.includes("go back") ||
    t.includes("back to menu") ||
    t.includes("back to the menu") ||
    t.includes("go to the menu") ||
    t.includes("go to main menu")
  );
}

// NEW: stop any current audio, then confirm + go to main menu
async function speakAndGoToMainMenu() {
  await stopAllAudio();
  speakSafe("Going to the main menu.", () => {
    endStudySession();
  });
}

async function handleGlobalVoiceCommands(text) {
  const t = text.toLowerCase();

  // üîÅ Repeat question ‚Äî allowed in ANY voice state when we have a card
  if (t.includes("repeat question") && currentMode === "voice" && currentCard) {
    restartCurrentCardVoiceFlow();
    return true;
  }

  // üîÅ Repeat answer ‚Äî allowed whenever we've already shown an answer
  if (t.includes("repeat answer") && currentMode === "voice" && currentCard) {
    const plainAnswer = getPlainTextFromCard(currentCard.answer);
    speakSafe("Answer: " + plainAnswer, () => {
      if (isPaused) return;

      // If we're in study-ahead + gap, restart the gap window
      if (noScheduleChanges && studyAheadSession && inStudyAheadAnswerGap) {
        startStudyAheadAnswerWindow(true);
        return;
      }

      // If we are waiting for difficulty in normal mode, just re-prompt
      if (awaitingDifficulty && !noScheduleChanges) {
        const detailed =
          !hasSpokenInstructionsOnce || !skipInstructionsAfterFirst;
        hasSpokenInstructionsOnce = true;
        const promptText = detailed
          ? "How was that? Say again, hard, good, or easy."
          : "How was that?";
        speak(promptText, () => {
          listenForCommand(handleVoiceTranscript);
        });
        return;
      }

      // If we're at post-completion choice, re-prompt main menu
      if (awaitingPostCompletionChoice) {
        speakSafe("Say main menu to go back.", () => {
          listenForCommand(handleVoiceTranscript);
        });
        return;
      }

      // Otherwise, just keep listening for the next command
      if (currentMode === "voice") {
        listenForCommand(handleVoiceTranscript);
      }
    });
    return true;
  }

  // üßä Pause study session ‚Äì pause IMMEDIATELY (before speaking)
if (
  t.includes("pause study session") ||
  (t.includes("pause") && (t.includes("study") || t.includes("session")))
) {
  if (currentMode === "voice" && !isPaused) {

    // ‚úÖ pause right now (not inside speak callback)
    isPaused = true;

    // ‚úÖ ensure resume replays same card
    if (currentCard) restartCardOnResumeVoice = true;

    // ‚úÖ kill anything that could advance the session
    await stopAllAudio();
    clearStudyAheadGapTimer();
    clearQuestionDelayTimer();
    clearAnswerAfterSpeechDelay();

    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
    setStatus("Paused. Say 'resume study session' or tap Resume.");

    // optional: quick confirmation, but it won't affect pause state
    speakSafe("Paused.", () => {
      // keep listening while paused so you can say "resume study session"
      listenForCommand(handleVoiceTranscript);
    });
  }
  return true;
}

  // ‚ñ∂Ô∏è Resume study session ‚Äì allowed anytime we‚Äôre paused
  if (
    t.includes("resume study session") ||
    (t.includes("resume") && (t.includes("study") || t.includes("session")))
  ) {
    if (isPaused) {
  speakSafe("Resuming study session.", () => {
    isPaused = false;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;

    if (currentMode === "voice") {
      if (restartCardOnResumeVoice && currentCard) {
        restartCardOnResumeVoice = false;
        restartCurrentCardVoiceFlow();
        return;
      }
      runVoiceLoop();
    } else if (currentMode === "silent") {
      runSilentLoop();
    }
  });
}
    return true;
  }

  // üè† Main menu ‚Äì now allowed in ANY voice state (normal or study-ahead)
  if (isMainMenuCommand(t) && currentMode === "voice") {
    speakAndGoToMainMenu();
    return true;
  }

  // ‚ùå End study session
  if (t.includes("end study session")) {
    endStudySession();
    return true;
  }

  return false;
}

 async function handleVoiceTranscript(text) {
  console.log("[VOICE] handleVoiceTranscript called with text:", text, { awaitingAnswerSignal, awaitingDifficulty, inAnswerAfterSpeechDelay });
  

  // If paused, only allow resume command, ignore all other input (mic stays on)
  if (isPaused) {
    const t = text.toLowerCase();
    if (
      t.includes("resume study session") ||
      (t.includes("resume") && (t.includes("study") || t.includes("session")))
    ) {
      speakSafe("Resuming study session.", () => {
        isPaused = false;
        pauseBtn.disabled = false;
        resumeBtn.disabled = true;
        if (currentMode === "voice") {
          if (restartCardOnResumeVoice && currentCard) {
            restartCardOnResumeVoice = false;
            restartCurrentCardVoiceFlow();
            return;
          }
          runVoiceLoop();
        } else if (currentMode === "silent") {
          runSilentLoop();
        }
      });
    } else {
      // Stay paused, keep listening indefinitely
      setStatus("Paused. Say 'resume study session' or tap Resume.");
      listenForCommand(handleVoiceTranscript);
    }
    return;
  }

  // If we are waiting to play the answer after speech ended, ANY transcript resets the countdown
  if (inAnswerAfterSpeechDelay) {
    if (isNextCardCommand(text)) { handleNextCardSkip(); return; }
    if (normalizeCmdText(text).length > 0) {
      startOrResetAnswerAfterSpeechDelay();
      return;
    }
  }

  // ‚úÖ IMPORTANT: await the async global handler
  if (await handleGlobalVoiceCommands(text)) return;

  // ‚úÖ Next card = skip answer + auto-easy (or just advance in study-ahead)
  if (isNextCardCommand(text) && currentMode === "voice") {
    handleNextCardSkip().catch(console.error);
    return;
  }
  // ===== Mic mute command: ONLY during voice-answer gap (after question, before answer) =====
if (awaitingAnswerSignal && currentMode === "voice") {
  const t = normalizeCmdText(text);

  if (!awaitingMuteSeconds && (t === "mute microphone" || t.includes("mute microphone"))) {
    awaitingMuteSeconds = true;

    // Speak the allowed options and then listen for a number
    speakSafe("10, 20, 30, 40, 50, or 60 seconds?", () => {
      listenForCommand((numText) => {
        const n = parseMuteSeconds(numText);
        if (!n) {
          // reprompt once (safe, minimal)
          speakSafe("Please say 10, 20, 30, 40, 50, or 60.", () => {
            awaitingMuteSeconds = true;
            listenForCommand((numText2) => {
              const n2 = parseMuteSeconds(numText2);
              awaitingMuteSeconds = false;
              if (!n2) {
                speakSafe("Okay, not muting.", () => {
                  // resume listening for the answer
                  if (!isPaused && awaitingAnswerSignal) {
                    setStatus("Listening for your answer...");
                    listenForCommand(handleVoiceTranscript);
                  }
                });
                return;
              }
              startMicMute(n2);
            });
          });
          return;
        }

        awaitingMuteSeconds = false;
        startMicMute(n);
      });
    });

    return; // important: don‚Äôt fall through
  }
  
  // ‚úÖ If we get here while awaitingAnswerSignal is true, the user said something OTHER than "mute microphone"
  // So proceed with playing the answer
  console.log("[VOICE] User spoke in voice-answer mode (not mute), calling startOrResetAnswerAfterSpeechDelay");
  awaitingAnswerSignal = false;
  startOrResetAnswerAfterSpeechDelay();
  return;
}

  // If we were in the study-ahead answer gap, we no longer need a special case here;
  // main menu / repeat answer are already handled globally.

  // If we're choosing what to do after finishing all due cards
  if (awaitingPostCompletionChoice) {
    const wantsMainMenu = isMainMenuCommand(text);

    awaitingPostCompletionChoice = false;

    if (wantsMainMenu) {
      speakAndGoToMainMenu();
      return;
    }

    // Otherwise: enter study-ahead mode (no schedule changes)
    studyAheadSession = true;
    noScheduleChanges = true;
    studyAheadPromptedOnceVoice = false;

    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    speak(
      "Okay, entering study ahead mode. These reviews will not change your future schedule.",
      () => {
        runVoiceLoop();
      }
    );
    return;
  }

  // If we're waiting for the user to say "I'm ready" in voice-answer mode

  // Difficulty / rating flow (normal, schedule-changing mode only)
  if (awaitingDifficulty) {
    const t = text.toLowerCase();
      if (isNextCardCommand(text)) { handleNextCardSkip(); return; }

    // Main menu commands are already handled globally, but just in case:
    if (isMainMenuCommand(t)) {
      awaitingDifficulty = false;
      speakAndGoToMainMenu();
      return;
    }

    // In study-ahead (noScheduleChanges) we should never be here,
    // but if we are, just re-prompt for main menu.
    if (noScheduleChanges) {
      speakSafe("Say main menu to go to the main menu.", () => {
        listenForCommand(handleVoiceTranscript);
      });
      return;
    }

    const ratingKey = parseRatingFromText(text);
    if (!ratingKey) {
      speak(
        "I didn't catch that. Please say again, hard, good, or easy.",
        () => {
          listenForCommand(handleVoiceTranscript);
        }
      );
      return;
    }

    // Apply scheduling normally
    // Apply scheduling normally (this records the rating)
const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, ratingKey);
if (nextState && nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES) {
  queueCardForAgain(currentDeckId, currentCard);
}

awaitingDifficulty = false;
if (voiceRatingButtons) {
  voiceRatingButtons.classList.add("hidden");
}

// ‚úÖ NEW: echo the rating word with mic OFF, then continue
echoRatingThenContinue(ratingKey, () => {
  if (isPaused) return; // safety
  setStudyState(StudyState.IDLE);
  runVoiceLoop();
});

return;
  }

  // Fallback: keep listening for the next command in voice mode
  if (currentMode === "voice") {
    listenForCommand(handleVoiceTranscript);
  }
}

    function describeAutoModeBehavior() {
      switch (autoModeBehavior) {
        case "again":
          return "mark each card as again";
        case "hard":
          return "mark each card as hard";
        case "good":
          return "mark each card as good";
        case "easy":
          return "mark each card as easy";
        case "tomorrow":
          return "push each card to show again tomorrow";
        default:
          return "mark each card as good";
      }
    }

    // ‚úÖ NEW: speak back the chosen rating (echo) with mic OFF, then continue
function echoRatingThenContinue(ratingKey, next) {
  // Normalize what we speak back (exactly the rating word)
  const spoken =
    ratingKey === "again" ? "again" :
    ratingKey === "hard"  ? "hard"  :
    ratingKey === "good"  ? "good"  :
    ratingKey === "easy"  ? "easy"  :
    null;

  if (!spoken) {
    // fallback: just continue
    next && next();
    return;
  }

  // Hard stop any active listening and prevent re-starts during the echo
  keepListening = false;
  if (recognition) {
    try { recognition.stop(); } catch (_) {}
  }

  // Mic OFF during echo
  const prevMicMuted = isMicMuted;
  isMicMuted = true;

  // Optional: disable onscreen rating buttons during echo (prevents accidental taps)
  setVoiceRatingButtonsEnabled(false);

  // Speak the rating word, then continue
  speakWithWebTts(spoken, () => {
    // Restore mic state
    isMicMuted = prevMicMuted;

    // Re-enable rating buttons (though you usually hide them right after)
    setVoiceRatingButtonsEnabled(true);

    next && next();
  }, { lang: "en-US" });
}

function speakAnswerThenAskDifficulty() {
  if (!currentCard) return;

  hasSpokenCurrentAnswer = true;
  setStudyState(StudyState.SHOWING_ANSWER);

  if (voiceAnswer) {
    voiceAnswer.classList.remove("hidden");
  }
  setCardContent(voiceAnswerText, currentCard.answer);

  // ‚úÖ get language for the ANSWER
  const deck = getDeckById(currentDeckId);
  const { aLang } = getCardLangs(deck, currentCard);

  // üîä Speak the answer in its language
  speakWithWebTts(
    getPlainTextFromCard(currentCard.answer),
    async () => {
      if (isPaused) return;

      // ===== STUDY-AHEAD HANDS-FREE: always respect the study-ahead gap and never ask for rating =====
      if (noScheduleChanges && studyAheadSession) {
        startStudyAheadAnswerWindow(false);
        return;
      }

      // ===== Automatic mode for pure hands-free, no commands =====
      if (autoGoodMode) {
        // Only schedule in normal mode; never schedule in noScheduleChanges mode
        if (!noScheduleChanges) {
          const behaviorRating = autoModeBehavior || "good";

          if (autoModeBehavior === "tomorrow") {
            applyTomorrowScheduling(currentDeckId, currentCard.id);
          } else {
            const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, behaviorRating);
            if (
              nextState &&
              nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES
            ) {
              queueCardForAgain(currentDeckId, currentCard);
            }
          }
        }

        // Just advance to the next card
        setStudyState(StudyState.IDLE);
        runVoiceLoop();
        return;
      }

      // ===== Normal hands-free flow: show rating buttons, prompt again/hard/good/easy, then listen =====
      awaitingDifficulty = true;
      if (voiceRatingButtons) {
        voiceRatingButtons.classList.remove("hidden");
      }

      const detailed = !hasSpokenInstructionsOnce || !skipInstructionsAfterFirst;
      hasSpokenInstructionsOnce = true;

      const promptText = detailed
        ? "How was that? Say again, hard, good, or easy."
        : "How was that?";

      setStatus(promptText);

      // ‚úÖ Speak the prompt in English (or change if you want)
      speakWithWebTts(
        promptText,
        () => {
          if (!isPaused) listenForCommand(handleVoiceTranscript);
        },
        { lang: "en-US" }
      );
    },
    { lang: aLang }
  );
}

    // NEW: Study-ahead answer window ‚Äì gives you time to say "repeat answer" or "main menu"
    function startStudyAheadAnswerWindow(restartOnly) {
      if (isPaused) return;
      clearStudyAheadGapTimer();
      inStudyAheadAnswerGap = true;

      const startListeningAndTimer = () => {
        if (!isPaused && currentMode === "voice") {
          listenForCommand(handleVoiceTranscript);
        }
        studyAheadGapTimerId = setTimeout(() => {
          inStudyAheadAnswerGap = false;
          studyAheadGapTimerId = null;
          if (!isPaused && currentMode === "voice" && !awaitingPostCompletionChoice) {
            runVoiceLoop();
          }
        }, studyAheadGapMs);
      };

      if (!restartOnly && !studyAheadPromptedOnceVoice) {
        studyAheadPromptedOnceVoice = true;
        speakSafe("You are in study ahead mode. You can say repeat answer, repeat question, pause study session, resume study session, or main menu before the next card.", () => {
          if (isPaused) return;
          startListeningAndTimer();
        });
      } else {
        startListeningAndTimer();
      }
    }

    // NEW helper: randomized next-card picker for normal (schedule-changing) mode
    function pickRandomNextCardNormal(dueCards, lastId, isSilentMode) {
      // Remove duplicates between reviewQueue and dueCards
      const uniqueDue = dueCards.filter(card =>
        !reviewQueue.some(r => r.id === card.id)
      );

      const reviewCandidates = reviewQueue.slice();
      const dueCandidates = uniqueDue;

      function pickFromPool(pool) {
        if (pool.length === 0) return null;
        let candidates = pool;
        if (pool.length > 1 && lastId) {
          const filtered = pool.filter(c => c.id !== lastId);
          if (filtered.length > 0) {
            candidates = filtered;
          }
        }
        const idx = Math.floor(Math.random() * (candidates.length));
        return candidates[idx];
      }

      function chooseRandom() {
        if (reviewCandidates.length === 0 && dueCandidates.length === 0) return null;

        let poolType;
        if (reviewCandidates.length && dueCandidates.length) {
          // 50/50 mix when both exist
          poolType = Math.random() < 0.5 ? "review" : "due";
        } else if (reviewCandidates.length) {
          poolType = "review";
        } else {
          poolType = "due";
        }

        let candidate = pickFromPool(poolType === "review" ? reviewCandidates : dueCandidates);

        // If we couldn't get a candidate from that pool (e.g., only lastId and we're avoiding it),
        // fall back to the other pool if possible.
        if (!candidate && poolType === "review") {
          candidate = pickFromPool(dueCandidates);
        } else if (!candidate && poolType === "due") {
          candidate = pickFromPool(reviewCandidates);
        }

        // In silent mode we prefer never to repeat the same card back-to-back
        // when there are other options. The picker above already tries to avoid
        // lastId when pool size > 1, so at this point if candidate === lastId,
        // it means it's the only card available globally.
        return candidate;
      }

      const chosen = chooseRandom();

      if (chosen && reviewQueue.length > 0) {
        // If we picked from reviewQueue, remove it so it can be re-queued later
        const idx = reviewQueue.findIndex(c => c.id === chosen.id);
        if (idx !== -1) {
          reviewQueue.splice(idx, 1);
        }
      }

      return chosen;
    }

    function runVoiceLoop() {
      if (isPaused) {
        setStatus("Paused.");
        return;
      }
      clearStudyAheadGapTimer();
      clearQuestionDelayTimer();
      clearAnswerAfterSpeechDelay();
      const deck = getDeckById(currentDeckId);
      if (!deck || deck.cards.length === 0) {
        if (voiceQuestionText) voiceQuestionText.textContent = "";
        if (voiceAnswerText) voiceAnswerText.textContent = "";
        if (voiceAnswer) voiceAnswer.classList.add("hidden");

        setStudyState(StudyState.IDLE);
        speakSafe("This deck has no cards.", () => {
          awaitingPostCompletionChoice = true;
          speakSafe("Say main menu to go back.", () =>
            listenForCommand(handleVoiceTranscript)
          );
        });
        return;
      }

      const allowAhead = studyAheadSession;
      const includeOverdue = !noScheduleChanges;
      const lastId = currentCard ? currentCard.id : null;

      let nextCard = null;

      // If resuming after main menu, show the same card first
      if (currentCard && currentMode === null) {
        nextCard = currentCard;
        currentMode = "voice"; // or "silent" if needed
      } else if (noScheduleChanges && allowAhead) {
        if (!aheadQueue || aheadQueue.length === 0) {
          aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
          aheadQueueIndex = 0;
        }
        if (aheadQueueIndex < aheadQueue.length) {
          nextCard = aheadQueue[aheadQueueIndex++];
        } else {
          nextCard = null;
        }
      } else {
        // Normal schedule-changing mode with randomized mixing
        const dueCards = getDueCardsForDeck(currentDeckId, false, includeOverdue);
        const { overdue, due } = splitOverdueAndDue(currentDeckId, dueCards);

        // üö® Always exhaust overdue cards first
        if (overdue.length > 0) {
          nextCard = pickRandomNextCardNormal(overdue, lastId, false);
        } else {
          nextCard = pickRandomNextCardNormal(due, lastId, false);
        }
      }

      if (!nextCard && !allowAhead) {
  // Finished all due cards (normal mode)
  if (autoEnterStudyAhead) {
    // Automatically enter study-ahead mode
    studyAheadSession = true;
    noScheduleChanges = true;
    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    setStudyState(StudyState.IDLE);
    speak(
      "Congratulations, you are all caught up, no more cards are due today. Entering study ahead mode.",
      () => {
        runVoiceLoop();
      }
    );
    return;
  }

  // Old behavior: ask if they want study-ahead
  setStudyState(StudyState.IDLE);
  awaitingPostCompletionChoice = true;
  speak(
    "Congratulations, you are all caught up, no more cards are due today.",
    () => {
      speak(
        "If you'd like to go back to the main menu, say 'main menu'. Otherwise, say 'study ahead mode' to enter study ahead mode, which lets you review all cards in this deck without affecting their future due dates.",
        () => {
          listenForCommand(handleVoiceTranscript);
        }
      );
    }
  );
  return;
} else if (!nextCard && allowAhead) {
  // Finished all cards in study-ahead mode
  if (noScheduleChanges && studyAheadSession && loopStudyAhead) {
    // Automatically loop study-ahead again (no extra prompt)
    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    if (aheadQueue.length > 0) {
      setStudyState(StudyState.IDLE);
      runVoiceLoop();
      return;
    }
    // If for some reason there are no cards, fall through to message below
  }

  setStudyState(StudyState.IDLE);
  awaitingPostCompletionChoice = true;
  speak(
    "There are no more cards available to study in this deck right now.",
    () => {
      speakSafe("Say main menu to go back, or study ahead to enter review all cards in this deck again.", () =>
        listenForCommand(handleVoiceTranscript)
      );
    }
  );
  return;
}

      currentCard = nextCard;
      setStatus("Studying card...");
      hasSpokenCurrentQuestion = false;
      hasSpokenCurrentAnswer = false;

      setCardContent(voiceQuestionText, currentCard.question);
setCardContent(voiceAnswerText, currentCard.answer);

      if (voiceAnswer) {
        voiceAnswer.classList.add("hidden");
      }
      voiceEditPanel.classList.add("hidden");
   // Show rating buttons immediately AND make them clickable right away
if (!noScheduleChanges && !autoGoodMode && voiceRatingButtons) {
  voiceRatingButtons.classList.remove("hidden");
  setVoiceRatingButtonsEnabled(true);
} else if (voiceRatingButtons) {
  voiceRatingButtons.classList.add("hidden");
}

      hasSpokenCurrentQuestion = true;
setStudyState(StudyState.SHOWING_QUESTION);

// üîä Use the same MP3-capable helper for the question
const { qLang } = getCardLangs(deck, currentCard);

speakWithWebTts(
  getPlainTextFromCard(currentCard.question),
  () => {
    if (isPaused) return;

    if (answerMode === "delay") {
      const delay = Math.max(
        1,
        Math.min(60, Math.floor(answerDelayMs / 1000))
      );

      if (!autoGoodMode) {
        listenForCommand(handleVoiceTranscript);
      }

      setStudyState(StudyState.WAITING_FOR_ANSWER);
      questionDelayTimerId = setTimeout(() => {
        if (!isPaused) {
          speakAnswerThenAskDifficulty();
        }
      }, delay * 1000);
    } else {
      awaitingAnswerSignal = true;
      setStudyState(StudyState.WAITING_FOR_ANSWER);
      setStatus("Listening for your answer...");
      listenForCommand(handleVoiceTranscript);
    }
  },
  { lang: qLang }
);
    }

    // ===================== SILENT MODE =====================
    function clearSilentHints() {
      hintAgain.textContent = "";
      hintHard.textContent = "";
      hintGood.textContent = "";
      hintEasy.textContent = "";
    }

    function updateSilentDueHints() {
      if (!currentCard || noScheduleChanges) {
        clearSilentHints();
        return;
      }
      const deckId = currentDeckId;
      const cardId = currentCard.id;

      // "Again" always means ~5 minutes (back to ladder level 1)
      hintAgain.textContent = "5 min >";

      const hardMinutes = previewIntervalMinutes(deckId, cardId, "hard");
      const goodMinutes = previewIntervalMinutes(deckId, cardId, "good");
      const easyMinutes = previewIntervalMinutes(deckId, cardId, "easy");

      function formatInterval(minutes) {
        if (minutes < 60) {
          const m = Math.max(1, Math.round(minutes));
          return m + " min";
        }
        const hours = minutes / 60;
        if (hours < 24) {
          const h = Math.max(1, Math.round(hours));
          return h + " hr" + (h === 1 ? "" : "s");
        }
        const days = minutes / MINUTES_PER_DAY;
        if (days < 14) {
          const d = Math.max(1, Math.round(days));
          return d + " day" + (d === 1 ? "" : "s");
        }
        const weeks = days / 7;
        const w = Math.max(1, Math.round(weeks));
        return w + " wk" + (w === 1 ? "" : "s");
      }

      hintHard.textContent = "Next in " + formatInterval(hardMinutes);
      hintGood.textContent = "Next in " + formatInterval(goodMinutes);
      hintEasy.textContent = "Next in " + formatInterval(easyMinutes);
    }

    function runSilentLoop() {
      if (isPaused) {
        setStatus("Paused.");
        return;
      }
      const deck = getDeckById(currentDeckId);
      if (!deck || deck.cards.length === 0) {
        setStatus("This deck has no cards.");
        silentQuestionText.textContent = "";
        silentQuestion.classList.remove("hidden");
        silentAnswer.classList.add("hidden");
        showAnswerBtn.classList.remove("hidden");
        silentRatingButtons.classList.add("hidden");
        silentNextCardBtn.classList.add("hidden");
        clearSilentHints();
        silentCompletionControls.classList.add("hidden");
        silentEditPanel.classList.add("hidden");
        setStudyState(StudyState.IDLE);
        return;
      }
      const allowAhead = studyAheadSession;
      const includeOverdue = !noScheduleChanges;
      const lastId = currentCard ? currentCard.id : null;

      let nextCard = null;

      // Study-ahead (no schedule changes) uses aheadQueue
      if (noScheduleChanges && allowAhead) {
        if (!aheadQueue || aheadQueue.length === 0) {
          aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
          aheadQueueIndex = 0;
        }
        if (aheadQueueIndex < aheadQueue.length) {
          nextCard = aheadQueue[aheadQueueIndex++];
        } else {
          nextCard = null;
        }
      } else {
        // Normal schedule-changing mode (silent) with randomized mixing
        const dueCards = getDueCardsForDeck(currentDeckId, false, includeOverdue);
const { overdue, due } = splitOverdueAndDue(currentDeckId, dueCards);

if (overdue.length > 0) {
  nextCard = pickRandomNextCardNormal(overdue, lastId, true);
} else {
  nextCard = pickRandomNextCardNormal(due, lastId, true);
}
      }

      if (!nextCard && !allowAhead) {
  // Finished all due cards (normal mode)
  if (autoEnterStudyAhead) {
    setStatus("Congratulations, you are all caught up. Entering study ahead mode.");
    studyAheadSession = true;
    noScheduleChanges = true;

    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    silentCompletionControls.classList.add("hidden");
    silentNextCardBtn.classList.remove("hidden");
    setStudyState(StudyState.IDLE);
    runSilentLoop();
    return;
  }

  // Old behavior: show completion controls
  setStatus(
    "Congratulations, you are all caught up, no more cards are due today."
  );
  silentQuestionText.textContent = "";
  silentQuestion.classList.add("hidden");
  silentAnswer.classList.add("hidden");
  showAnswerBtn.classList.add("hidden");
  silentRatingButtons.classList.add("hidden");
  silentNextCardBtn.classList.add("hidden");
  clearSilentHints();
  pauseBtn.classList.add("hidden");
  resumeBtn.classList.add("hidden");
  silentCompletionControls.classList.remove("hidden");
  silentEditPanel.classList.add("hidden");
  setStudyState(StudyState.IDLE);
  return;
} else if (!nextCard && allowAhead) {
  // Finished all cards in study-ahead mode
  if (noScheduleChanges && studyAheadSession && loopStudyAhead) {
    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    if (aheadQueue.length > 0) {
      setStudyState(StudyState.IDLE);
      runSilentLoop();
      return;
    }
    // fall through if somehow there are still no cards
  }

  setStatus("There are no more cards available to study in this deck right now.");
  silentQuestionText.textContent = "";
  silentQuestion.classList.add("hidden");
  silentAnswer.classList.add("hidden");
  showAnswerBtn.classList.add("hidden");
  silentRatingButtons.classList.add("hidden");
  silentNextCardBtn.classList.add("hidden");
  clearSilentHints();
  silentCompletionControls.classList.add("hidden");
  silentEditPanel.classList.add("hidden");
  setStudyState(StudyState.IDLE);
  return;
}

      silentCompletionControls.classList.add("hidden");
      silentQuestion.classList.remove("hidden");
      showAnswerBtn.classList.remove("hidden");
      pauseBtn.classList.remove("hidden");
      resumeBtn.classList.remove("hidden");

      currentCard = nextCard;
      setStatus("Studying card...");
      setCardContent(silentQuestionText, currentCard.question);
setCardContent(silentAnswerText, currentCard.answer);
      silentAnswer.classList.add("hidden");
      silentRatingButtons.classList.add("hidden");
      clearSilentHints();
      silentEditPanel.classList.add("hidden");

      setCardContent(voiceQuestionText, currentCard.question);
setCardContent(voiceAnswerText, currentCard.answer);

      if (noScheduleChanges) {
        silentNextCardBtn.classList.remove("hidden");
      } else {
        silentNextCardBtn.classList.add("hidden");
      }

      setStudyState(StudyState.SHOWING_QUESTION);
    }

    showAnswerBtn.addEventListener("click", () => {
      if (!currentCard) return;

      // study-ahead silent: tap once to show answer, second tap goes next
      if (noScheduleChanges && !silentAnswer.classList.contains("hidden")) {
        silentAnswer.classList.add("hidden");
        clearSilentHints();
        setStudyState(StudyState.IDLE);
        runSilentLoop();
        return;
      }

      silentAnswer.classList.remove("hidden");
      setStudyState(StudyState.SHOWING_ANSWER);
      if (noScheduleChanges) {
        silentRatingButtons.classList.add("hidden");
        clearSilentHints();
      } else {
        silentRatingButtons.classList.remove("hidden");
        updateSilentDueHints();
        setStudyState(StudyState.WAITING_FOR_RATING);
      }
    });

    silentNextCardBtn.addEventListener("click", () => {
      if (!currentCard) return;
      silentAnswer.classList.add("hidden");
      clearSilentHints();
      setStudyState(StudyState.IDLE);
      runSilentLoop();
    });

    silentRatingButtons.addEventListener("click", (e) => {
      const btn = e.target;
      if (!btn.dataset.rating || !currentCard) return;
      const ratingKey = btn.dataset.rating;
      if (!noScheduleChanges) {
        const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, ratingKey);
        if (nextState && nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES) {
          queueCardForAgain(currentDeckId, currentCard);
        }
      }
      setStudyState(StudyState.IDLE);
      runSilentLoop();
    });

        // Rating buttons for voice (hands-free) mode ‚Äì optional tap instead of speaking
    if (voiceRatingButtons) {
  voiceRatingButtons.addEventListener("click", async (e) => {
    const btn = e.target.closest("button[data-voice-rating]");
    if (!btn || !currentCard) return;

    const ratingKey = btn.dataset.voiceRating;

    clearQuestionDelayTimer();
    clearStudyAheadGapTimer();
    awaitingAnswerSignal = false;
    awaitingDifficulty = false;

    await stopAllAudio();

    if (!noScheduleChanges) {
      const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, ratingKey);
      if (nextState && nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES) {
        queueCardForAgain(currentDeckId, currentCard);
      }
    }

    voiceRatingButtons.classList.add("hidden");
    setStudyState(StudyState.IDLE);
    // If autoGood is not enabled, delay before next question
    if (!autoGoodToggle.checked && handsFreeNextDelayMs > 0) {
      setTimeout(() => {
        runVoiceLoop();
      }, handsFreeNextDelayMs);
    } else {
      runVoiceLoop();
    }
  });
}

    silentMainMenuBtn.addEventListener("click", () => {
      silentCompletionControls.classList.add("hidden");
      endStudySession();
    });

    silentStudyAheadBtn.addEventListener("click", () => {
      silentCompletionControls.classList.add("hidden");
      studyAheadSession = true;
      noScheduleChanges = true;

      aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
      aheadQueueIndex = 0;

      silentQuestion.classList.remove("hidden");
      showAnswerBtn.classList.remove("hidden");
      pauseBtn.classList.remove("hidden");
      resumeBtn.classList.remove("hidden");
      silentNextCardBtn.classList.remove("hidden");
      runSilentLoop();
    });

    startSilentBtn.addEventListener("click", () => {
      saveLastMode("silent");
if (selectedDeckId) saveLastDeckId(selectedDeckId);
      currentDeckId = selectedDeckId;
      if (!currentDeckId) return;
      skipInstructionsAfterFirst = !!skipInstructionsAfterFirstCheckbox.checked;
      autoEnterStudyAhead = !!autoEnterStudyAheadCheckbox.checked;
loopStudyAhead = !!loopStudyAheadCheckbox.checked;

      // Start in normal due-today mode; study-ahead entered from completion controls
      studyAheadSession = false;
      noScheduleChanges = false;
      reviewQueue = [];
      aheadQueue = [];
      aheadQueueIndex = 0;
      silentCompletionControls.classList.add("hidden");
      silentNextCardBtn.classList.add("hidden");

      silentUI.classList.remove("hidden");
      voiceUI.classList.add("hidden");

      showStudySection("silent");
      runSilentLoop();
    });

    // ===================== INIT & AUTO MODE WIRING =====================
    // Disable rating select when automatic mode is off (UX polish)
    autoRatingSelect.disabled = true;
    autoGoodToggle.addEventListener("change", () => {
      autoRatingSelect.disabled = !autoGoodToggle.checked;
    });

    function describeAutoIntro() {
      const desc = describeAutoModeBehavior();
      if (autoModeBehavior === "tomorrow") {
        return "Starting automatic hands free study session. I will read the question, then the answer, and " + desc + ".";
      }
      return "Starting automatic hands free study session. I will read the question, then the answer, and " + desc + ".";
    }

    // >>> MODIFIED: add async + inline mic permission request here <<<
    // >>> REPLACE your existing startVoiceBtn handler with this whole block <<<
startVoiceBtn.addEventListener("click", async () => {
  saveLastMode("voice");
  if (selectedDeckId) saveLastDeckId(selectedDeckId);

  // ‚úÖ Set autoGoodMode/options EARLY so we can use it for conditional initialization
  autoModeBehavior = autoRatingSelect.value || "good";
  autoGoodMode = !!autoGoodToggle.checked;
  autoEnterStudyAhead = !!autoEnterStudyAheadCheckbox.checked;
  loopStudyAhead = !!loopStudyAheadCheckbox.checked;

  // ‚úÖ Determine answer mode (needed to decide if we need VoiceCommands)
  const selectedAnswerMode = answerModeVoiceRadio.checked ? "voice" : "delay";

  // ‚úÖ Only initialize VoiceCommands if we actually need voice input
  // Skip if in auto-good mode WITH delay answer (no STT needed)
  // But DO initialize if answer mode is "voice" (need to detect when user speaks)
  const needsVoiceCommands = !autoGoodMode || selectedAnswerMode === "voice";

  // ‚úÖ Deck id: fall back to dropdown value if selectedDeckId isn't set
  currentDeckId = selectedDeckId || (deckSelect ? deckSelect.value : null);
  if (!currentDeckId) {
    alert("Please select a deck first.");
    return;
  }


  // ‚úÖ Browser mic permission (web version: always request if needed)
  if (
    (typeof isNativeApp === "undefined" || !isNativeApp) &&
    needsVoiceCommands &&
    navigator.mediaDevices &&
    navigator.mediaDevices.getUserMedia
  ) {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      if (stream && stream.getTracks) stream.getTracks().forEach((t) => t.stop());
      console.log("Microphone permission requested.");
    } catch (err) {
      console.error("Microphone permission error:", err);
      alert(
        "Microphone access is required for hands-free study in the browser. " +
        "Please enable it in your browser's site settings and try again."
      );
      return;
    }
  }

  // If we need voice commands but have NO native plugin and NO browser STT, we can't proceed
 if (needsVoiceCommands && !speechSupported) {
    alert("Speech recognition not supported in this environment.");
    return;
  }

  // ‚úÖ Clean slate (prevents ‚Äúnothing happens‚Äù due to stale timers/audio)
  await stopAllAudio();
  clearStudyAheadGapTimer();
  clearQuestionDelayTimer();
  clearAnswerAfterSpeechDelay();

  skipInstructionsAfterFirst = !!skipInstructionsAfterFirstCheckbox.checked;
  hasSpokenInstructionsOnce = false;

  // Start in normal ‚Äúdue today‚Äù mode; study-ahead only after completion
  studyAheadSession = false;
  noScheduleChanges = false;
  studyAheadPromptedOnceVoice = false;
  reviewQueue = [];
  aheadQueue = [];
  aheadQueueIndex = 0;
  hasSpokenCurrentQuestion = false;
  hasSpokenCurrentAnswer = false;

  // Determine answer mode from user selection (NOT forced by autoGoodMode)
  // autoGoodMode just changes HOW we rate, not WHEN we show the answer
  answerMode = answerModeVoiceRadio.checked ? "voice" : "delay";

  const secs = parseInt(answerDelaySecondsInput.value, 10);
  answerDelayMs = isNaN(secs) ? 4000 : Math.max(1, Math.min(60, secs)) * 1000;

  const gapSecs = parseInt(studyAheadGapSecondsInput.value, 10);
  studyAheadGapMs = isNaN(gapSecs) ? 4000 : Math.max(1, Math.min(60, gapSecs)) * 1000;

  // Switch UI into voice mode
  voiceUI.classList.remove("hidden");
  silentUI.classList.add("hidden");
  showStudySection("voice");
  setStudyState(StudyState.IDLE);

  const intro = autoGoodMode
    ? describeAutoIntro()
    : "Starting hands free study session. I will read a question, then the answer, then ask how hard it was.";

  // ‚úÖ Don‚Äôt pre-check cards here; let runVoiceLoop be the single source of truth
  speak(intro, () => {
    runVoiceLoop();
  });
});

    // <<< END MODIFIED HANDLER <<<

    if (studyInstructionsBtn) {
  studyInstructionsBtn.addEventListener("click", () => {
    openInstructionsModal();
  });
}

 async function init() {

  // 1) Check session early - if no session, redirect to login
  try {
    const { data: sessionData, error: sessErr } = await supabaseClient.auth.getSession();
    const session = sessionData?.session || null;

    console.log("[BOOT] getSession()", {
      hasSession: !!session,
      sessErr: sessErr ? { message: sessErr.message, name: sessErr.name } : null
    });

    if (!session) {
      console.warn("[BOOT] No session. Not redirecting to index.html (app mode)");
      showSessionError("No session found. Please log in again.");
      return;
    }

    // 2) Set currentUser + show auth bar
    currentUser = session.user;
    if (userEmailLabel) userEmailLabel.textContent = currentUser.email || "";
    if (authLoggedIn) authLoggedIn.classList.remove("hidden");

  } catch (e) {
    console.error("[BOOT] Session check failed:", e);
    showSessionError("Session check failed. Please log in again.");
    return;
  }

  // 3) Load local data first (fast)
  try {
    loadFromStorage();
  } catch (e) {
    console.error("loadFromStorage failed:", e);
  }

  // 4) Immediately render whatever we have locally
  try {
    if (typeof rebuildDeckUI === "function") rebuildDeckUI();
  } catch (e) {
    console.error("rebuildDeckUI (local) failed:", e);
  }

// ===== Show session error UI =====
function showSessionError(msg) {
  let el = document.getElementById("sessionErrorMsg");
  if (!el) {
    el = document.createElement("div");
    el.id = "sessionErrorMsg";
    el.style.position = "fixed";
    el.style.top = "0";
    el.style.left = "0";
    el.style.width = "100vw";
    el.style.background = "#1e293b";
    el.style.color = "#fff";
    el.style.zIndex = "99999";
    el.style.padding = "1.5rem 1rem";
    el.style.textAlign = "center";
    el.style.fontSize = "1.1rem";
    el.style.fontWeight = "bold";
    el.innerText = msg || "Session error. Please log in again.";
    document.body.appendChild(el);
  } else {
    el.innerText = msg || "Session error. Please log in again.";
    el.style.display = "block";
  }
}

  // 5) Load remote state (if logged in)
  try {
    if (currentUser && typeof loadStateFromSupabase === "function") {
      await loadStateFromSupabase();
      hasLoadedRemote = true;

      // 6) Re-render again AFTER remote arrives
      try {
        if (typeof rebuildDeckUI === "function") rebuildDeckUI();
      } catch (e) {
        console.error("rebuildDeckUI (remote) failed:", e);
      }
    } else {
      hasLoadedRemote = false;
    }
  } catch (e) {
    console.error("init remote load failed", e);
    hasLoadedRemote = false;
  }
   applyStudyPrefsToUIAndState();
  wireStudyPrefsListeners();
}

init();


  </script>
</body>
</html>
