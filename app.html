<!DOCTYPE html>
<html lang="en">
<head>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <meta charset="UTF-8" />
  <title>ZenCards ‚Äî Hands-Free Audio Flashcards </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- MathJax for rendering LaTeX equations in cards -->
   <script>
    console.log("APP VERSION:", "2026-01-04 10:33am");

    
  window.MathJax = {
    startup: {
      ready: () => {
        console.log("MathJax ready");
        MathJax.startup.defaultReady();
      }
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  <style>
    /* Hide Sign Up button on app.html (users sign up on landing) */
#signUpBtn {
  display: none !important;
}
#authLoggedOut .row {
  justify-content: center;
}

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at top, #1f2937 0, #020617 55%);
      color: #e5e7eb;
      margin: 0;
      padding: 1rem;
      line-height: 1.5;
    }
    h1, h2, h3 {
      margin: 0.5rem 0;
    }

    button:disabled {
  opacity: 0.45;
  cursor: not-allowed;
}

    /* App header + logo */
    .appHeader {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.6rem;
      margin-bottom: 0.15rem;
    }
    .logoMark {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.9);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      background: radial-gradient(circle at 30% 0%, #22c55e 0, #22c55e22 45%, #020617 70%);
      box-shadow: 0 8px 18px rgba(15,23,42,0.9);
      color: #e5e7eb;
      flex-shrink: 0;
    }
    .appTitle {
      text-align: center;
      font-size: 1.9rem;
      letter-spacing: 0.04em;
    }
    .appSubtitle {
      text-align: center;
      font-size: 0.95rem;
      color: #9ca3af;
      margin-top: 0.15rem;
      margin-bottom: 0.75rem;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    .card {
      background: #020617cc;
      border-radius: 0.9rem;
      padding: 1rem;
      margin-top: 1rem;
      border: 1px solid #1f2937;
      box-shadow:
        0 18px 35px rgba(0,0,0,0.55),
        0 0 0 1px rgba(15,23,42,0.7);
    }
    label {
      display: inline-block;
      margin: 0.25rem 0;
      font-size: 0.9rem;
    }
    input[type="text"], textarea, select, input[type="number"] {
      width: 100%;
      padding: 0.55rem 0.65rem;
      border-radius: 0.6rem;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      box-sizing: border-box;
      font-size: 0.9rem;
    }
    input[type="text"]:focus,
    textarea:focus,
    select:focus,
    input[type="number"]:focus {
      outline: none;
      border-color: #22c55e;
      box-shadow: 0 0 0 1px rgba(34,197,94,0.35);
    }
    textarea {
      min-height: 60px;
    }
    textarea.drag-hover {
  outline: 2px dashed #22c55e;
}

    button {
      margin: 0.25rem 0.25rem 0.25rem 0;
      padding: 0.5rem 1.2rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: #10b981;
      color: #020617;
      font-weight: 600;
      font-size: 0.95rem;
      transition:
        background 0.15s ease,
        transform 0.08s ease,
        box-shadow 0.12s ease;
      box-shadow: 0 8px 18px rgba(16,185,129,0.28);
    }
    button:hover:not(:disabled) {
      background: #22c55e;
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(34,197,94,0.35);
    }
    button:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(15,23,42,0.6);
    }
    button.secondary {
      background: #374151;
      color: #e5e7eb;
      box-shadow: none;
    }
    button.secondary:hover:not(:disabled) {
      background: #4b5563;
      box-shadow: 0 6px 14px rgba(15,23,42,0.65);
    }
    button.small {
      padding: 0.25rem 0.7rem;
      font-size: 0.8rem;
    }
    button:disabled {
      background: #374151;
      cursor: default;
      box-shadow: none;
      opacity: 0.7;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
    }
/* Decks layout fix for mobile */
.deckRow {
  align-items: flex-start;
}

@media (max-width: 600px) {
  .deckRow {
    flex-direction: column;
  }
  .deckRow > * {
    width: 100%;
  }
}

    .row > * {
      flex: 1;
      min-width: 0;
    }
    .inline {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      margin-right: 0.75rem;
    }
    .badge {
      display: inline-block;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      background: #1f2937;
      font-size: 0.75rem;
      margin-left: 0.25rem;
    }
    #status {
      margin-top: 0.75rem;
      font-size: 0.9rem;
      color: #9ca3af;
      min-height: 1.2em;
    }
    #cardsList {
      max-height: 180px;
      overflow-y: auto;
      margin-top: 0.5rem;
      border-top: 1px solid #111827;
      padding-top: 0.5rem;
    }
    .cardRow {
      padding: 0.35rem 0;
      border-bottom: 1px solid #020617;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
    }
    /* Horizontal rating layout */
.ratingRow {
  display: flex;
  gap: 0.6rem;
  flex-wrap: wrap;          /* wraps nicely on small screens */
  align-items: flex-start;
  margin-top: 0.5rem;
}

.ratingItem {
  display: flex;
  flex-direction: column;   /* button on top, hint under it */
  gap: 0.25rem;
}

.ratingItem .dueHint {
  margin: 0;                /* remove extra spacing */
}

    #cardsHeader {
  padding: 0.25rem 0;
  border-top: 1px solid #111827;
  border-bottom: 1px solid #111827;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.8rem;
  color: #9ca3af;
  text-transform: uppercase;
  letter-spacing: 0.06em;
}

#cardsHeader span:first-child {
  flex: 1;
  min-width: 0;
}

#cardsHeader .dueDateCell {
  flex: 0 0 130px;
  text-align: center;
  white-space: nowrap;
}

.cardRow .dueDateCell {
  flex: 0 0 130px;
  text-align: center;
  white-space: nowrap;
  font-size: 0.75rem;
  color: #9ca3af;
}
/* Visually mark overdue cards in the card list */
.cardRow.overdue .dueDateCell {
  color: #f97373;
  font-weight: 600;
}

.cardRow.overdue span:first-child {
  color: #f97373;
}

.cardActions {
  display: flex;
  gap: 0.25rem;
  flex: 0 0 auto;
}
    .cardRow span {
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: #e5e7eb;
    }
    .cardRow:hover span {
      color: #a5b4fc;
    }
    .hidden {
      display: none;
    }
    /* ===== Modal styling ===== */
.modal {
  position: fixed;
  inset: 0;
  z-index: 9999;
}

.modalBackdrop {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.6);
}

.modalCard {
  position: relative;
  width: min(720px, calc(100% - 2rem));
  margin: 10vh auto;
  background: #020617;
  border: 1px solid #1f2937;
  border-radius: 0.9rem;
  padding: 1rem;
  box-shadow: 0 25px 60px rgba(0,0,0,0.6);
}
    #studySection {
      margin-top: 1rem;
    }
    /* Shared visual style for both silent + voice question/answer blocks */
    #silentQuestion, #silentAnswer, #voiceQuestion, #voiceAnswer {
      margin-top: 0.75rem;
      padding: 0.75rem;
      background: #020617;
      border-radius: 0.6rem;
      min-height: 3rem;
      border: 1px solid #1f2937;
    }
    #modeBadge {
      font-size: 0.8rem;
      margin-left: 0.5rem;
    }
    .dueHint {
      display: block;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.35rem;
    }

  </style>
</head>
<body>
    <div>
  </div>
</div>

  <div class="container">
  

      <!-- Shown when logged IN -->
      <div id="authLoggedIn" class="hidden">
        <p style="margin-bottom:0.5rem;">
          Signed in as <strong id="userEmailLabel"></strong>
        </p>
        <button id="logOutBtn" class="secondary small">Log Out</button>
        <button id="manageBillingBtn">Manage Billing</button>
         <button id="resetPasswordLoggedInBtn" class="secondary small">Reset Password</button>
      </div>
    </div>

    <div class="appHeader">
      <div class="logoMark">Z</div>
      <h1 class="appTitle">ZenCards</h1>
    </div>
    <p class="appSubtitle">Hands-free & silent spaced&nbsp;repetition flashcards</p>

    <!-- ========== MAIN SETTINGS / MENU ========== -->
    <div id="mainMenu" class="card">
      <h2>Main Menu</h2>

      <!-- Deck controls -->
      <div class="card">
        <h3>Decks</h3>
          <div class="row deckRow">
          <div>
            <label for="deckSelect">Select deck:</label>
            <select id="deckSelect"></select>
          </div>
          <div>
            <label for="newDeckName">New deck name:</label>
            <input id="newDeckName" type="text" placeholder="e.g. Bio, Anatomy, etc." />
          </div>
          <div style="flex:0 0 auto;">
            <button id="addDeckBtn">Add Deck</button>
            <!-- Delete deck button -->
            <button id="deleteDeckBtn" class="secondary">Delete Deck</button>
          </div>
        </div>
        <!-- Legend for counts -->
        <p style="font-size:0.8rem;color:#9ca3af;margin-top:0.35rem;">
  Legend: <em>Deck name (new / learning / review)</em>
</p>
      </div>

      <!-- Card editor / viewer -->
      <div class="card">
        <h3>Cards (Viewer & Editor)</h3>
        <div class="row">
         <div>
  <label for="cardQuestion">Question:</label>
  <textarea id="cardQuestion" placeholder="Enter question"></textarea>
  
  <div style="margin-top:0.25rem;font-size:0.8rem;">
    <button type="button"
            class="secondary small"
            data-insert-image
            data-target="cardQuestion">
      Insert image‚Ä¶
    </button>
    <span style="color:#9ca3af;">
      (Paste URL, choose file, or drag &amp; drop an image here)
    </span>
  </div>
</div>
<div>
  <label for="cardAnswer">Answer:</label>
  <textarea id="cardAnswer" placeholder="Enter answer"></textarea>
  
  <div style="margin-top:0.25rem;font-size:0.8rem;">
    <button type="button"
            class="secondary small"
            data-insert-image
            data-target="cardAnswer">
      Insert image‚Ä¶
    </button>
    <span style="color:#9ca3af;">
      (Paste URL, choose file, or drag &amp; drop an image here)
    </span>
  </div>
</div>
        </div>
        <div class="row">
          <div style="flex:0 0 auto;">
            <button id="addCardBtn">Add Card</button>
            <button id="updateCardBtn" class="secondary" disabled>Update Selected Card</button>
          </div>
          <div>
            <span id="selectedCardInfo" style="font-size:0.85rem;color:#9ca3af;"></span>
          </div>
        </div>
        <!-- Move card to another deck -->
<div class="row" style="margin-top:0.5rem;">
  <div>
    <label for="moveDeckSelect">Move selected card to deck (edit a card to select it):</label>
    <select id="moveDeckSelect"></select>
  </div>
  <div style="flex:0 0 auto;">
    <button id="moveCardBtn" class="secondary" disabled>Move Card</button>
  </div>
</div>
                <!-- Cards table header -->
        <div id="cardsHeader">
          <span>Question</span>
          <span class="dueDateCell">Due date</span>
          <span style="flex:0 0 auto;text-align:right;">Actions</span>
        </div>
        <div id="cardsList"></div>

        <!-- NEW: Import from Anki block -->
        <div style="margin-top:0.75rem;border-top:1px solid #111827;padding-top:0.5rem;">
          <label for="ankiImport" style="display:block;margin-bottom:0.25rem;">
            Import from Anki (TSV export):
          </label>
          <input id="ankiImport" type="file" accept=".txt,.tsv,.csv" />
          <button id="ankiImportHelpBtn" class="secondary small" type="button">How?</button>
          <span id="ankiImportStatus" style="font-size:0.8rem;color:#9ca3af;margin-left:0.5rem;"></span>
        </div>
      </div>

      <!-- Study options -->
      <div class="card">
        <h3>Study Options</h3>
        <div>
          <label class="inline">
            <input type="checkbox" id="skipInstructionsAfterFirst" checked />
            Skip detailed difficulty instructions after first card
          </label>
        </div>
        <!-- Automatic mode -->
        <div>
          <label class="inline">
            <input type="checkbox" id="autoGoodToggle" />
            Can't give voice commands? Enable automatic mode so each card is assigned
            <select id="autoRatingSelect" style="width:auto;min-width:120px;">
              <option value="again">Again</option>
              <option value="hard">Hard</option>
              <option value="good" selected>Good</option>
              <option value="easy">Easy</option>
              <option value="tomorrow">Show again tomorrow</option>
            </select>
            rating automatically
            <span class="badge">New</span>
          </label>
        </div>
                <!-- NEW: auto study-ahead options -->
        <div style="margin-top:0.5rem;">
          <label class="inline">
            <input type="checkbox" id="autoEnterStudyAhead" />
            After I finish all due cards, automatically enter study-ahead mode
          </label>
        </div>
        <div>
          <label class="inline">
            <input type="checkbox" id="loopStudyAhead" />
            In study-ahead mode, keep looping the deck automatically
          </label>
        </div>
        <div style="margin-top:0.5rem;">
          <strong>Hands-free answer behavior:</strong>
          <div class="row" style="margin-top:0.25rem;">
            <div class="inline">
              <input type="radio" name="answerMode" id="answerModeDelay" value="delay" checked />
              <label for="answerModeDelay">Wait</label>
              <input type="number" id="answerDelaySeconds" min="1" max="60" value="4" style="width:60px;" />
              <span>seconds before answer</span>
            </div>
            <div class="inline">
              <input type="radio" name="answerMode" id="answerModeVoice" value="voice" />
              <label for="answerModeVoice">Play answer after I speak</label>
            </div>
          </div>
        </div>
        <!-- NEW: study-ahead answer gap control -->
        <div style="margin-top:0.5rem;">
          <label class="inline" for="studyAheadGapSeconds">
            Study-ahead: delay after answer before next question
          </label>
          <input type="number" id="studyAheadGapSeconds" min="1" max="60" value="4" style="width:60px;" />
          <span>seconds</span>
        </div>
      </div>

      <!-- NEW: Audio & Voice Settings (collapsible section) -->
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;">
          <h3>Audio &amp; Voice Settings</h3>
          <div style="flex:0 0 auto;text-align:right;">
            <button id="toggleAudioSettingsBtn" class="secondary small" type="button">Show</button>
          </div>
        </div>
        <div id="audioSettingsPanel" class="hidden" style="margin-top:0.5rem;">
          <div>
            <label for="ttsRateInput">
              TTS speed (0.5 = slower, 1.0 = normal, 2.0 = faster)
            </label>
            <input
              type="number"
              id="ttsRateInput"
              min="0.5"
              max="2"
              step="0.1"
              value="1.0"
            />
          </div>

          <div style="margin-top:0.5rem;">
  <label for="answerDelayAfterSpeechSecInput">
    Answer delay after I stop speaking (seconds)
    <br />
    <small style="opacity:0.7;">
      0 = instant (default). Any speech resets the timer.
    </small>
  </label>
  <input
    type="number"
    id="answerDelayAfterSpeechSecInput"
    min="0"
    max="30"
    step="1"
    value="0"
  />
</div>

          <div style="margin-top:0.5rem;">
            <label for="ttsVolumeInput">
              TTS volume (0 = mute, 1 = max)
            </label>
            <input
              type="number"
              id="ttsVolumeInput"
              min="0"
              max="1"
              step="0.05"
              value="1.0"
            />
          </div>
        </div>
      </div>

      <!-- Study mode buttons -->
      <div class="card">
        <h3>Start Studying</h3>
        <div class="row">
          <button id="startVoiceBtn">Start Hands-Free Study</button>
          <button id="startSilentBtn" class="secondary">Start Silent Study</button>
        </div>

        <button id="openInstructionsBtn" class="secondary small" type="button">
  Instructions / Voice Commands
</button>

        <p style="font-size:0.85rem;color:#9ca3af;margin-top:0.5rem;">
          Voice commands (hands-free): "again", "hard", "good", "easy", "go to the next card",
          "repeat question", "repeat answer", "pause study session",
          "resume study session", "go to the main menu", "mute microphone".
        </p>
      </div>
    </div>

    <!-- ========== STUDY SECTION ========== -->
    <div id="studySection" class="card hidden">
      <div class="row" style="justify-content:space-between;">
        <h2 style="margin:0;">
  Study Session
  <span id="modeBadge" class="badge"></span>
  <span id="deckBadge" class="badge" style="margin-left:0.5rem;"></span>
</h2>
        <div>
            <button id="studyAddCardBtn" class="secondary small">Add Card</button>
          <button id="backToMenuBtn" class="secondary small">Main Menu</button>
          <button id="pauseBtn" class="secondary small">Pause</button>
          <button id="resumeBtn" class="secondary small" disabled>Resume</button>
          <button id="studyInstructionsBtn" class="secondary small">Instructions</button>
        </div>
      </div>
      <div id="status"></div>

      <!-- Voice mode UI (visual front/back during hands-free) -->
      <div id="voiceUI" class="hidden">
        <div id="voiceQuestion">
          <strong>Question:</strong> <span id="voiceQuestionText"></span>
        </div>
        <div id="voiceAnswer" class="hidden">
          <strong>Answer:</strong> <span id="voiceAnswerText"></span>
        </div>
        <div id="micMuteTimer" class="hidden" style="margin-top:0.5rem;">
  <span class="badge">
    Mic muted: <span id="micMuteSeconds">0</span>s
  </span>
</div>

        <!-- Inline edit for voice mode -->
        <div style="margin-top:0.5rem;">
          <button id="voiceEditToggleBtn" class="secondary small">Edit Card</button>
        </div>
        <div id="voiceEditPanel" class="hidden" style="margin-top:0.75rem;">
          <label for="voiceEditQuestion">Edit question:</label>
          <textarea id="voiceEditQuestion"></textarea>
          <label for="voiceEditAnswer">Edit answer:</label>
          <textarea id="voiceEditAnswer"></textarea>
          <div style="margin-top:0.5rem;">
            <button id="voiceSaveEditBtn">Save</button>
            <button id="voiceCancelEditBtn" class="secondary">Cancel</button>
          </div>
        </div>
                <!-- Rating buttons for hands-free mode (optional tap) -->
        <div id="voiceRatingButtons" class="hidden" style="margin-top:0.5rem;">
          <span>How was that?</span><br />
          <button data-voice-rating="again">Again</button>
          <button data-voice-rating="hard">Hard</button>
          <button data-voice-rating="good">Good</button>
          <button data-voice-rating="easy">Easy</button>
        </div>
      </div> <!-- end of #voiceUI -->

      <!-- Silent mode UI -->
      <div id="silentUI" class="hidden">
        <div id="silentQuestion">
          <strong>Question:</strong> <span id="silentQuestionText"></span>
        </div>
        <div id="silentAnswer" class="hidden">
          <strong>Answer:</strong> <span id="silentAnswerText"></span>
        </div>

        <!-- Inline edit for silent mode -->
        <div style="margin-top:0.5rem;">
          <button id="silentEditToggleBtn" class="secondary small">Edit Card</button>
        </div>
        <div id="silentEditPanel" class="hidden" style="margin-top:0.75rem;">
          <label for="silentEditQuestion">Edit question:</label>
          <textarea id="silentEditQuestion"></textarea>
          <label for="silentEditAnswer">Edit answer:</label>
          <textarea id="silentEditAnswer"></textarea>
          <div style="margin-top:0.5rem;">
            <button id="silentSaveEditBtn">Save</button>
            <button id="silentCancelEditBtn" class="secondary">Cancel</button>
          </div>
        </div>

        <div style="margin-top:0.75rem;">
          <button id="showAnswerBtn">Show Answer</button>
          <!-- next card button for silent study-ahead -->
          <button id="silentNextCardBtn" class="secondary hidden">Next Card</button>
        </div>
        <div id="silentRatingButtons" class="hidden" style="margin-top:0.5rem;">
  <span>How was that?</span>

  <div class="ratingRow">
    <div class="ratingItem">
      <button data-rating="again">Again</button>
      <span id="hint-again" class="dueHint"></span>
    </div>

    <div class="ratingItem">
      <button data-rating="hard">Hard</button>
      <span id="hint-hard" class="dueHint"></span>
    </div>

    <div class="ratingItem">
      <button data-rating="good">Good</button>
      <span id="hint-good" class="dueHint"></span>
    </div>

    <div class="ratingItem">
      <button data-rating="easy">Easy</button>
      <span id="hint-easy" class="dueHint"></span>
    </div>
  </div>
</div>
        <!-- Completion controls for silent mode -->
        <div id="silentCompletionControls" class="hidden" style="margin-top:0.75rem;">
          <button id="silentMainMenuBtn">Main Menu</button>
          <button id="silentStudyAheadBtn" class="secondary">Study Ahead in this Deck</button>
        </div>
      </div>
    </div>
  </div>
<!-- ===== Add Card Modal (during study) ===== -->
<div id="addCardModal" class="modal hidden" aria-hidden="true">
  <div class="modalBackdrop"></div>

  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="addCardModalTitle">
    <div class="row" style="justify-content:space-between;align-items:center;">
      <h3 id="addCardModalTitle" style="margin:0;">Add a card to this deck</h3>
      <button id="addCardModalCloseBtn" class="secondary small" type="button">Close</button>
    </div>

    <div style="margin-top:0.75rem;">
      <label for="addCardModalQuestion">Question</label>
      <textarea id="addCardModalQuestion" placeholder="Enter question"></textarea>
    </div>

    <div style="margin-top:0.75rem;">
      <label for="addCardModalAnswer">Answer</label>
      <textarea id="addCardModalAnswer" placeholder="Enter answer"></textarea>
    </div>

    <div class="row" style="margin-top:0.75rem;">
      <button id="addCardModalSaveBtn" type="button">Save Card</button>
      <button id="addCardModalCancelBtn" class="secondary" type="button">Cancel</button>
      <span id="addCardModalStatus" style="font-size:0.85rem;color:#9ca3af;"></span>
    </div>
  </div>
</div>

<!-- ===== Instructions Modal ===== -->
<div id="instructionsModal" class="modal hidden" aria-hidden="true">
  <div class="modalBackdrop"></div>

  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="instructionsModalTitle">
    <div class="row" style="justify-content:space-between;align-items:center;">
      <h3 id="instructionsModalTitle" style="margin:0;">How ZenCards Works</h3>
      <button id="instructionsCloseBtn" class="secondary small" type="button">Close</button>
    </div>

    <div style="margin-top:0.75rem;max-height:70vh;overflow:auto;">

      <h3>üìä Ratings (Again / Hard / Good / Easy)</h3>
      <p style="color:#9ca3af;margin-top:0.25rem;">
        Ratings decide when you‚Äôll see the card again. ‚ÄúAgain‚Äù brings it back soonest, ‚ÄúEasy‚Äù pushes it out the farthest.
      </p>
      <ul style="margin-top:0.5rem;">
        <li><strong>Again</strong> ‚Äî you didn‚Äôt remember it (restarts the learning ladder).</li>
        <li><strong>Hard</strong> ‚Äî you remembered, but it was tough (slower progress).</li>
        <li><strong>Good</strong> ‚Äî you remembered normally (standard progress).</li>
        <li><strong>Easy</strong> ‚Äî you remembered instantly (faster progress).</li>
      </ul>

      <hr style="border:0;border-top:1px solid #111827;margin:1rem 0;" />

      <h3>üé§ When to say voice commands</h3>
      <ul>
        <li><strong>After the question</strong>: you can say <em>repeat question</em> or <em>go to next card</em>.</li>
        <li><strong>After the answer</strong>: say your rating (<em>again / hard / good / easy</em>).</li>
        <li><strong>Any time</strong>: <em>pause study session</em>, <em>resume study session</em>, <em>go to the main menu</em>.</li>
      </ul>

      <hr style="border:0;border-top:1px solid #111827;margin:1rem 0;" />

      <h3>‚û°Ô∏è Next Card</h3>
      <p style="color:#9ca3af;margin-top:0.25rem;">
        Say <strong>‚Äúgo to next card‚Äù</strong> to skip the current card and immediately move forward.
      </p>

      <hr style="border:0;border-top:1px solid #111827;margin:1rem 0;" />

      <h3>üîá Mute Microphone (Hands-Free mode)</h3>
      <p style="color:#9ca3af;margin-top:0.25rem;">
        If you need time to think or you‚Äôre in a noisy place, you can temporarily stop listening.
      </p>
      <ul>
        <li>Say <strong>‚Äúmute microphone‚Äù</strong></li>
        <li>Then say a duration: <strong>10 / 20 / 30 / 40 / 50 / 60</strong> seconds</li>
        <li>While muted, ZenCards will not process commands until the timer ends.</li>
      </ul>

      <hr style="border:0;border-top:1px solid #111827;margin:1rem 0;" />

      <h3>üó£Ô∏è Full voice command list</h3>
      <ul>
        <li><strong>again</strong>, <strong>hard</strong>, <strong>good</strong>, <strong>easy</strong> ‚Äî rate the card</li>
        <li><strong>go to next card</strong> ‚Äî skip ahead</li>
        <li><strong>repeat question</strong></li>
        <li><strong>repeat answer</strong></li>
        <li><strong>pause study session</strong></li>
        <li><strong>resume study session</strong></li>
        <li><strong>go to the main menu</strong></li>
        <li><strong>mute microphone</strong> (then say: 10/20/30/40/50/60)</li>
      </ul>

    </div>
  </div>
</div>

  <script>
    // ===================== SUPABASE CONFIG =====================
const SUPABASE_URL = "https://elpfcnnrripftxoqeckv.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVscGZjbm5ycmlwZnR4b3FlY2t2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4NTk5MzQsImV4cCI6MjA4MDQzNTkzNH0.uiLHVcRfMXu0V7QRW41TARMIy-Hbhovc4h9uYFzzGLQ";
    const { createClient } = window.supabase;
    const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    storage: window.localStorage,
    storageKey: "zencards-auth",
  },
});

window.supabaseClient = supabaseClient;
window.setSyncLock = window.setSyncLock || function () {};
window.lockUI = window.lockUI || function () {};

let currentUser = null;
let isSigningOut = false;
async function signOutFromApp() {
  if (isSigningOut) return;
  isSigningOut = true;

  try {
    console.log("[LOGOUT] signing out...");

    // Stop any study audio/listening
    try { stopAllAudio(); } catch (_) {}

    // Supabase sign out
    await supabaseClient.auth.signOut();

    // Clear ONLY your app‚Äôs local state (not everything)
    localStorage.removeItem("srsDecks");
    localStorage.removeItem("srsSchedule");

    // Clear Supabase session storage key
    localStorage.removeItem("zencards-auth");

    currentUser = null;
    hasLoadedRemote = false;
    pendingSaveBeforeRemote = false;

    console.log("[LOGOUT] done, redirecting to index.html");
    window.location.replace("index.html");
  } catch (e) {
    console.error("[LOGOUT] failed:", e);
    alert("Logout failed. Check console.");
  } finally {
    isSigningOut = false;
  }
}



// ===== AUTH DOM REFERENCES =====
const deckBadge = document.getElementById("deckBadge");
// ===== AUTH UI refs =====
const authLoggedIn = document.getElementById("authLoggedIn");
const userEmailLabel = document.getElementById("userEmailLabel");
const signOutBtn = document.getElementById("logOutBtn");

// Optional buttons (keep if you use them)
const manageBillingBtn = document.getElementById("manageBillingBtn");
const resetPasswordLoggedInBtn = document.getElementById("resetPasswordLoggedInBtn");


const studyAddCardBtn = document.getElementById("studyAddCardBtn");
const addCardModal = document.getElementById("addCardModal");
const addCardModalCloseBtn = document.getElementById("addCardModalCloseBtn");
const addCardModalCancelBtn = document.getElementById("addCardModalCancelBtn");
const addCardModalSaveBtn = document.getElementById("addCardModalSaveBtn");
const addCardModalQuestion = document.getElementById("addCardModalQuestion");
const addCardModalAnswer = document.getElementById("addCardModalAnswer");
const addCardModalStatus = document.getElementById("addCardModalStatus");
// ===== Instructions modal refs =====
const openInstructionsBtn = document.getElementById("openInstructionsBtn");
const instructionsModal = document.getElementById("instructionsModal");
const instructionsCloseBtn = document.getElementById("instructionsCloseBtn");

// ===== BUTTON EVENT HOOKS =====

if (signOutBtn) {
  signOutBtn.addEventListener("click", () => {
    signOutFromApp();
  });
}
// ===================== BILLING (STRIPE PORTAL) =====================

// Helper: returns a good redirect base for GitHub Pages + local
function getBaseUrlForSameFolder() {
  // app.html, reset.html, etc are in the same folder
  return new URL(".", window.location.href).href; // ends with trailing slash
}

async function openStripeCustomerPortal() {
  try {
    // Make sure we have a session token to authorize the edge function
    const { data: sessionData, error: sessErr } = await supabaseClient.auth.getSession();
    if (sessErr) throw sessErr;

    const session = sessionData?.session;
    if (!session?.access_token) {
      alert("No active session. Please log in again.");
      window.location.replace("index.html");
      return;
    }

    // Call your edge function: create-portal-link
    const fnUrl = `${SUPABASE_URL}/functions/v1/create-portal-link`;

    const res = await fetch(fnUrl, {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "apikey": SUPABASE_ANON_KEY,
    Authorization: `Bearer ${session.access_token}`,
  },
  body: JSON.stringify({
    return_url: getBaseUrlForSameFolder() + "app.html",
  }),
});

    const json = await res.json().catch(() => ({}));

    if (!res.ok) {
      console.error("[PORTAL] Edge function error:", json);
      alert("Could not open billing portal. Check console.");
      return;
    }

    const url = json?.url;
    if (!url) {
      console.error("[PORTAL] No url returned:", json);
      alert("Billing portal link not returned. Check console.");
      return;
    }

    // Redirect to Stripe portal
    window.location.assign(url);
  } catch (e) {
    console.error("[PORTAL] Failed:", e);
    alert("Could not open billing portal. Check console.");
  }
}

// Hook up the button
if (manageBillingBtn) {
  manageBillingBtn.addEventListener("click", openStripeCustomerPortal);
}


    // ===================== DATA & STORAGE =====================
    let decks = [];
    // schedule[deckId_cardId] = {
    //   phase: "ladder" | "mature1" | "mature2",
    //   level: 1..5 (only for ladder),
    //   intervalMinutes: number,
    //   timesGraduated: number,
    //   dueTime: ms since epoch
    // }
    let schedule = {};
    let hasLoadedRemote = false;

function getCurrentState() {
  return {
    decks,
    schedule,
  };
}

    const MINUTES_PER_DAY = 1440;
    const LADDER_LEVEL_MINUTES = {
      1: 5,                 // level 1: ~5 minutes
      2: 10,                // level 2: 10 minutes
      3: 1 * MINUTES_PER_DAY,   // 1 day
      4: 3 * MINUTES_PER_DAY,   // 3 days
      5: 7 * MINUTES_PER_DAY    // 7 days
    };

    // threshold for "show again in this session" behavior
    const SHORT_REVIEW_THRESHOLD_MINUTES = 10;

    function loadFromStorage() {
  try {
    const d = localStorage.getItem("srsDecks");
    decks = d ? JSON.parse(d) : [];
  } catch (_) {
    decks = [];
  }
  if (!Array.isArray(decks)) decks = [];

  try {
    const s = localStorage.getItem("srsSchedule");
    schedule = s ? JSON.parse(s) : {};
  } catch (_) {
    schedule = {};
  }
  if (typeof schedule !== "object" || schedule === null) schedule = {};

  // ‚úÖ Only create sample deck if NOT logged in
  if (decks.length === 0 && !currentUser) {
    decks = [{
      id: "deck1",
      name: "Sample Deck",
      cards: [
        { id: "c1", question: "What does DOMS stand for?", answer: "Delayed onset muscle soreness." },
        { id: "c2", question: "In a dumbbell incline press, what area of the chest is emphasized?", answer: "The upper chest, especially the clavicular head of the pectoralis major." }
      ]
    }];
  }
}

// ===================== SUPABASE SAVE QUEUE (prevents overlaps) =====================
let saveInFlight = false;
let saveQueued = false;
let pendingSaveBeforeRemote = false;

async function queueSaveToSupabase() {
  if (!currentUser) {
  pendingSaveBeforeRemote = true;
  console.warn("[QUEUE] No currentUser yet; deferring save");
  return;
}
  console.log("[QUEUE] queueSaveToSupabase() hit", {
    hasLoadedRemote,
    saveInFlight,
    saveQueued
  });

  try {
    // If remote hasn't loaded yet, allow a write ONLY if user exists
    if (!hasLoadedRemote) {
      const { data: u, error: userErr } = await supabaseClient.auth.getUser();

      console.log("[QUEUE] hasLoadedRemote=false; getUser check:", {
        userErr: userErr ? { message: userErr.message, name: userErr.name } : null,
        hasUser: !!u?.user,
        userId: u?.user?.id || null
      });

      if (userErr) {
        console.error("‚ùå [QUEUE] getUser error (this is why saves stop):", userErr);
        pendingSaveBeforeRemote = true;
        return;
      }

      if (!u?.user) {
        pendingSaveBeforeRemote = true;
        console.warn("‚è≥ [QUEUE] Deferring save until remote is loaded (no user yet)");
        return;
      }

      console.warn("‚úÖ [QUEUE] User exists; allowing save before remote load");
    }

    if (saveInFlight) {
      saveQueued = true;
      console.log("[QUEUE] saveInFlight=true -> queued next save");
      return;
    }

    saveInFlight = true;

    const res = await saveStateToSupabase();
    console.log("[QUEUE] saveStateToSupabase result:", res);
  } catch (e) {
    console.error("‚ùå [QUEUE] queueSaveToSupabase crashed:", e);
  } finally {
    saveInFlight = false;

    if (saveQueued) {
      saveQueued = false;
      console.log("[QUEUE] running queued save now‚Ä¶");
      // important: await so errors don‚Äôt get swallowed again
      await queueSaveToSupabase();
    }
  }
}


  function saveDecks() {
  console.log("üíæ saveDecks() firing. decks.length =", decks.length);

  localStorage.setItem("srsDecks", JSON.stringify(decks));

  // THIS is the critical wiring line:
 queueSaveToSupabase().catch(e => console.error("‚ùå queueSaveToSupabase rejected:", e));
}


function saveSchedule() {
  console.log("üü© saveSchedule() firing. schedule keys =", Object.keys(schedule || {}).length);
  localStorage.setItem("srsSchedule", JSON.stringify(schedule));

  queueSaveToSupabase().catch(e => console.error("‚ùå queueSaveToSupabase rejected:", e));
}

// ===================== SUPABASE SYNC HELPERS =====================
async function saveStateToSupabase() {
  console.log("[SAVE] called", new Date().toISOString(), {
    hasLoadedRemote,
    decksLen: Array.isArray(decks) ? decks.length : null,
    hasSchedule: !!schedule
  });

  try {
    // MUST have a logged-in user
    const { data: userData, error: userErr } = await supabaseClient.auth.getUser();

    console.log("[SAVE] getUser()", {
      userErr: userErr
        ? { message: userErr.message, name: userErr.name, status: userErr.status }
        : null,
      userId: userData?.user?.id || null,
      email: userData?.user?.email || null
    });

    if (userErr) {
      console.error("[SAVE] getUser error:", userErr);
      return { ok: false, step: "getUser", error: userErr };
    }

    const user = userData?.user;
    if (!user) {
      console.warn("[SAVE] No user ‚Äî skipping Supabase save");
      return { ok: false, step: "no_user" };
    }

    const payload = {
      user_id: user.id,
      state_json: { decks, schedule },
      updated_at: new Date().toISOString()
    };

    console.log("[SAVE] about to upsert payload", {
      table: "zencards_state",
      user_id: payload.user_id,
      stateSize: JSON.stringify(payload.state_json || {}).length
    });

    const { data, error, status } = await supabaseClient
      .from("zencards_state")
      .upsert(payload, { onConflict: "user_id" });

    console.log("[SAVE] upsert response", {
      status,
      error: error
        ? { message: error.message, code: error.code, details: error.details, hint: error.hint }
        : null,
      data
    });

    if (error) {
      console.error("[SAVE] Supabase save failed:", error);
      if (typeof setAuthStatus === "function") {
        setAuthStatus("Supabase save failed: " + (error.message || "unknown"));
      }
      return { ok: false, step: "upsert", error };
    }

    console.log("‚úÖ [SAVE] Supabase save OK");
    return { ok: true, status, data };
  } catch (e) {
    console.error("[SAVE] crashed:", e);
    return { ok: false, step: "crash", error: e };
  }
}

async function loadStateFromSupabase() {
  console.log("‚úÖ loadStateFromSupabase called");

  console.log("üì• loadStateFromSupabase() start");

  try {
    // Make sure token is fresh
    try { await supabaseClient.auth.refreshSession(); } catch (_) {}

    // Get user
    const { data: userData, error: userErr } = await supabaseClient.auth.getUser();
    const user = userData?.user;

    console.log("üü¶ loadStateFromSupabase getUser()", { user, userErr });

    // ‚úÖ If no user, we still "unlock" in finally.
    if (!user) {
      console.warn("üü® No user in loadStateFromSupabase(). Skipping remote load.");
      return;
    }

    // Load row
    const { data, error } = await supabaseClient
      .from("zencards_state")
      .select("state_json, updated_at")
      .eq("user_id", user.id)
      .maybeSingle();

    if (error) {
      console.error("üü• Supabase load error:", error);
      setAuthStatus("Supabase load error: " + (error.message || "unknown"));
      return;
    }

    console.log("üü¶ Supabase load row:", data);

    // ‚úÖ FIRST-TIME USER CASE: no row yet
    if (!data?.state_json) {
      console.log("üü® No remote state yet; creating from local‚Ä¶");
      await queueSaveToSupabase();     // create their row via queue/locking
return;                        // ‚úÖ still safe because finally runs
    }

    // Apply remote -> memory
    const remote = data.state_json;

    if (Array.isArray(remote.decks)) decks = remote.decks;
    if (remote.schedule && typeof remote.schedule === "object") schedule = remote.schedule;

    // Persist remote -> local
    localStorage.setItem("srsDecks", JSON.stringify(decks));
    localStorage.setItem("srsSchedule", JSON.stringify(schedule));

    console.log("‚úÖ Loaded remote state into app + localStorage");
  } catch (e) {
    console.error("‚ùå loadStateFromSupabase crashed:", e);
  } finally {
    // ‚úÖ CRITICAL: ALWAYS release the gate so saves can proceed
    hasLoadedRemote = true;
    console.log("‚úÖ hasLoadedRemote = true");

    setSyncLock(false); // unlock UI if you use this lock

    // ‚úÖ CRITICAL: flush any deferred save that happened before remote loaded
    if (pendingSaveBeforeRemote) {
      pendingSaveBeforeRemote = false;
      console.log("‚è© Flushing deferred save now that remote is loaded/checked");
     queueSaveToSupabase().catch(e => console.error("‚ùå queueSaveToSupabase rejected:", e));
    }
  }
}
initAppSession().catch(e => console.error("‚ùå initAppSession crashed:", e));
async function initAppSession() {
  console.log("[BOOT] initAppSession()");

  // 1) Check session first (fast)
  const { data: sessionData, error: sessErr } = await supabaseClient.auth.getSession();
  const session = sessionData?.session || null;

  console.log("[BOOT] getSession()", {
    hasSession: !!session,
    sessErr: sessErr ? { message: sessErr.message, name: sessErr.name } : null
  });

  // 2) If no session ‚Üí go back to landing/login page
  if (!session) {
    console.warn("[BOOT] No session. Redirecting to index.html");
    window.location.replace("index.html");
    return;
  }

  // 3) Set currentUser + show UI
  currentUser = session.user;

  if (userEmailLabel) userEmailLabel.textContent = currentUser.email || "";
  if (authLoggedIn) authLoggedIn.classList.remove("hidden");

  // 4) Load local immediately so app feels instant
  loadFromStorage();
  refreshDeckSelect();
  refreshCardsList();

  // 5) Load remote once (this will set hasLoadedRemote=true in finally)
  await loadStateFromSupabase();

  // 6) After remote load, re-render (remote may overwrite local)
  refreshDeckSelect();
  refreshCardsList();

  console.log("[BOOT] done", { hasLoadedRemote, userId: currentUser?.id });
}

    function scheduleKey(deckId, cardId) {
      return `${deckId}_${cardId}`;
    }

    // NEW: simple Fisher-Yates shuffle helper (returns a new array)
    function shuffleArray(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
      }
      return a;
    }

    // Normalize old/new schedule entries into our new shape
    function normalizeScheduleEntry(raw) {
      const now = Date.now();
      if (!raw || typeof raw !== "object") {
        return {
          phase: "ladder",
          level: 1,
          intervalMinutes: LADDER_LEVEL_MINUTES[1],
          timesGraduated: 0,
          dueTime: now
        };
      }
      let phase = raw.phase || "ladder";
      let level = typeof raw.level === "number" ? raw.level : 1;
      let timesGraduated =
        typeof raw.timesGraduated === "number" ? raw.timesGraduated : 0;
      let intervalMinutes =
        typeof raw.intervalMinutes === "number" && raw.intervalMinutes > 0
          ? raw.intervalMinutes
          : (LADDER_LEVEL_MINUTES[level] || LADDER_LEVEL_MINUTES[1]);

      let dueTime;
      if (typeof raw.dueTime === "number") {
        dueTime = raw.dueTime;
      } else if (raw.dueDate) {
        const t = Date.parse(raw.dueDate);
        dueTime = isNaN(t) ? now : t;
      } else {
        dueTime = now;
      }

      return { phase, level, intervalMinutes, timesGraduated, dueTime };
    }

    // Core scheduling logic implementing your rules
    function computeNextState(entry, ratingKey) {
      const s = normalizeScheduleEntry(entry);
      const result = { ...s };

      // "again" always: reset to level 1, ladder, 5 minutes
      if (ratingKey === "again") {
        result.phase = "ladder";
        result.level = 1;
        result.intervalMinutes = LADDER_LEVEL_MINUTES[1];
        // keep timesGraduated so we know if it was ever mature before
        return result;
      }

      // Ladder phase: 5 levels
      if (s.phase === "ladder") {
        let lvl = s.level || 1;

        if (ratingKey === "hard") {
          // Stay on same level, same interval as that level
          result.level = lvl;
          result.intervalMinutes = LADDER_LEVEL_MINUTES[lvl];
          return result;
        }

        if (ratingKey === "good" || ratingKey === "easy") {
          const jump = ratingKey === "good" ? 1 : 2;
          let target = lvl + jump;

          // Still within ladder (1‚Äì5)
          if (target <= 5) {
            result.level = target;
            result.intervalMinutes = LADDER_LEVEL_MINUTES[target];
            return result;
          }

          // We are "past level 5" -> enter mature phase
          const prevInterval = LADDER_LEVEL_MINUTES[lvl];
          const alreadyGraduated = (s.timesGraduated || 0) > 0;

          result.level = 0;
          result.phase = alreadyGraduated ? "mature2" : "mature1";
          result.timesGraduated = (s.timesGraduated || 0) + 1;

          if (result.phase === "mature1") {
            // First time past level 5:
            // hard: 1x, good: 1.75x, easy: 2.5x
            if (ratingKey === "good") {
              result.intervalMinutes = prevInterval * 1.75;
            } else {
              // easy from level 5 into mature1
              result.intervalMinutes = prevInterval * 2.5;
            }
          } else {
            // mature2 = after you've already been mature before,
            // passed through the ladder again and gone past level 5:
            // hard: 1.2x, good: 2x, easy: 2.5x
            const base = prevInterval;
            if (ratingKey === "hard") {
              result.intervalMinutes = base * 1.2;
            } else if (ratingKey === "good") {
              result.intervalMinutes = base * 2.0;
            } else {
              result.intervalMinutes = base * 2.5;
            }
          }

          return result;
        }
      }

      // Mature phases
      const base = s.intervalMinutes || MINUTES_PER_DAY;

      if (s.phase === "mature1") {
        // First mature phase: hard=1x, good=1.75x, easy=2.5x
        if (ratingKey === "hard") {
          result.intervalMinutes = base * 1.0;
        } else if (ratingKey === "good") {
          result.intervalMinutes = base * 1.75;
        } else if (ratingKey === "easy") {
          result.intervalMinutes = base * 2.5;
        }
        return result;
      }

      if (s.phase === "mature2") {
        // Second+ mature phase: hard=1.2x, good=2x, easy=2.5x
        if (ratingKey === "hard") {
          result.intervalMinutes = base * 1.2;
        } else if (ratingKey === "good") {
          result.intervalMinutes = base * 2.0;
        } else if (ratingKey === "easy") {
          result.intervalMinutes = base * 2.5;
        }
        return result;
      }

      // Fallback: keep same interval
      return result;
    }

    // Apply scheduling (mutates global schedule) ‚Äî now returns the new entry
    function applyAnkiScheduling(deckId, cardId, ratingKey) {
      const key = scheduleKey(deckId, cardId);
      const existing = schedule[key] || {};
      const nextState = computeNextState(existing, ratingKey);
      const now = Date.now();
      nextState.dueTime = now + nextState.intervalMinutes * 60000;
      schedule[key] = nextState;
      saveSchedule();
      // Update deck dropdown counts when schedule changes
      refreshDeckSelect();
      return nextState;
    }

    // NEW: apply "show again tomorrow" behavior for automatic mode
    function applyTomorrowScheduling(deckId, cardId) {
      const key = scheduleKey(deckId, cardId);
      const existing = normalizeScheduleEntry(schedule[key] || {});
      const now = Date.now();
      const nextState = { ...existing };
      // Keep phase/level/interval the same, just snooze dueTime by 1 day
      nextState.dueTime = now + MINUTES_PER_DAY * 60000;
      schedule[key] = nextState;
      saveSchedule();
      refreshDeckSelect();
      return nextState;
    }

    // Preview next interval (in minutes) without changing schedule
    function previewIntervalMinutes(deckId, cardId, ratingKey) {
      const key = scheduleKey(deckId, cardId);
      const existing = schedule[key] || {};
      const nextState = computeNextState(existing, ratingKey);

      const minutes =
        typeof nextState.intervalMinutes === "number" && nextState.intervalMinutes > 0
          ? nextState.intervalMinutes
          : LADDER_LEVEL_MINUTES[1]; // default to 5 minutes

      return minutes;
    }

    // ===================== DECK & CARD UI =====================
    const deckSelect = document.getElementById("deckSelect");
    const newDeckNameInput = document.getElementById("newDeckName");
    const addDeckBtn = document.getElementById("addDeckBtn");
    const deleteDeckBtn = document.getElementById("deleteDeckBtn");

    // Disable/enable Add Deck button based on input
function updateAddDeckButtonState() {
  const name = (newDeckNameInput?.value || "").trim();
  if (addDeckBtn) addDeckBtn.disabled = name.length === 0;
}

// Run once on load
updateAddDeckButtonState();

// Update live while typing
if (newDeckNameInput) {
  newDeckNameInput.addEventListener("input", updateAddDeckButtonState);
}

    const cardQuestionInput = document.getElementById("cardQuestion");
    const cardAnswerInput = document.getElementById("cardAnswer");
    const addCardBtn = document.getElementById("addCardBtn");
    const updateCardBtn = document.getElementById("updateCardBtn");
    const cardsListDiv = document.getElementById("cardsList");
    const selectedCardInfo = document.getElementById("selectedCardInfo");
    // ===== Move card UI =====
const moveDeckSelect = document.getElementById("moveDeckSelect");
const moveCardBtn = document.getElementById("moveCardBtn");

function refreshMoveDeckSelect() {
  if (!moveDeckSelect) return;
  moveDeckSelect.innerHTML = "";

  decks.forEach(deck => {
    const opt = document.createElement("option");
    opt.value = deck.id;
    opt.textContent = deck.name;
    moveDeckSelect.appendChild(opt);
  });

  // Default to current deck (or first deck)
  if (selectedDeckId) moveDeckSelect.value = selectedDeckId;

  // Enable button only when a card is selected and there's at least 1 other deck
  const hasOtherDeck =
    decks.filter(d => d.id !== selectedDeckId).length > 0;

  if (moveCardBtn) {
    moveCardBtn.disabled = !selectedCardId || !hasOtherDeck;
  }
}

    // ================= IMAGE INSERT HELPERS =================
function insertImageTagInto(textarea, imgSrc) {
  if (!textarea || !imgSrc) return;

  const tag = `\n<img src="${imgSrc}" alt="" style="max-width:100%;height:auto;" />\n`;

  const start = textarea.selectionStart ?? textarea.value.length;
  const end   = textarea.selectionEnd ?? textarea.value.length;

  textarea.value =
    textarea.value.slice(0, start) +
    tag +
    textarea.value.slice(end);

  textarea.focus();
  const pos = start + tag.length;
  textarea.selectionStart = textarea.selectionEnd = pos;
}

// Allow dragging & dropping images directly onto a textarea
function makeTextareaAcceptImageDrops(textarea) {
  if (!textarea) return;

  textarea.addEventListener("dragover", (e) => {
    e.preventDefault();
    textarea.classList.add("drag-hover");
  });

  textarea.addEventListener("dragenter", (e) => {
    e.preventDefault();
    textarea.classList.add("drag-hover");
  });

  textarea.addEventListener("dragleave", (e) => {
    e.preventDefault();
    textarea.classList.remove("drag-hover");
  });

  textarea.addEventListener("drop", (e) => {
    e.preventDefault();
    textarea.classList.remove("drag-hover");

    const dt = e.dataTransfer;
    if (!dt || !dt.files || dt.files.length === 0) return;

    const file = dt.files[0];
    if (!file.type.startsWith("image/")) return;

    const reader = new FileReader();
    reader.onload = (ev) => {
      insertImageTagInto(textarea, ev.target.result);
    };
    reader.readAsDataURL(file);
  });
}

// Enable drag/drop on the main editor textareas
makeTextareaAcceptImageDrops(cardQuestionInput);
makeTextareaAcceptImageDrops(cardAnswerInput);

// Insert image button: paste URL or pick a file (stored as data: URL)
document.querySelectorAll("[data-insert-image]").forEach(btn => {
  btn.addEventListener("click", () => {
    const targetId = btn.getAttribute("data-target");
    const textarea = document.getElementById(targetId);
    if (!textarea) return;

    const url = prompt(
      "Paste an image URL, or leave blank to choose a file from your device."
    );

    if (url && url.trim()) {
      insertImageTagInto(textarea, url.trim());
      return;
    }

    // If no URL, open a file picker and embed as data URL
    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = "image/*";
    fileInput.onchange = () => {
      const file = fileInput.files && fileInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        insertImageTagInto(textarea, e.target.result); // data:image/...
      };
      reader.readAsDataURL(file);
    };
    fileInput.click();
  });
});

    // NEW: Anki import elements
    const ankiImportInput   = document.getElementById("ankiImport");
    const ankiImportStatus  = document.getElementById("ankiImportStatus");
    const ankiImportHelpBtn = document.getElementById("ankiImportHelpBtn");

    let selectedDeckId = null;
    let selectedCardId = null;

    function getDeckById(id) {
      return decks.find(d => d.id === id) || null;
    }

   // New: compute TOTAL counts per deck (new / learning / review)
// - new: no schedule yet
// - learning: phase === "ladder" (levels 1‚Äì5)
// - review: phase === "mature1" or "mature2" (i.e. past level 5)
function getDeckPhaseCounts(deck) {
  let newCount = 0;
  let learningCount = 0;
  let reviewCount = 0;

  deck.cards.forEach(card => {
    const key = scheduleKey(deck.id, card.id);
    const s = schedule[key];

    // New card: never scheduled
    if (!s) {
      newCount++;
      return;
    }

    const normalized = normalizeScheduleEntry(s);
    const level = typeof normalized.level === "number" ? normalized.level : 1;

    if (normalized.phase === "ladder" && level <= 5) {
      // Learning cards (still in the 5-step ladder)
      learningCount++;
    } else {
      // Anything past the ladder is treated as review
      reviewCount++;
    }
  });

  return { newCount, learningCount, reviewCount };
}

    function refreshDeckSelect() {
  const currentValue = selectedDeckId;
  deckSelect.innerHTML = "";

  decks.forEach(deck => {
    const opt = document.createElement("option");
    opt.value = deck.id;

    const counts = getDeckPhaseCounts(deck);
    // Format: Deck name (new / learning / review)
    opt.textContent = `${deck.name} (${counts.newCount}/${counts.learningCount}/${counts.reviewCount})`;

    deckSelect.appendChild(opt);
  });

  // Preserve previously selected deck if possible
  if (!selectedDeckId && decks.length > 0) {
    selectedDeckId = decks[0].id;
  }

  if (currentValue && decks.some(d => d.id === currentValue)) {
    selectedDeckId = currentValue;
  }

  if (selectedDeckId && decks.some(d => d.id === selectedDeckId)) {
    deckSelect.value = selectedDeckId;
  } else if (decks.length > 0) {
    selectedDeckId = decks[0].id;
    deckSelect.value = selectedDeckId;
  } else {
    selectedDeckId = null;
  }
  refreshMoveDeckSelect();
}
    // Format the next due date for a given card
    function formatDueDate(deckId, cardId) {
      const key = scheduleKey(deckId, cardId);
      const entry = schedule[key];
      if (!entry) {
        // Never scheduled = brand new card
        return "New";
      }

      const normalized = normalizeScheduleEntry(entry);
      const dueMs = normalized.dueTime;
      if (typeof dueMs !== "number") return "New";

      const nowMs = Date.now();
      const due = new Date(dueMs);
      if (Number.isNaN(due.getTime())) return "New";

      const now = new Date();
      const todayStr = now.toDateString();
      const dueStr = due.toDateString();

      if (dueMs <= nowMs) {
        return "Due now";
      }

      // Today later
      if (dueStr === todayStr) {
        return "Today " + due.toLocaleTimeString([], {
          hour: "numeric",
          minute: "2-digit"
        });
      }

      // Otherwise just show date (local)
      return due.toLocaleDateString();
    }

        function refreshCardsList() {
      const deck = getDeckById(selectedDeckId);
      cardsListDiv.innerHTML = "";
      selectedCardId = null;
      selectedCardInfo.textContent = "";
      updateCardBtn.disabled = true;
      if (!deck) return;

      deck.cards.forEach(card => {
        const row = document.createElement("div");
        row.className = "cardRow";

        // Question column
        const questionSpan = document.createElement("span");
        questionSpan.textContent = getPlainTextFromCard(card.question);
        row.appendChild(questionSpan);

        // Due date column
        const dueSpan = document.createElement("span");
        dueSpan.className = "dueDateCell";
        dueSpan.textContent = formatDueDate(selectedDeckId, card.id);
        row.appendChild(dueSpan);

        // Actions column (Edit / Delete)
        const actionsDiv = document.createElement("div");
        actionsDiv.className = "cardActions";

        const editBtn = document.createElement("button");
        editBtn.textContent = "Edit";
        editBtn.className = "secondary small";
        editBtn.addEventListener("click", () => {
          selectedCardId = card.id;
          cardQuestionInput.value = card.question;
          cardAnswerInput.value = card.answer;
          selectedCardInfo.textContent = `Editing card: ${card.id}`;
          updateCardBtn.disabled = false;
          refreshMoveDeckSelect();
        });
        actionsDiv.appendChild(editBtn);

        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "Delete";
        deleteBtn.className = "secondary small";
        deleteBtn.addEventListener("click", () => {
          if (!confirm("Delete this card?")) return;
          const d = getDeckById(selectedDeckId);
          if (!d) return;
          const idx = d.cards.findIndex(c => c.id === card.id);
          if (idx !== -1) {
            d.cards.splice(idx, 1);
          }
          const key = scheduleKey(selectedDeckId, card.id);
          delete schedule[key];
          saveDecks();
          saveSchedule();
          if (selectedCardId === card.id) {
            selectedCardId = null;
            cardQuestionInput.value = "";
            cardAnswerInput.value = "";
            selectedCardInfo.textContent = "";
            updateCardBtn.disabled = true;
          }
          refreshCardsList();
          refreshDeckSelect();
        });
        actionsDiv.appendChild(deleteBtn);

        row.appendChild(actionsDiv);
        cardsListDiv.appendChild(row);
      });
    }

    addDeckBtn.addEventListener("click", () => {
  console.log("‚úÖ Add Deck clicked");

  const raw = newDeckNameInput.value;
  console.log("Deck name raw:", raw);

  if (!raw || !raw.trim()) {
    console.warn("‚ùå No deck name; aborting");
    return;
  }

  const name = raw.trim();
  const id = "deck_" + Date.now();

  console.log("Creating deck:", { id, name });

  decks.push({ id, name, cards: [] });

  console.log("Decks after push:", decks);

  saveDecks();

  console.log("‚úÖ saveDecks() called");

  newDeckNameInput.value = "";
  updateAddDeckButtonState();
  selectedDeckId = id;
  refreshDeckSelect();
  refreshCardsList();
});

    deleteDeckBtn.addEventListener("click", () => {
      if (!selectedDeckId) return;
      const deck = getDeckById(selectedDeckId);
      if (!deck) return;
      if (!confirm(`Delete deck "${deck.name}" and all its cards?`)) return;

      decks = decks.filter(d => d.id !== selectedDeckId);
      saveDecks();

      const prefix = selectedDeckId + "_";
      Object.keys(schedule).forEach(key => {
        if (key.startsWith(prefix)) {
          delete schedule[key];
        }
      });
      saveSchedule();

      if (decks.length > 0) {
        selectedDeckId = decks[0].id;
      } else {
        selectedDeckId = null;
      }
      refreshDeckSelect();
      refreshCardsList();
    });

    deckSelect.addEventListener("change", () => {
      selectedDeckId = deckSelect.value;
      refreshCardsList();
    });

    addCardBtn.addEventListener("click", () => {
      const q = cardQuestionInput.value.trim();
      const a = cardAnswerInput.value.trim();
      if (!q || !a) return;
      const deck = getDeckById(selectedDeckId);
      if (!deck) return;
      const id = "c_" + Date.now();
      deck.cards.push({ id, question: q, answer: a });
      saveDecks();
      cardQuestionInput.value = "";
      cardAnswerInput.value = "";
      selectedCardId = null;
      selectedCardInfo.textContent = "";
      updateCardBtn.disabled = true;
      refreshCardsList();
      refreshDeckSelect();
    });

    updateCardBtn.addEventListener("click", () => {
      if (!selectedCardId) return;
      const q = cardQuestionInput.value.trim();
      const a = cardAnswerInput.value.trim();
      if (!q || !a) return;
      const deck = getDeckById(selectedDeckId);
      if (!deck) return;
      const card = deck.cards.find(c => c.id === selectedCardId);
      if (!card) return;
      card.question = q;
      card.answer = a;
      saveDecks();
      refreshCardsList();
      selectedCardInfo.textContent = `Updated card: ${selectedCardId}`;
    });
    if (moveCardBtn) {
  moveCardBtn.addEventListener("click", () => {
    if (!selectedCardId) return;
    const fromDeckId = selectedDeckId;
    const toDeckId = moveDeckSelect ? moveDeckSelect.value : null;

    if (!fromDeckId || !toDeckId) return;
    if (fromDeckId === toDeckId) return;

    const fromDeck = getDeckById(fromDeckId);
    const toDeck = getDeckById(toDeckId);
    if (!fromDeck || !toDeck) return;

    const idx = fromDeck.cards.findIndex(c => c.id === selectedCardId);
    if (idx === -1) return;

    // Move the card object
    const [movedCard] = fromDeck.cards.splice(idx, 1);
    toDeck.cards.push(movedCard);

    // Move schedule entry (because key includes deckId)
    const oldKey = scheduleKey(fromDeckId, movedCard.id);
    const newKey = scheduleKey(toDeckId, movedCard.id);

    if (schedule[oldKey]) {
      schedule[newKey] = schedule[oldKey];
      delete schedule[oldKey];
      saveSchedule();
    }

    // Persist + reset editor selection
    saveDecks();

    selectedCardId = null;
    cardQuestionInput.value = "";
    cardAnswerInput.value = "";
    selectedCardInfo.textContent = "";
    updateCardBtn.disabled = true;

    refreshCardsList();
    refreshDeckSelect();     // also refreshes move dropdown + counts
  });
}

    // NEW: Anki import help button
    ankiImportHelpBtn.addEventListener("click", () => {
      alert(
        "How to export from Anki:\n\n" +
        "1. Open Anki on desktop and select settings next to the deck you would like to export.\n" +
        "2. Hit export.\n" +
        "3. Set export format to 'notes in plain text', include the deck you wish to export, and select 'include HTML and media references' as well as 'include tags'.\n" +
        "4. Hit Export... and then save to your computer.\n" +
        "5. Choose that file from your computer to import.\n\n" +
        "You're done!"
      );
    });

    // NEW: Anki import handler
    ankiImportInput.addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      if (!selectedDeckId) {
        alert("Please select a deck first, so I know where to import the cards.");
        ankiImportInput.value = "";
        return;
      }

      const deck = getDeckById(selectedDeckId);
      if (!deck) {
        alert("Selected deck not found.");
        ankiImportInput.value = "";
        return;
      }

      const reader = new FileReader();
      reader.onload = (ev) => {
        const text = ev.target.result || "";
        const lines = text.split(/\r?\n/).filter((l) => l.trim().length > 0);

        let imported = 0;
        const timestamp = Date.now();

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];

          // Try TAB first (typical Anki export), fall back to comma
          let parts = line.split("\t");
          if (parts.length < 2) {
            parts = line.split(",");
          }
          if (parts.length < 2) continue;

          const q = parts[0].trim();
          const a = parts[1].trim();
          if (!q || !a) continue;

          const id = "c_" + timestamp + "_" + imported;
          deck.cards.push({ id, question: q, answer: a });
          imported++;
        }

        if (imported > 0) {
          saveDecks();
          refreshCardsList();
          refreshDeckSelect();
          ankiImportStatus.textContent = `Imported ${imported} cards.`;
        } else {
          ankiImportStatus.textContent = "No valid cards found in file.";
        }

        // Reset file input so you can import the same file again if needed
        ankiImportInput.value = "";
      };

      reader.onerror = () => {
        alert("Error reading file.");
        ankiImportInput.value = "";
      };

      reader.readAsText(file);
    });

    // ===================== TTS & STT =====================
    const statusDiv = document.getElementById("status");
// ========== RENDER HELPERS FOR IMAGES + MATH ==========

// Takes card text (which may contain HTML/LaTeX) and renders it into an element.
// Then asks MathJax to typeset any equations in that element.
function setCardContent(el, raw) {
  if (!el) return;
  el.innerHTML = raw || "";

  // Let MathJax typeset any LaTeX in this element
  if (window.MathJax && window.MathJax.typesetPromise) {
    MathJax.typesetPromise([el]).catch(err => {
      console.error("MathJax error:", err);
    });
  }
}

// Strip HTML tags so TTS doesn't try to read "<img ...>" etc
function getPlainTextFromCard(raw) {
  const tmp = document.createElement("div");
  tmp.innerHTML = raw || "";
  return tmp.textContent || tmp.innerText || "";
}
    function setStatus(text) {
      statusDiv.textContent = text;
    }

    let isSpeaking = false;
    // Every time we start or forcibly stop TTS, bump this.
// Old TTS callbacks check this and no-op if they're "stale".
let speakGeneration = 0;


    // ===== Native iOS VoiceCommands plugin (Capacitor) =====
    let nativeVoicePlugin = null;
    let nativeVoiceActiveCallback = null;
    let usingNativeVoice = false;

    if (
      window.Capacitor &&
      window.Capacitor.Plugins &&
      window.Capacitor.Plugins.VoiceCommands
    ) {
      nativeVoicePlugin = window.Capacitor.Plugins.VoiceCommands;
      usingNativeVoice = true;
      console.log("Using native iOS VoiceCommands plugin");

      nativeVoicePlugin.addListener("speechResult", (data) => {
        const text = (data && data.text) || "";
        const isFinal = !!(data && data.isFinal);
        if (!text) return;

        if (isFinal && nativeVoiceActiveCallback) {
          const cb = nativeVoiceActiveCallback;
          nativeVoiceActiveCallback = null;
          cb(text);
        }
      });
    }

    // ===== Browser Web SpeechRecognition fallback =====
    const SpeechRecognition =
      window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let speechSupported = !!SpeechRecognition;

    // NEW: track whether we *expect* recognition to keep listening
    let keepListening = false;

    if (speechSupported) {
      recognition = new SpeechRecognition();
      recognition.lang = "en-US";
      recognition.interimResults = false;
      recognition.continuous = false;
      recognition.maxAlternatives = 3; // tiny robustness boost, still using top result
    }

    // >>> NEW: explicit microphone permission helper (kept as-is, though not called now) <<<
    function requestMicrophoneAccess() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        console.warn("getUserMedia not supported in this browser.");
        return;
      }
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          // Immediately stop the stream; we just needed the permission prompt.
          stream.getTracks().forEach(track => track.stop());
          console.log("Microphone permission granted.");
        })
        .catch(err => {
          console.error("Microphone permission denied:", err);
          setStatus("Please allow microphone access in your browser to use hands-free mode.");
        });
    }
    // <<< END MIC HELPER <<<

    // NEW: TTS settings (rate & volume)
    let ttsRate = 1.0;
    let ttsVolume = 1.0;
    const TTS_SETTINGS_KEY = "srsTtsSettings";
    function clamp(n, min, max) {
  return Math.max(min, Math.min(max, n));
}

// Reads the full settings object (rate, volume, + new delay)
function getTtsSettingsObj() {
  const raw = localStorage.getItem(TTS_SETTINGS_KEY);
  let s = {};
  try { s = raw ? JSON.parse(raw) : {}; } catch { s = {}; }

  if (typeof s.rate !== "number") s.rate = 1.0;
  if (typeof s.volume !== "number") s.volume = 1.0;
  if (typeof s.answerDelayAfterSpeechSec !== "number") s.answerDelayAfterSpeechSec = 0;

  s.rate = clamp(s.rate, 0.5, 2.0);
  s.volume = clamp(s.volume, 0.0, 1.0);
  s.answerDelayAfterSpeechSec = clamp(Math.round(s.answerDelayAfterSpeechSec), 0, 30);

  return s;
}

function saveTtsSettingsObj(s) {
  const out = {
    rate: clamp(Number(s.rate ?? 1.0), 0.5, 2.0),
    volume: clamp(Number(s.volume ?? 1.0), 0.0, 1.0),
    answerDelayAfterSpeechSec: clamp(Math.round(Number(s.answerDelayAfterSpeechSec ?? 0)), 0, 30),
  };
  localStorage.setItem(TTS_SETTINGS_KEY, JSON.stringify(out));
}

    const toggleAudioSettingsBtn = document.getElementById("toggleAudioSettingsBtn");
    const audioSettingsPanel = document.getElementById("audioSettingsPanel");
    const ttsRateInput = document.getElementById("ttsRateInput");
    const ttsVolumeInput = document.getElementById("ttsVolumeInput");
    const answerDelayAfterSpeechSecInput = document.getElementById("answerDelayAfterSpeechSecInput");
    
if (answerDelayAfterSpeechSecInput) {
  answerDelayAfterSpeechSecInput.addEventListener("change", () => {
    const v = Math.max(
      0,
      Math.min(30, parseInt(answerDelayAfterSpeechSecInput.value, 10) || 0)
    );

    answerDelayAfterSpeechSecInput.value = String(v);

    const s = getTtsSettingsObj();
    s.answerDelayAfterSpeechSec = v;
    saveTtsSettingsObj(s);
  });
}
    // Load TTS settings from storage
    (function loadTtsSettings() {
  const s = getTtsSettingsObj();
  ttsRate = s.rate;
  ttsVolume = s.volume;

  if (ttsRateInput) ttsRateInput.value = String(ttsRate);
  if (ttsVolumeInput) ttsVolumeInput.value = String(ttsVolume);

  const delayInput = document.getElementById("answerDelayAfterSpeechSecInput");
  if (delayInput) delayInput.value = String(s.answerDelayAfterSpeechSec ?? 0);
})();


    function saveTtsSettings() {
  const current = getTtsSettingsObj();
  current.rate = ttsRate;
  current.volume = ttsVolume;

  // keep existing value unless you set it elsewhere
  saveTtsSettingsObj(current);
}

    if (toggleAudioSettingsBtn && audioSettingsPanel) {
      toggleAudioSettingsBtn.addEventListener("click", () => {
        const isHidden = audioSettingsPanel.classList.contains("hidden");
        if (isHidden) {
          audioSettingsPanel.classList.remove("hidden");
          toggleAudioSettingsBtn.textContent = "Hide";
        } else {
          audioSettingsPanel.classList.add("hidden");
          toggleAudioSettingsBtn.textContent = "Show";
        }
      });
    }

    if (ttsRateInput) {
      ttsRateInput.addEventListener("change", () => {
        let v = parseFloat(ttsRateInput.value);
        if (isNaN(v)) v = 1.0;
        v = Math.max(0.5, Math.min(2, v));
        ttsRate = v;
        ttsRateInput.value = String(v);
        saveTtsSettings();
      });
    }

    if (ttsVolumeInput) {
      ttsVolumeInput.addEventListener("change", () => {
        let v = parseFloat(ttsVolumeInput.value);
        if (isNaN(v)) v = 1.0;
        v = Math.max(0, Math.min(1, v));
        ttsVolume = v;
        ttsVolumeInput.value = String(v);
        saveTtsSettings();
      });
    }
    if (answerDelayAfterSpeechSecInput) {
  answerDelayAfterSpeechSecInput.addEventListener("change", () => {
    const v = Math.max(
      0,
      Math.min(30, parseInt(answerDelayAfterSpeechSecInput.value, 10) || 0)
    );

    answerDelayAfterSpeechSecInput.value = String(v);

    const s = getTtsSettingsObj();
    s.answerDelayAfterSpeechSec = v;
    saveTtsSettingsObj(s);
  });
}

    // Helper: stop all audio + listening
    function stopAllAudio() {
       speakGeneration++;
       clearAnswerAfterSpeechDelay();
      if (window.speechSynthesis) {
        window.speechSynthesis.cancel();
      }
      isSpeaking = false;

      // Stop native plugin listener if we're using it
      if (nativeVoicePlugin) {
        try {
          nativeVoicePlugin.stop();
        } catch (e) {
          console.error("Error stopping native voice plugin:", e);
        }
        nativeVoiceActiveCallback = null;
      }

      // Stop browser Web SpeechRecognition if used
      if (recognition) {
        try {
          // make sure auto-restart doesn't fire while we're intentionally stopping
          keepListening = false;
          recognition.onresult = null;
          recognition.onerror = null;
          recognition.onend = null;
          recognition.stop();
        } catch (e) {
          console.error("Error stopping recognition:", e);
        }
      }
    }

  function speak(text, onEnd) {
  if (!window.speechSynthesis) {
    setStatus("Text-to-speech not supported in this browser.");
    if (onEnd) onEnd();
    return;
  }

  // Always sync with the UI controls right before speaking,
  // so intro + cards all use the exact same volume & rate.
  if (ttsRateInput) {
    const v = parseFloat(ttsRateInput.value);
    if (!isNaN(v)) {
      ttsRate = Math.max(0.5, Math.min(2, v));
    }
  }
  if (ttsVolumeInput) {
    const v = parseFloat(ttsVolumeInput.value);
    if (!isNaN(v)) {
      ttsVolume = Math.max(0, Math.min(1, v));
    }
  }

  // üîá Make sure NO mic is listening before we start speaking.
  if (nativeVoicePlugin) {
    try {
      nativeVoicePlugin.stop();
    } catch (e) {
      console.error("Error stopping native voice plugin before speaking:", e);
    }
    nativeVoiceActiveCallback = null;
  }

  if (recognition) {
    try {
      keepListening = false;
      recognition.onresult = null;
      recognition.onerror = null;
      recognition.onend = null;
      recognition.stop();
    } catch (e) {
      console.error("Error stopping browser recognition before speaking:", e);
    }
  }

  // üßπ Clear any queued / half-finished utterances so we get a clean read.
  try {
    window.speechSynthesis.cancel();
  } catch (e) {
    console.error("Error cancelling previous speech:", e);
  }

  // This is a new TTS "generation"
  speakGeneration++;
  const myGeneration = speakGeneration;

  const utt = new SpeechSynthesisUtterance(text);

  // Use the *same* volume & rate for intro, questions, and answers.
  utt.rate   = ttsRate || 1.0;
  utt.volume = (typeof ttsVolume === "number") ? ttsVolume : 1.0;

  utt.onstart = () => {
    if (myGeneration !== speakGeneration) return;
    isSpeaking = true;
    setStatus("Speaking...");
  };

  const finish = () => {
    if (myGeneration !== speakGeneration) return;
    isSpeaking = false;
    setStatus("");
    if (onEnd) onEnd();
  };

  utt.onend = finish;
  utt.onerror = (err) => {
    console.error("TTS error:", err);
    finish();
  };

  window.speechSynthesis.speak(utt);
}

    function listenForCommand(callback) {
      if (isMicMuted) {
  // Don‚Äôt listen while muted
  return;
}
      // 1) Prefer native iOS plugin when running inside the Capacitor app
      if (nativeVoicePlugin) {
        setStatus("Listening...");
        // Save the callback for the next FINAL phrase from Swift
        nativeVoiceActiveCallback = callback;

        nativeVoicePlugin
          .start()
          .catch((err) => {
            console.error("Native voice start failed:", err);
            setStatus(
              "Error starting native speech. You can still use silent mode."
            );
          });
        return;
      }

      // 2) Fallback: Browser Web SpeechRecognition
      if (!speechSupported || !recognition) {
        setStatus("Speech recognition not supported in this browser.");
        return;
      }
      setStatus("Listening...");
      keepListening = true;

      recognition.onresult = (event) => {
  keepListening = false;

  const res = event.results && event.results[0];
  if (!res) return callback("");

  // Collect all alternatives (you set recognition.maxAlternatives = 3)
  const alts = [];
  for (let i = 0; i < res.length; i++) {
    if (res[i] && res[i].transcript) alts.push(res[i].transcript);
  }
  if (alts.length === 0) return callback("");

  // Pick the first alternative that parses into a rating command
  for (const alt of alts) {
    if (parseRatingFromText(alt)) {
      callback(alt);
      return;
    }
  }

  // Otherwise fall back to the top alternative for global commands, etc.
  callback(alts[0]);
};
      recognition.onerror = (event) => {
        console.error("STT error:", event.error);
        keepListening = false;
        if (event.error !== "not-allowed") {
          setTimeout(() => listenForCommand(callback), 800);
        } else {
          setStatus("Microphone access blocked.");
        }
      };
      recognition.onend = () => {
  if (keepListening && currentMode === "voice" && !isMicMuted) {
    try {
      recognition.start();
    } catch (e) {
      console.error("Error restarting recognition:", e);
    }
  }
};
      try {
        recognition.start();
      } catch (e) {
        console.error("Error starting recognition:", e);
      }
    }

    // ===================== STUDY LOGIC (DUE / AHEAD) =====================
    function splitOverdueAndDue(deckId, cards) {
  const now = Date.now();
  const overdue = [];
  const due = [];

  cards.forEach(card => {
    const key = scheduleKey(deckId, card.id);
    const s = schedule[key];

    // New cards = due today (not overdue)
    if (!s) {
      due.push(card);
      return;
    }

    const { dueTime } = normalizeScheduleEntry(s);
    if (dueTime <= now) {
      // Overdue if it was due before *today*
      if (now - dueTime > 60 * 1000) {
        overdue.push(card);
      } else {
        due.push(card);
      }
    }
  });

  return { overdue, due };
}

    function getDueCardsForDeck(deckId, allowAhead, includeOverdue) {
      const deck = getDeckById(deckId);
      if (!deck) return [];
      const now = Date.now();

      const filtered = deck.cards.filter(card => {
        const key = scheduleKey(deckId, card.id);
        const s = schedule[key];

        // New cards: treat as due now
        if (!s) {
          if (!allowAhead) return true;
          if (includeOverdue) return true;
          return true;
        }

        const normalized = normalizeScheduleEntry(s);
        const due = normalized.dueTime || now;
        const isDueOrOverdue = due <= now;
        const isFuture = due > now;

        if (!allowAhead) {
          return isDueOrOverdue;
        }

        if (isFuture) return true;
        if (includeOverdue && isDueOrOverdue) return true;
        return false;
      });

      // Still sort by dueTime so earlier due cards are "earlier" in the day,
      // but we will add randomness at selection time.
      return filtered.sort((a, b) => {
        const ka = scheduleKey(deckId, a.id);
        const kb = scheduleKey(deckId, b.id);
        const sa = schedule[ka];
        const sb = schedule[kb];
        const na = sa ? normalizeScheduleEntry(sa).dueTime : 0;
        const nb = sb ? normalizeScheduleEntry(sb).dueTime : 0;
        return na - nb;
      });
    }

    function getNextCardForDeck(deckId, allowAhead, includeOverdue) {
      const dueCards = getDueCardsForDeck(deckId, allowAhead, includeOverdue);
      if (dueCards.length === 0) return null;
      return dueCards[0];
    }

    // ===================== STUDY SESSION STATE =====================
    const mainMenuDiv = document.getElementById("mainMenu");
    const studySectionDiv = document.getElementById("studySection");
    const modeBadge = document.getElementById("modeBadge");
    const backToMenuBtn = document.getElementById("backToMenuBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const resumeBtn = document.getElementById("resumeBtn");
    const studyInstructionsBtn = document.getElementById("studyInstructionsBtn");

    const skipInstructionsAfterFirstCheckbox = document.getElementById("skipInstructionsAfterFirst");
    const autoGoodToggle = document.getElementById("autoGoodToggle");
    const autoRatingSelect = document.getElementById("autoRatingSelect");
    const answerModeDelayRadio = document.getElementById("answerModeDelay");
    const answerModeVoiceRadio = document.getElementById("answerModeVoice");
    const answerDelaySecondsInput = document.getElementById("answerDelaySeconds");
    const studyAheadGapSecondsInput = document.getElementById("studyAheadGapSeconds");
const autoEnterStudyAheadCheckbox = document.getElementById("autoEnterStudyAhead");
const loopStudyAheadCheckbox = document.getElementById("loopStudyAhead");
    const startVoiceBtn = document.getElementById("startVoiceBtn");
    const startSilentBtn = document.getElementById("startSilentBtn");

    const silentUI = document.getElementById("silentUI");
    const silentQuestion = document.getElementById("silentQuestion");
    const silentQuestionText = document.getElementById("silentQuestionText");
    const silentAnswer = document.getElementById("silentAnswer");
    const silentAnswerText = document.getElementById("silentAnswerText");
    const showAnswerBtn = document.getElementById("showAnswerBtn");
    const silentRatingButtons = document.getElementById("silentRatingButtons");

    const hintAgain = document.getElementById("hint-again");
    const hintHard = document.getElementById("hint-hard");
    const hintGood = document.getElementById("hint-good");
    const hintEasy = document.getElementById("hint-easy");

    const voiceUI = document.getElementById("voiceUI");
    const voiceQuestion = document.getElementById("voiceQuestion");
    const voiceQuestionText = document.getElementById("voiceQuestionText");
    const voiceAnswer = document.getElementById("voiceAnswer");
    const voiceAnswerText = document.getElementById("voiceAnswerText");
        const voiceRatingButtons = document.getElementById("voiceRatingButtons");
        function setVoiceRatingButtonsEnabled(enabled) {
  if (!voiceRatingButtons) return;
  voiceRatingButtons
    .querySelectorAll('button[data-voice-rating]')
    .forEach(b => (b.disabled = !enabled));
}

    const silentNextCardBtn = document.getElementById("silentNextCardBtn");

    const silentEditToggleBtn = document.getElementById("silentEditToggleBtn");
    const silentEditPanel = document.getElementById("silentEditPanel");
    const silentEditQuestion = document.getElementById("silentEditQuestion");
    const silentEditAnswer = document.getElementById("silentEditAnswer");
    const silentSaveEditBtn = document.getElementById("silentSaveEditBtn");
    const silentCancelEditBtn = document.getElementById("silentCancelEditBtn");

    const voiceEditToggleBtn = document.getElementById("voiceEditToggleBtn");
    const voiceEditPanel = document.getElementById("voiceEditPanel");
    const voiceEditQuestion = document.getElementById("voiceEditQuestion");
    const voiceEditAnswer = document.getElementById("voiceEditAnswer");
    const voiceSaveEditBtn = document.getElementById("voiceSaveEditBtn");
    const voiceCancelEditBtn = document.getElementById("voiceCancelEditBtn");

    const silentCompletionControls = document.getElementById("silentCompletionControls");
    const silentMainMenuBtn = document.getElementById("silentMainMenuBtn");
    const silentStudyAheadBtn = document.getElementById("silentStudyAheadBtn");

    let currentMode = null;
    let currentDeckId = null;
    let currentCard = null;

    // ***** STATE MACHINE FOR CARD FLOW *****
    const StudyState = {
      IDLE: "idle",
      SHOWING_QUESTION: "showing_question",
      WAITING_FOR_ANSWER: "waiting_for_answer",
      SHOWING_ANSWER: "showing_answer",
      WAITING_FOR_RATING: "waiting_for_rating"
    };

    let studyState = StudyState.IDLE;

    function setStudyState(newState) {
      studyState = newState;
      // You can comment this out later if you don't want console noise:
      console.log("Study state:", newState);
    }
    // ***** END STATE MACHINE DEFINITIONS *****

    let studyAheadSession = false;
    let noScheduleChanges = false;
    let studyAheadPromptedOnceVoice = false;
    let autoEnterStudyAhead = false;  // from Study Options
let loopStudyAhead = false;       // from Study Options
    let skipInstructionsAfterFirst = true;
    let hasSpokenInstructionsOnce = false;
    let answerMode = "delay";
    let answerDelayMs = 4000;
    let autoGoodMode = false;
    let autoModeBehavior = "good"; // again | hard | good | easy | tomorrow

    let studyAheadGapMs = 4000;
    let inStudyAheadAnswerGap = false;
    let answerAfterSpeechTimerId = null;
let answerAfterSpeechDueMs = 0;
let inAnswerAfterSpeechDelay = false;

function clearAnswerAfterSpeechDelay() {
  if (answerAfterSpeechTimerId !== null) {
    clearTimeout(answerAfterSpeechTimerId);
    answerAfterSpeechTimerId = null;
  }
  inAnswerAfterSpeechDelay = false;
  answerAfterSpeechDueMs = 0;
}
function startOrResetAnswerAfterSpeechDelay() {
  const s = getTtsSettingsObj();
  const sec = clamp(Number(s.answerDelayAfterSpeechSec || 0), 0, 30);

  if (sec === 0) {
    clearAnswerAfterSpeechDelay();
    speakAnswerThenAskDifficulty();
    return;
  }

  clearAnswerAfterSpeechDelay();
  inAnswerAfterSpeechDelay = true;
  answerAfterSpeechDueMs = Date.now() + sec * 1000;

  // ‚úÖ keep the mic open during this window so any speech resets the timer
  if (currentMode === "voice" && !isPaused) {
    listenForCommand(handleVoiceTranscript);
  }

  answerAfterSpeechTimerId = setTimeout(() => {
    inAnswerAfterSpeechDelay = false;
    answerAfterSpeechTimerId = null;
    speakAnswerThenAskDifficulty();
  }, sec * 1000);
}

    let studyAheadGapTimerId = null;

    let isPaused = false;
    let restartCardOnResumeVoice = false; // NEW: when resuming voice mode, replay current card
    let awaitingDifficulty = false;
    let awaitingAnswerSignal = false;
    let awaitingPostCompletionChoice = false;

    let reviewQueue = [];
    let aheadQueue = [];
    let aheadQueueIndex = 0;
// ===== Mic mute feature (voice-answer gap only) =====
let isMicMuted = false;
let micMutedUntilMs = 0;
let micMuteIntervalId = null;
let awaitingMuteSeconds = false;

// DOM refs (safe here because index.html already loaded)
const micMuteTimerEl = document.getElementById("micMuteTimer");
const micMuteSecondsEl = document.getElementById("micMuteSeconds");


    // NEW: track if question/answer have been spoken for current card
    let hasSpokenCurrentQuestion = false;
    let hasSpokenCurrentAnswer = false;

    // NEW: track delay window between question and answer in delay mode
    let questionDelayTimerId = null;

    function clearStudyAheadGapTimer() {
      if (studyAheadGapTimerId !== null) {
        clearTimeout(studyAheadGapTimerId);
        studyAheadGapTimerId = null;
      }
      inStudyAheadAnswerGap = false;
    }

    function clearQuestionDelayTimer() {
      if (questionDelayTimerId !== null) {
        clearTimeout(questionDelayTimerId);
        questionDelayTimerId = null;
      }
    }
    function clearMicMuteTimer() {
  if (micMuteIntervalId !== null) {
    clearInterval(micMuteIntervalId);
    micMuteIntervalId = null;
  }
  isMicMuted = false;
  micMutedUntilMs = 0;
  awaitingMuteSeconds = false;
  if (micMuteTimerEl) micMuteTimerEl.classList.add("hidden");
}

function updateMicMuteCountdownUI() {
  if (!micMuteTimerEl || !micMuteSecondsEl) return;
  const remainingMs = Math.max(0, micMutedUntilMs - Date.now());
  const remainingSec = Math.ceil(remainingMs / 1000);
  micMuteSecondsEl.textContent = String(remainingSec);
}

function startMicMute(seconds) {
  const sec = Math.max(0, Math.min(60, Number(seconds || 0)));
  isMicMuted = true;
  setStatus("Mic temporarily muted...");
  micMutedUntilMs = Date.now() + sec * 1000;

  // Stop any live listening immediately
  keepListening = false;
  if (nativeVoicePlugin) {
    try { nativeVoicePlugin.stop(); } catch (_) {}
    nativeVoiceActiveCallback = null;
  }
  if (recognition) {
    try { recognition.stop(); } catch (_) {}
  }

  if (micMuteTimerEl) micMuteTimerEl.classList.remove("hidden");
  updateMicMuteCountdownUI();

  if (micMuteIntervalId !== null) clearInterval(micMuteIntervalId);
  micMuteIntervalId = setInterval(() => {
    const remaining = micMutedUntilMs - Date.now();
    if (remaining <= 0) {
      clearInterval(micMuteIntervalId);
      micMuteIntervalId = null;
      isMicMuted = false;
      if (micMuteTimerEl) micMuteTimerEl.classList.add("hidden");

      // If we are STILL in the answer gap, resume listening for the ‚Äúanswer to show answer‚Äù
      if (!isPaused && currentMode === "voice" && awaitingAnswerSignal) {
        setStatus("Listening for your answer...");
        listenForCommand(handleVoiceTranscript);
      }
      return;
    }
    updateMicMuteCountdownUI();
  }, 250);
}

    function queueCardForAgain(deckId, cardObj) {
      if (!cardObj) return;
      const key = scheduleKey(deckId, cardObj.id);
      const exists = reviewQueue.some((c) => scheduleKey(deckId, c.id) === key);
      if (!exists) {
        reviewQueue.push(cardObj);
      }
    }

    function showMainMenu() {
      stopAllAudio();
      clearStudyAheadGapTimer();
      clearQuestionDelayTimer();

      currentMode = null;
      mainMenuDiv.classList.remove("hidden");
      studySectionDiv.classList.add("hidden");
      setStatus("");
      isPaused = false;
      awaitingDifficulty = false;
      awaitingAnswerSignal = false;
      awaitingPostCompletionChoice = false;
      resumeBtn.disabled = true;
      pauseBtn.disabled = false;
      pauseBtn.classList.remove("hidden");
      resumeBtn.classList.remove("hidden");
      silentNextCardBtn.classList.add("hidden");
      studyAheadSession = false;
      noScheduleChanges = false;
      studyAheadPromptedOnceVoice = false;
      reviewQueue = [];
      aheadQueue = [];
      aheadQueueIndex = 0;
      hasSpokenCurrentQuestion = false;
      hasSpokenCurrentAnswer = false;
      silentCompletionControls.classList.add("hidden");
      if (voiceQuestionText) voiceQuestionText.textContent = "";
      if (voiceAnswerText) voiceAnswerText.textContent = "";
      if (voiceAnswer) voiceAnswer.classList.add("hidden");
      silentEditPanel.classList.add("hidden");
      voiceEditPanel.classList.add("hidden");
            if (voiceRatingButtons) voiceRatingButtons.classList.add("hidden");
      setStudyState(StudyState.IDLE);
    }
function updateDeckBadge() {
  if (!deckBadge) return;
  const deck = getDeckById(currentDeckId);
  deckBadge.textContent = deck ? `Deck: ${deck.name}` : "";
}

function openAddCardModal() {
  // Stop audio/listening so the modal is calm in hands-free mode
  stopAllAudio();
  clearStudyAheadGapTimer();
  clearQuestionDelayTimer();

  if (addCardModalStatus) addCardModalStatus.textContent = "";
  if (addCardModalQuestion) addCardModalQuestion.value = "";
  if (addCardModalAnswer) addCardModalAnswer.value = "";

  addCardModal.classList.remove("hidden");
  addCardModal.setAttribute("aria-hidden", "false");
  if (addCardModalQuestion) addCardModalQuestion.focus();
}

function closeAddCardModal() {
  addCardModal.classList.add("hidden");
  addCardModal.setAttribute("aria-hidden", "true");

  // If you were in voice mode, resume your normal loop
  if (currentMode === "voice" && !isPaused) runVoiceLoop();
  if (currentMode === "silent" && !isPaused) runSilentLoop();
}
function openInstructionsModal() {
  // pause audio/listening so the modal isn‚Äôt chaotic in hands-free mode
  stopAllAudio();
  clearStudyAheadGapTimer();
  clearQuestionDelayTimer();
  clearAnswerAfterSpeechDelay();

  if (!instructionsModal) return;
  instructionsModal.classList.remove("hidden");
  instructionsModal.setAttribute("aria-hidden", "false");
}

function closeInstructionsModal() {
  if (!instructionsModal) return;
  instructionsModal.classList.add("hidden");
  instructionsModal.setAttribute("aria-hidden", "true");

  // If you were studying, resume the correct loop
  if (currentMode === "voice" && !isPaused) runVoiceLoop();
  if (currentMode === "silent" && !isPaused) runSilentLoop();
}

if (openInstructionsBtn) {
  openInstructionsBtn.addEventListener("click", openInstructionsModal);
}

if (instructionsCloseBtn) {
  instructionsCloseBtn.addEventListener("click", closeInstructionsModal);
}

// click backdrop to close
if (instructionsModal) {
  instructionsModal.addEventListener("click", (e) => {
    if (e.target && e.target.classList && e.target.classList.contains("modalBackdrop")) {
      closeInstructionsModal();
    }
  });
}

// ESC to close
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && instructionsModal && !instructionsModal.classList.contains("hidden")) {
    closeInstructionsModal();
  }
});


    function showStudySection(mode) {
      currentMode = mode;
      mainMenuDiv.classList.add("hidden");
      studySectionDiv.classList.remove("hidden");
      modeBadge.textContent = mode === "voice" ? "Hands-Free Mode" : "Silent Mode";
      isPaused = false;
      resumeBtn.disabled = true;
      pauseBtn.disabled = false;
      pauseBtn.classList.remove("hidden");
      resumeBtn.classList.remove("hidden");
      updateDeckBadge();
    }

    backToMenuBtn.addEventListener("click", () => {
      stopAllAudio();
      showMainMenu();
    });

    pauseBtn.addEventListener("click", () => {
  isPaused = true;

  // NEW: make Resume replay the SAME card in hands-free mode
  if (currentMode === "voice" && currentCard) {
    restartCardOnResumeVoice = true;
  }
stopAllAudio();  
  clearStudyAheadGapTimer();
  clearQuestionDelayTimer();

  pauseBtn.disabled = true;
  resumeBtn.disabled = false;
  setStatus("Paused. Say 'resume study session' or tap Resume.");

  // keep listening while paused when paused via button
  if (currentMode === "voice" && speechSupported && recognition) {
    listenForCommand(handleVoiceTranscript);
  }
});

    resumeBtn.addEventListener("click", () => {
  if (!currentMode) return;

  isPaused = false;
  pauseBtn.disabled = false;
  resumeBtn.disabled = true;

  if (currentMode === "voice") {
    // NEW: replay the paused card instead of advancing
    if (restartCardOnResumeVoice && currentCard) {
      restartCardOnResumeVoice = false;
      restartCurrentCardVoiceFlow();
      return;
    }
    runVoiceLoop();
  } else {
    runSilentLoop();
  }
});

if (studyAddCardBtn) {
  studyAddCardBtn.addEventListener("click", () => {
    if (!currentDeckId) return;
    openAddCardModal();
  });
}

if (addCardModalCloseBtn) addCardModalCloseBtn.addEventListener("click", closeAddCardModal);
if (addCardModalCancelBtn) addCardModalCancelBtn.addEventListener("click", closeAddCardModal);

// Close when clicking backdrop
if (addCardModal) {
  addCardModal.addEventListener("click", (e) => {
    if (e.target && e.target.classList && e.target.classList.contains("modalBackdrop")) {
      closeAddCardModal();
    }
  });
}

// Save card into CURRENT deck
if (addCardModalSaveBtn) {
  addCardModalSaveBtn.addEventListener("click", () => {
    const q = (addCardModalQuestion?.value || "").trim();
    const a = (addCardModalAnswer?.value || "").trim();

    if (!q || !a) {
      if (addCardModalStatus) addCardModalStatus.textContent = "Please enter both a question and an answer.";
      return;
    }

    const deck = getDeckById(currentDeckId);
    if (!deck) {
      if (addCardModalStatus) addCardModalStatus.textContent = "Deck not found.";
      return;
    }

    const id = "c_" + Date.now();
    deck.cards.push({ id, question: q, answer: a });

    saveDecks();
    refreshDeckSelect();
    refreshCardsList();

    if (addCardModalStatus) addCardModalStatus.textContent = "Saved!";
    closeAddCardModal();
  });
}

// ESC to close
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && addCardModal && !addCardModal.classList.contains("hidden")) {
    closeAddCardModal();
  }
});
    
    function endStudySession() {
  clearStudyAheadGapTimer();
  clearQuestionDelayTimer();
  clearAnswerAfterSpeechDelay();
  if (voiceRatingButtons) {
    voiceRatingButtons.classList.add("hidden");
  }
  showMainMenu();
  setStatus("Study session ended.");
}

    // ===================== INLINE EDIT HELPERS =====================
    function updateCardTextInDeck(deckId, cardId, newQ, newA) {
      const deck = getDeckById(deckId);
      if (!deck) return null;
      const card = deck.cards.find(c => c.id === cardId);
      if (!card) return null;
      card.question = newQ;
      card.answer = newA;
      saveDecks();
      refreshDeckSelect();
      return card;
    }

    // Silent mode inline edit
    silentEditToggleBtn.addEventListener("click", () => {
      if (!currentCard) return;
      silentEditQuestion.value = currentCard.question;
      silentEditAnswer.value = currentCard.answer;
      silentEditPanel.classList.remove("hidden");
    });

    silentCancelEditBtn.addEventListener("click", () => {
      silentEditPanel.classList.add("hidden");
    });

    silentSaveEditBtn.addEventListener("click", () => {
      if (!currentCard) return;
      const q = silentEditQuestion.value.trim();
      const a = silentEditAnswer.value.trim();
      if (!q || !a) return;
      const updated = updateCardTextInDeck(currentDeckId, currentCard.id, q, a);
      if (!updated) return;
      currentCard = updated;
      setCardContent(silentQuestionText, currentCard.question);
setCardContent(silentAnswerText, currentCard.answer);
      setCardContent(voiceQuestionText, currentCard.question);
setCardContent(voiceAnswerText, currentCard.answer);

      // refresh main card list so changes are visible there too
      refreshCardsList();

      silentEditPanel.classList.add("hidden");
      setStatus("Card updated.");
    });

    // Voice mode inline edit
    voiceEditToggleBtn.addEventListener("click", () => {
      if (!currentCard) return;
      voiceEditQuestion.value = currentCard.question;
      voiceEditAnswer.value = currentCard.answer;
      voiceEditPanel.classList.remove("hidden");
    });

    voiceCancelEditBtn.addEventListener("click", () => {
      voiceEditPanel.classList.add("hidden");
    });

    voiceSaveEditBtn.addEventListener("click", () => {
      if (!currentCard) return;
      const q = voiceEditQuestion.value.trim();
      const a = voiceEditAnswer.value.trim();
      if (!q || !a) return;
      const updated = updateCardTextInDeck(currentDeckId, currentCard.id, q, a);
      if (!updated) return;
      currentCard = updated;
      setCardContent(voiceQuestionText, currentCard.question);
setCardContent(voiceAnswerText, currentCard.answer);

      setCardContent(silentQuestionText, currentCard.question);
setCardContent(silentAnswerText, currentCard.answer);

      // refresh main card list so changes are visible there too
      refreshCardsList();

      voiceEditPanel.classList.add("hidden");
      setStatus("Card updated.");
    });

    // ===================== VOICE MODE =====================

    // Helper: detect "main menu" style commands
    function isMainMenuCommand(text) {
      const t = text.toLowerCase();
      return (
        t.includes("main menu") ||
        (t.includes("menu") && t.includes("main")) ||
        t.includes("go back") ||
        t.includes("back to menu") ||
        t.includes("back to the menu") ||
        t.includes("go to the menu") ||
        t.includes("go to main menu")
      );
    }
   // NEW: stop any current audio, then confirm + go to main menu
function speakAndGoToMainMenu() {
  // üîá cut off any answer TTS or listening that might still be running
  stopAllAudio();

  // Now speak a quick confirmation, then end the session
  speak("Going to the main menu.", () => {
    endStudySession();
  });
}


    // NEW helper: fully restart current card flow in hands-free mode
    function restartCurrentCardVoiceFlow() {
      if (!currentCard) return;

      // Reset timers and state for this card
      clearStudyAheadGapTimer();
      clearQuestionDelayTimer();
      clearAnswerAfterSpeechDelay();
      awaitingDifficulty = false;
      awaitingAnswerSignal = false;
      awaitingPostCompletionChoice = false;
      inStudyAheadAnswerGap = false;

      // Hide answer again and reset flags
      if (voiceAnswer) {
        voiceAnswer.classList.add("hidden");
      }
      hasSpokenCurrentAnswer = false;
      hasSpokenCurrentQuestion = false;

      setStatus("Repeating card...");
      setStudyState(StudyState.SHOWING_QUESTION);

      hasSpokenCurrentQuestion = true;
        speak(getPlainTextFromCard(currentCard.question), () => {
    if (isPaused) return;
    if (answerMode === "delay") {
      const delay = Math.max(
        1,
        Math.min(60, Math.floor(answerDelayMs / 1000))
      );

      // ‚úÖ Only tracking that we‚Äôre waiting for the answer delay
      setStudyState(StudyState.WAITING_FOR_ANSWER);
      questionDelayTimerId = setTimeout(() => {
        if (!isPaused) {
          // Here we speak the answer *then* open the mic for rating / pause / menu
          speakAnswerThenAskDifficulty();
        }
      }, delay * 1000);
    } else {
      // Voice answer mode stays the same
      awaitingAnswerSignal = true;
      setStudyState(StudyState.WAITING_FOR_ANSWER);
      setStatus("Listening for your answer...");
      listenForCommand(handleVoiceTranscript);
    }
  });
    }

    function handleNextCardSkip() {
  if (!currentCard || !currentDeckId) return;

  // 1) Hard stop anything that could still fire the answer later
  stopAllAudio();                 // cancels TTS + mic
  clearQuestionDelayTimer();      // kills delay-mode timer
  clearStudyAheadGapTimer();      // kills study-ahead gap window
  clearAnswerAfterSpeechDelay();  // kills ‚Äúanswer after I stop speaking‚Äù timer
  clearMicMuteTimer();            // optional safety

  // 2) Reset flow flags so nothing thinks we‚Äôre mid-step
  awaitingAnswerSignal = false;
  awaitingDifficulty = false;
  inAnswerAfterSpeechDelay = false;

  // 3) Hide answer UI (we‚Äôre skipping it)
  if (voiceAnswer) voiceAnswer.classList.add("hidden");
  if (voiceRatingButtons) voiceRatingButtons.classList.add("hidden");

  // 4) Apply EASY only when schedule changes are enabled
  if (!noScheduleChanges) {
    const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, "easy");
    if (nextState && nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES) {
      queueCardForAgain(currentDeckId, currentCard);
    }
  }

  // 5) Advance
  setStudyState(StudyState.IDLE);
  runVoiceLoop();
}


    function normalizeCmdText(x) {
  return String(x || "")
    .toLowerCase()
    // ‚úÖ allow digits too, so "10" survives
    .replace(/[^a-z0-9\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}
function isNextCardCommand(text) {
  const t = normalizeCmdText(text);
  return (
    t === "go to next card" ||
    t === "go next card" ||       // optional: forgiving variation
    t === "go to the next card"   // optional: forgiving variation
  );
}


// tiny Levenshtein distance (fast enough for 1‚Äì2 word commands)
function levenshtein(a, b) {
  if (a === b) return 0;
  const al = a.length, bl = b.length;
  if (!al) return bl;
  if (!bl) return al;

  const dp = Array.from({ length: al + 1 }, () => new Array(bl + 1).fill(0));
  for (let i = 0; i <= al; i++) dp[i][0] = i;
  for (let j = 0; j <= bl; j++) dp[0][j] = j;

  for (let i = 1; i <= al; i++) {
    for (let j = 1; j <= bl; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[i][j] = Math.min(
        dp[i - 1][j] + 1,
        dp[i][j - 1] + 1,
        dp[i - 1][j - 1] + cost
      );
    }
  }
  return dp[al][bl];
}
function parseMuteSeconds(text) {
  const t = normalizeCmdText(text);

  // Accept ‚Äú10‚Äù, ‚Äúten‚Äù, ‚Äú20‚Äù, ‚Äútwenty‚Äù, etc.
  const map = {
    "10": 10, "ten": 10,
    "20": 20, "twenty": 20,
    "30": 30, "thirty": 30,
    "40": 40, "forty": 40,
    "50": 50, "fifty": 50,
    "60": 60, "sixty": 60,
  };

  // Look for any token that matches
  const parts = t.split(" ");
  for (const p of parts) {
    if (map[p]) return map[p];
  }

  // Handle phrases like "20 seconds"
  if (t.includes("10")) return 10;
  if (t.includes("20")) return 20;
  if (t.includes("30")) return 30;
  if (t.includes("40")) return 40;
  if (t.includes("50")) return 50;
  if (t.includes("60")) return 60;

  return null;
}

function parseRatingFromText(text) {
  const t = normalizeCmdText(text);
  if (!t) return null;

  // Prefer matching the FIRST word for rating commands (reduces false hits)
  const first = t.split(" ")[0] || "";

  // Direct phrase matches
  if (t.includes("repeat question") || t.includes("repeat answer")) return null; // handled elsewhere
  if (t.includes("main menu") || t.includes("go to the main menu")) return null; // handled elsewhere

  // Easy wins
  if (t.includes("again")) return "again";
  if (t.includes("hard")) return "hard";
  if (t.includes("easy")) return "easy";

  // ‚ÄúGood‚Äù synonyms / common mishears
  // (Web Speech often returns could/hood/gud/go when you say "good")
  const goodLike = new Set([
    "good", "fine", "okay", "ok", "k",
    "could", "hood", "gud", "go", "goo", "gould"
  ]);
  if (goodLike.has(first) || t.includes(" good ") || t.endsWith(" good")) return "good";

  // Fuzzy match the FIRST word to the 4 commands
  const targets = ["again", "hard", "good", "easy"];
  let best = null;
  let bestDist = 999;

  for (const cmd of targets) {
    const d = levenshtein(first, cmd);
    if (d < bestDist) {
      bestDist = d;
      best = cmd;
    }
  }

  // Thresholds: short words need tighter thresholds
  // - good/easy/hard: allow distance 1 (e.g., gud -> good)
  // - again: allow distance 2 (it‚Äôs longer)
  if (best === "again" && bestDist <= 2) return "again";
  if (best !== "again" && bestDist <= 1) return best;

  return null;
}

    // Helper: detect "main menu" style commands
function isMainMenuCommand(text) {
  const t = text.toLowerCase();
  return (
    t.includes("main menu") ||
    (t.includes("menu") && t.includes("main")) ||
    t.includes("go back") ||
    t.includes("back to menu") ||
    t.includes("back to the menu") ||
    t.includes("go to the menu") ||
    t.includes("go to main menu")
  );
}

// NEW: stop any current audio, then confirm + go to main menu
function speakAndGoToMainMenu() {
  stopAllAudio();
  speak("Going to the main menu.", () => {
    endStudySession();
  });
}

function handleGlobalVoiceCommands(text) {
  const t = text.toLowerCase();

  // üîÅ Repeat question ‚Äî allowed in ANY voice state when we have a card
  if (t.includes("repeat question") && currentMode === "voice" && currentCard) {
    restartCurrentCardVoiceFlow();
    return true;
  }

  // üîÅ Repeat answer ‚Äî allowed whenever we've already shown an answer
  if (t.includes("repeat answer") && currentMode === "voice" && currentCard) {
    const plainAnswer = getPlainTextFromCard(currentCard.answer);
    speak("Answer: " + plainAnswer, () => {
      if (isPaused) return;

      // If we're in study-ahead + gap, restart the gap window
      if (noScheduleChanges && studyAheadSession && inStudyAheadAnswerGap) {
        startStudyAheadAnswerWindow(true);
        return;
      }

      // If we are waiting for difficulty in normal mode, just re-prompt
      if (awaitingDifficulty && !noScheduleChanges) {
        const detailed =
          !hasSpokenInstructionsOnce || !skipInstructionsAfterFirst;
        hasSpokenInstructionsOnce = true;
        const promptText = detailed
          ? "How was that? Say again, hard, good, or easy."
          : "How was that?";
        speak(promptText, () => {
          listenForCommand(handleVoiceTranscript);
        });
        return;
      }

      // If we're at post-completion choice, re-prompt main menu
      if (awaitingPostCompletionChoice) {
        speak("Say main menu to go back.", () => {
          listenForCommand(handleVoiceTranscript);
        });
        return;
      }

      // Otherwise, just keep listening for the next command
      if (currentMode === "voice") {
        listenForCommand(handleVoiceTranscript);
      }
    });
    return true;
  }

  // üßä Pause study session ‚Äì pause IMMEDIATELY (before speaking)
if (
  t.includes("pause study session") ||
  (t.includes("pause") && (t.includes("study") || t.includes("session")))
) {
  if (currentMode === "voice" && !isPaused) {

    // ‚úÖ pause right now (not inside speak callback)
    isPaused = true;

    // ‚úÖ ensure resume replays same card
    if (currentCard) restartCardOnResumeVoice = true;

    // ‚úÖ kill anything that could advance the session
    stopAllAudio();
    clearStudyAheadGapTimer();
    clearQuestionDelayTimer();
    clearAnswerAfterSpeechDelay();

    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
    setStatus("Paused. Say 'resume study session' or tap Resume.");

    // optional: quick confirmation, but it won't affect pause state
    speak("Paused.", () => {
      // keep listening while paused so you can say "resume study session"
      listenForCommand(handleVoiceTranscript);
    });
  }
  return true;
}

  // ‚ñ∂Ô∏è Resume study session ‚Äì allowed anytime we‚Äôre paused
  if (
    t.includes("resume study session") ||
    (t.includes("resume") && (t.includes("study") || t.includes("session")))
  ) {
    if (isPaused) {
  speak("Resuming study session.", () => {
    isPaused = false;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;

    if (currentMode === "voice") {
      if (restartCardOnResumeVoice && currentCard) {
        restartCardOnResumeVoice = false;
        restartCurrentCardVoiceFlow();
        return;
      }
      runVoiceLoop();
    } else if (currentMode === "silent") {
      runSilentLoop();
    }
  });
}
    return true;
  }

  // üè† Main menu ‚Äì now allowed in ANY voice state (normal or study-ahead)
  if (isMainMenuCommand(t) && currentMode === "voice") {
    speakAndGoToMainMenu();
    return true;
  }

  // ‚ùå End study session
  if (t.includes("end study session")) {
    endStudySession();
    return true;
  }

  return false;
}

    function handleVoiceTranscript(text) {
      // If we are waiting to play the answer after speech ended, ANY transcript resets the countdown
if (inAnswerAfterSpeechDelay) {

  if (isNextCardCommand(text)) { handleNextCardSkip(); return; }

  // Optional: ignore empty
  if (normalizeCmdText(text).length > 0) {
    startOrResetAnswerAfterSpeechDelay();
    return;
  }
}
  // First, let global commands capture things like pause, resume, main menu, repeats
  if (handleGlobalVoiceCommands(text)) return;
  // ‚úÖ Next card = skip answer + auto-easy (or just advance in study-ahead)
if (isNextCardCommand(text) && currentMode === "voice") {
  handleNextCardSkip();
  return;
}
  // ===== Mic mute command: ONLY during voice-answer gap (after question, before answer) =====
if (awaitingAnswerSignal && currentMode === "voice") {
  const t = normalizeCmdText(text);

  if (!awaitingMuteSeconds && (t === "mute microphone" || t.includes("mute microphone"))) {
    awaitingMuteSeconds = true;

    // Speak the allowed options and then listen for a number
    speak("10, 20, 30, 40, 50, or 60 seconds?", () => {
      listenForCommand((numText) => {
        const n = parseMuteSeconds(numText);
        if (!n) {
          // reprompt once (safe, minimal)
          speak("Please say 10, 20, 30, 40, 50, or 60.", () => {
            awaitingMuteSeconds = true;
            listenForCommand((numText2) => {
              const n2 = parseMuteSeconds(numText2);
              awaitingMuteSeconds = false;
              if (!n2) {
                speak("Okay, not muting.", () => {
                  // resume listening for the answer
                  if (!isPaused && awaitingAnswerSignal) {
                    setStatus("Listening for your answer...");
                    listenForCommand(handleVoiceTranscript);
                  }
                });
                return;
              }
              startMicMute(n2);
            });
          });
          return;
        }

        awaitingMuteSeconds = false;
        startMicMute(n);
      });
    });

    return; // important: don‚Äôt fall through
  }
}

  // If we were in the study-ahead answer gap, we no longer need a special case here;
  // main menu / repeat answer are already handled globally.

  // If we're choosing what to do after finishing all due cards
  if (awaitingPostCompletionChoice) {
    const wantsMainMenu = isMainMenuCommand(text);

    awaitingPostCompletionChoice = false;

    if (wantsMainMenu) {
      speakAndGoToMainMenu();
      return;
    }

    // Otherwise: enter study-ahead mode (no schedule changes)
    studyAheadSession = true;
    noScheduleChanges = true;
    studyAheadPromptedOnceVoice = false;

    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    speak(
      "Okay, entering study ahead mode. These reviews will not change your future schedule.",
      () => {
        runVoiceLoop();
      }
    );
    return;
  }

  // If we're waiting for the user to say "I'm ready" in voice-answer mode
  if (awaitingAnswerSignal) {
  awaitingAnswerSignal = false;
  startOrResetAnswerAfterSpeechDelay();
  return;
}

  // Difficulty / rating flow (normal, schedule-changing mode only)
  if (awaitingDifficulty) {
    const t = text.toLowerCase();
      if (isNextCardCommand(text)) { handleNextCardSkip(); return; }

    // Main menu commands are already handled globally, but just in case:
    if (isMainMenuCommand(t)) {
      awaitingDifficulty = false;
      speakAndGoToMainMenu();
      return;
    }

    // In study-ahead (noScheduleChanges) we should never be here,
    // but if we are, just re-prompt for main menu.
    if (noScheduleChanges) {
      speak("Say main menu to go to the main menu.", () => {
        listenForCommand(handleVoiceTranscript);
      });
      return;
    }

    const ratingKey = parseRatingFromText(text);
    if (!ratingKey) {
      speak(
        "I didn't catch that. Please say again, hard, good, or easy.",
        () => {
          listenForCommand(handleVoiceTranscript);
        }
      );
      return;
    }

    // Apply scheduling normally
    const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, ratingKey);
    if (nextState && nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES) {
      queueCardForAgain(currentDeckId, currentCard);
    }

    awaitingDifficulty = false;
    if (voiceRatingButtons) {
      voiceRatingButtons.classList.add("hidden");
    }
    setStudyState(StudyState.IDLE);
    runVoiceLoop();
    return;
  }

  // Fallback: keep listening for the next command in voice mode
  if (currentMode === "voice") {
    listenForCommand(handleVoiceTranscript);
  }
}

    function describeAutoModeBehavior() {
      switch (autoModeBehavior) {
        case "again":
          return "mark each card as again";
        case "hard":
          return "mark each card as hard";
        case "good":
          return "mark each card as good";
        case "easy":
          return "mark each card as easy";
        case "tomorrow":
          return "push each card to show again tomorrow";
        default:
          return "mark each card as good";
      }
    }

    function speakAnswerThenAskDifficulty() {
      if (!currentCard) return;

      if (voiceAnswer) {
        voiceAnswer.classList.remove("hidden");
      }
      
      hasSpokenCurrentAnswer = true;
      setStudyState(StudyState.SHOWING_ANSWER);
      const plainAnswer = getPlainTextFromCard(currentCard.answer);
speak("Answer: " + plainAnswer, () => {
        // STUDY-AHEAD HANDS-FREE: always respect the study-ahead gap and never schedule
        if (noScheduleChanges && studyAheadSession) {
          startStudyAheadAnswerWindow(false);
          return;
        }

        // Automatic mode for pure hands-free, no commands
        if (autoGoodMode) {
          // Only schedule in normal mode; never schedule in noScheduleChanges/study-ahead
          if (!noScheduleChanges) {
            if (autoModeBehavior === "tomorrow") {
              applyTomorrowScheduling(currentDeckId, currentCard.id);
            } else {
              const behaviorRating = autoModeBehavior || "good";
              const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, behaviorRating);
              if (nextState && nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES) {
                queueCardForAgain(currentDeckId, currentCard);
              }
            }
          }
          // Just advance to the next card
          setStudyState(StudyState.IDLE);
          runVoiceLoop();
          return;
        }

        if (noScheduleChanges && !studyAheadSession) {
          // This case shouldn't normally happen, but keep safety behavior
          if (!studyAheadPromptedOnceVoice) {
            studyAheadPromptedOnceVoice = true;
            speak("Say main menu to go to the main menu.", () => {
              runVoiceLoop();
            });
          } else {
            runVoiceLoop();
          }
          return;
        }

        const detailed =
          !hasSpokenInstructionsOnce || !skipInstructionsAfterFirst;
        hasSpokenInstructionsOnce = true;
        const promptText = detailed
          ? "How was that? Say again, hard, good, or easy. You can also say next, repeat question, or repeat answer."
          : "How was that?";
           // Show tap-to-rate buttons in normal voice mode (not auto mode / study-ahead)
        // Buttons are already visible; enable them now that the answer is being shown
if (!noScheduleChanges && !autoGoodMode && voiceRatingButtons) {
  voiceRatingButtons.classList.remove("hidden");
  setVoiceRatingButtonsEnabled(true);
}
        awaitingDifficulty = true;
        setStudyState(StudyState.WAITING_FOR_RATING);
        speak(promptText, () => {
          listenForCommand(handleVoiceTranscript);
        });
      });
    }

    // NEW: Study-ahead answer window ‚Äì gives you time to say "repeat answer" or "main menu"
    function startStudyAheadAnswerWindow(restartOnly) {
      if (isPaused) return;
      clearStudyAheadGapTimer();
      inStudyAheadAnswerGap = true;

      const startListeningAndTimer = () => {
        if (!isPaused && currentMode === "voice") {
          listenForCommand(handleVoiceTranscript);
        }
        studyAheadGapTimerId = setTimeout(() => {
          inStudyAheadAnswerGap = false;
          studyAheadGapTimerId = null;
          if (!isPaused && currentMode === "voice" && !awaitingPostCompletionChoice) {
            runVoiceLoop();
          }
        }, studyAheadGapMs);
      };

      if (!restartOnly && !studyAheadPromptedOnceVoice) {
        studyAheadPromptedOnceVoice = true;
        speak("You are in study ahead mode. You can say repeat answer, repeat question, pause study session, resume study session, or main menu before the next card.", () => {
          if (isPaused) return;
          startListeningAndTimer();
        });
      } else {
        startListeningAndTimer();
      }
    }

    // NEW helper: randomized next-card picker for normal (schedule-changing) mode
    function pickRandomNextCardNormal(dueCards, lastId, isSilentMode) {
      // Remove duplicates between reviewQueue and dueCards
      const uniqueDue = dueCards.filter(card =>
        !reviewQueue.some(r => r.id === card.id)
      );

      const reviewCandidates = reviewQueue.slice();
      const dueCandidates = uniqueDue;

      function pickFromPool(pool) {
        if (pool.length === 0) return null;
        let candidates = pool;
        if (pool.length > 1 && lastId) {
          const filtered = pool.filter(c => c.id !== lastId);
          if (filtered.length > 0) {
            candidates = filtered;
          }
        }
        const idx = Math.floor(Math.random() * (candidates.length));
        return candidates[idx];
      }

      function chooseRandom() {
        if (reviewCandidates.length === 0 && dueCandidates.length === 0) return null;

        let poolType;
        if (reviewCandidates.length && dueCandidates.length) {
          // 50/50 mix when both exist
          poolType = Math.random() < 0.5 ? "review" : "due";
        } else if (reviewCandidates.length) {
          poolType = "review";
        } else {
          poolType = "due";
        }

        let candidate = pickFromPool(poolType === "review" ? reviewCandidates : dueCandidates);

        // If we couldn't get a candidate from that pool (e.g., only lastId and we're avoiding it),
        // fall back to the other pool if possible.
        if (!candidate && poolType === "review") {
          candidate = pickFromPool(dueCandidates);
        } else if (!candidate && poolType === "due") {
          candidate = pickFromPool(reviewCandidates);
        }

        // In silent mode we prefer never to repeat the same card back-to-back
        // when there are other options. The picker above already tries to avoid
        // lastId when pool size > 1, so at this point if candidate === lastId,
        // it means it's the only card available globally.
        return candidate;
      }

      const chosen = chooseRandom();

      if (chosen && reviewQueue.length > 0) {
        // If we picked from reviewQueue, remove it so it can be re-queued later
        const idx = reviewQueue.findIndex(c => c.id === chosen.id);
        if (idx !== -1) {
          reviewQueue.splice(idx, 1);
        }
      }

      return chosen;
    }

    function runVoiceLoop() {
      if (isPaused) {
        setStatus("Paused.");
        return;
      }
      clearStudyAheadGapTimer();
      clearQuestionDelayTimer();
      clearAnswerAfterSpeechDelay();
      const deck = getDeckById(currentDeckId);
      if (!deck || deck.cards.length === 0) {
        if (voiceQuestionText) voiceQuestionText.textContent = "";
        if (voiceAnswerText) voiceAnswerText.textContent = "";
        if (voiceAnswer) voiceAnswer.classList.add("hidden");

        setStudyState(StudyState.IDLE);
        speak("This deck has no cards.", () => {
          awaitingPostCompletionChoice = true;
          speak("Say main menu to go back.", () =>
            listenForCommand(handleVoiceTranscript)
          );
        });
        return;
      }

      const allowAhead = studyAheadSession;
      const includeOverdue = !noScheduleChanges;
      const lastId = currentCard ? currentCard.id : null;

      let nextCard = null;

      // Study-ahead voice mode (no schedule changes, uses aheadQueue)
      if (noScheduleChanges && allowAhead) {
        if (!aheadQueue || aheadQueue.length === 0) {
          aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
          aheadQueueIndex = 0;
        }
        if (aheadQueueIndex < aheadQueue.length) {
          nextCard = aheadQueue[aheadQueueIndex++];
        } else {
          nextCard = null;
        }
      } else {
        // Normal schedule-changing mode with randomized mixing
        const dueCards = getDueCardsForDeck(currentDeckId, false, includeOverdue);
const { overdue, due } = splitOverdueAndDue(currentDeckId, dueCards);

// üö® Always exhaust overdue cards first
if (overdue.length > 0) {
  nextCard = pickRandomNextCardNormal(overdue, lastId, false);
} else {
  nextCard = pickRandomNextCardNormal(due, lastId, false);
}
      }

      if (!nextCard && !allowAhead) {
  // Finished all due cards (normal mode)
  if (autoEnterStudyAhead) {
    // Automatically enter study-ahead mode
    studyAheadSession = true;
    noScheduleChanges = true;
    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    setStudyState(StudyState.IDLE);
    speak(
      "Congratulations, you are all caught up, no more cards are due today. Entering study ahead mode.",
      () => {
        runVoiceLoop();
      }
    );
    return;
  }

  // Old behavior: ask if they want study-ahead
  setStudyState(StudyState.IDLE);
  awaitingPostCompletionChoice = true;
  speak(
    "Congratulations, you are all caught up, no more cards are due today.",
    () => {
      speak(
        "If you'd like to go back to the main menu, say 'main menu'. Otherwise, say 'study ahead mode' to enter study ahead mode, which lets you review all cards in this deck without affecting their future due dates.",
        () => {
          listenForCommand(handleVoiceTranscript);
        }
      );
    }
  );
  return;
} else if (!nextCard && allowAhead) {
  // Finished all cards in study-ahead mode
  if (noScheduleChanges && studyAheadSession && loopStudyAhead) {
    // Automatically loop study-ahead again (no extra prompt)
    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    if (aheadQueue.length > 0) {
      setStudyState(StudyState.IDLE);
      runVoiceLoop();
      return;
    }
    // If for some reason there are no cards, fall through to message below
  }

  setStudyState(StudyState.IDLE);
  awaitingPostCompletionChoice = true;
  speak(
    "There are no more cards available to study in this deck right now.",
    () => {
      speak("Say main menu to go back, or study ahead to enter review all cards in this deck again.", () =>
        listenForCommand(handleVoiceTranscript)
      );
    }
  );
  return;
}

      currentCard = nextCard;
      setStatus("Studying card...");
      hasSpokenCurrentQuestion = false;
      hasSpokenCurrentAnswer = false;

      setCardContent(voiceQuestionText, currentCard.question);
setCardContent(voiceAnswerText, currentCard.answer);

      if (voiceAnswer) {
        voiceAnswer.classList.add("hidden");
      }
      voiceEditPanel.classList.add("hidden");
   // Show rating buttons immediately AND make them clickable right away
if (!noScheduleChanges && !autoGoodMode && voiceRatingButtons) {
  voiceRatingButtons.classList.remove("hidden");
  setVoiceRatingButtonsEnabled(true);
} else if (voiceRatingButtons) {
  voiceRatingButtons.classList.add("hidden");
}

      hasSpokenCurrentQuestion = true;
      setStudyState(StudyState.SHOWING_QUESTION);

      speak(getPlainTextFromCard(currentCard.question), () => {
        if (isPaused) return;
        if (answerMode === "delay") {
          const delay = Math.max(
            1,
            Math.min(60, Math.floor(answerDelayMs / 1000))
          );
          // In auto mode we do NOT start listening here,
          // so the mic isn't open while you're silently thinking.
          if (!autoGoodMode) {
            // start listening so "repeat question" etc. work before the answer
            listenForCommand(handleVoiceTranscript);
          }
          setStudyState(StudyState.WAITING_FOR_ANSWER);
          questionDelayTimerId = setTimeout(() => {
            if (!isPaused) {
              speakAnswerThenAskDifficulty();
            }
          }, delay * 1000);
        } else {
          awaitingAnswerSignal = true;
          setStudyState(StudyState.WAITING_FOR_ANSWER);
          setStatus("Listening for your answer...");
          listenForCommand(handleVoiceTranscript);
        }
      });
    }

    // ===================== SILENT MODE =====================
    function clearSilentHints() {
      hintAgain.textContent = "";
      hintHard.textContent = "";
      hintGood.textContent = "";
      hintEasy.textContent = "";
    }

    function updateSilentDueHints() {
      if (!currentCard || noScheduleChanges) {
        clearSilentHints();
        return;
      }
      const deckId = currentDeckId;
      const cardId = currentCard.id;

      // "Again" always means ~5 minutes (back to ladder level 1)
      hintAgain.textContent = "5 min >";

      const hardMinutes = previewIntervalMinutes(deckId, cardId, "hard");
      const goodMinutes = previewIntervalMinutes(deckId, cardId, "good");
      const easyMinutes = previewIntervalMinutes(deckId, cardId, "easy");

      function formatInterval(minutes) {
        if (minutes < 60) {
          const m = Math.max(1, Math.round(minutes));
          return m + " min";
        }
        const hours = minutes / 60;
        if (hours < 24) {
          const h = Math.max(1, Math.round(hours));
          return h + " hr" + (h === 1 ? "" : "s");
        }
        const days = minutes / MINUTES_PER_DAY;
        if (days < 14) {
          const d = Math.max(1, Math.round(days));
          return d + " day" + (d === 1 ? "" : "s");
        }
        const weeks = days / 7;
        const w = Math.max(1, Math.round(weeks));
        return w + " wk" + (w === 1 ? "" : "s");
      }

      hintHard.textContent = "Next in " + formatInterval(hardMinutes);
      hintGood.textContent = "Next in " + formatInterval(goodMinutes);
      hintEasy.textContent = "Next in " + formatInterval(easyMinutes);
    }

    function runSilentLoop() {
      if (isPaused) {
        setStatus("Paused.");
        return;
      }
      const deck = getDeckById(currentDeckId);
      if (!deck || deck.cards.length === 0) {
        setStatus("This deck has no cards.");
        silentQuestionText.textContent = "";
        silentQuestion.classList.remove("hidden");
        silentAnswer.classList.add("hidden");
        showAnswerBtn.classList.remove("hidden");
        silentRatingButtons.classList.add("hidden");
        silentNextCardBtn.classList.add("hidden");
        clearSilentHints();
        silentCompletionControls.classList.add("hidden");
        silentEditPanel.classList.add("hidden");
        setStudyState(StudyState.IDLE);
        return;
      }
      const allowAhead = studyAheadSession;
      const includeOverdue = !noScheduleChanges;
      const lastId = currentCard ? currentCard.id : null;

      let nextCard = null;

      // Study-ahead (no schedule changes) uses aheadQueue
      if (noScheduleChanges && allowAhead) {
        if (!aheadQueue || aheadQueue.length === 0) {
          aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
          aheadQueueIndex = 0;
        }
        if (aheadQueueIndex < aheadQueue.length) {
          nextCard = aheadQueue[aheadQueueIndex++];
        } else {
          nextCard = null;
        }
      } else {
        // Normal schedule-changing mode (silent) with randomized mixing
        const dueCards = getDueCardsForDeck(currentDeckId, false, includeOverdue);
const { overdue, due } = splitOverdueAndDue(currentDeckId, dueCards);

if (overdue.length > 0) {
  nextCard = pickRandomNextCardNormal(overdue, lastId, true);
} else {
  nextCard = pickRandomNextCardNormal(due, lastId, true);
}
      }

      if (!nextCard && !allowAhead) {
  // Finished all due cards (normal mode)
  if (autoEnterStudyAhead) {
    setStatus("Congratulations, you are all caught up. Entering study ahead mode.");
    studyAheadSession = true;
    noScheduleChanges = true;

    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    silentCompletionControls.classList.add("hidden");
    silentNextCardBtn.classList.remove("hidden");
    setStudyState(StudyState.IDLE);
    runSilentLoop();
    return;
  }

  // Old behavior: show completion controls
  setStatus(
    "Congratulations, you are all caught up, no more cards are due today."
  );
  silentQuestionText.textContent = "";
  silentQuestion.classList.add("hidden");
  silentAnswer.classList.add("hidden");
  showAnswerBtn.classList.add("hidden");
  silentRatingButtons.classList.add("hidden");
  silentNextCardBtn.classList.add("hidden");
  clearSilentHints();
  pauseBtn.classList.add("hidden");
  resumeBtn.classList.add("hidden");
  silentCompletionControls.classList.remove("hidden");
  silentEditPanel.classList.add("hidden");
  setStudyState(StudyState.IDLE);
  return;
} else if (!nextCard && allowAhead) {
  // Finished all cards in study-ahead mode
  if (noScheduleChanges && studyAheadSession && loopStudyAhead) {
    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    if (aheadQueue.length > 0) {
      setStudyState(StudyState.IDLE);
      runSilentLoop();
      return;
    }
    // fall through if somehow there are still no cards
  }

  setStatus("There are no more cards available to study in this deck right now.");
  silentQuestionText.textContent = "";
  silentQuestion.classList.add("hidden");
  silentAnswer.classList.add("hidden");
  showAnswerBtn.classList.add("hidden");
  silentRatingButtons.classList.add("hidden");
  silentNextCardBtn.classList.add("hidden");
  clearSilentHints();
  silentCompletionControls.classList.add("hidden");
  silentEditPanel.classList.add("hidden");
  setStudyState(StudyState.IDLE);
  return;
}

      silentCompletionControls.classList.add("hidden");
      silentQuestion.classList.remove("hidden");
      showAnswerBtn.classList.remove("hidden");
      pauseBtn.classList.remove("hidden");
      resumeBtn.classList.remove("hidden");

      currentCard = nextCard;
      setStatus("Studying card...");
      setCardContent(silentQuestionText, currentCard.question);
setCardContent(silentAnswerText, currentCard.answer);
      silentAnswer.classList.add("hidden");
      silentRatingButtons.classList.add("hidden");
      clearSilentHints();
      silentEditPanel.classList.add("hidden");

      setCardContent(voiceQuestionText, currentCard.question);
setCardContent(voiceAnswerText, currentCard.answer);

      if (noScheduleChanges) {
        silentNextCardBtn.classList.remove("hidden");
      } else {
        silentNextCardBtn.classList.add("hidden");
      }

      setStudyState(StudyState.SHOWING_QUESTION);
    }

    showAnswerBtn.addEventListener("click", () => {
      if (!currentCard) return;

      // study-ahead silent: tap once to show answer, second tap goes next
      if (noScheduleChanges && !silentAnswer.classList.contains("hidden")) {
        silentAnswer.classList.add("hidden");
        clearSilentHints();
        setStudyState(StudyState.IDLE);
        runSilentLoop();
        return;
      }

      silentAnswer.classList.remove("hidden");
      setStudyState(StudyState.SHOWING_ANSWER);
      if (noScheduleChanges) {
        silentRatingButtons.classList.add("hidden");
        clearSilentHints();
      } else {
        silentRatingButtons.classList.remove("hidden");
        updateSilentDueHints();
        setStudyState(StudyState.WAITING_FOR_RATING);
      }
    });

    silentNextCardBtn.addEventListener("click", () => {
      if (!currentCard) return;
      silentAnswer.classList.add("hidden");
      clearSilentHints();
      setStudyState(StudyState.IDLE);
      runSilentLoop();
    });

    silentRatingButtons.addEventListener("click", (e) => {
      const btn = e.target;
      if (!btn.dataset.rating || !currentCard) return;
      const ratingKey = btn.dataset.rating;
      if (!noScheduleChanges) {
        const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, ratingKey);
        if (nextState && nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES) {
          queueCardForAgain(currentDeckId, currentCard);
        }
      }
      setStudyState(StudyState.IDLE);
      runSilentLoop();
    });

        // Rating buttons for voice (hands-free) mode ‚Äì optional tap instead of speaking
    if (voiceRatingButtons) {
  voiceRatingButtons.addEventListener("click", (e) => {
    const btn = e.target.closest("button[data-voice-rating]");
    if (!btn || !currentCard) return;

    const ratingKey = btn.dataset.voiceRating;

    clearQuestionDelayTimer();
    clearStudyAheadGapTimer();
    awaitingAnswerSignal = false;
    awaitingDifficulty = false;

    stopAllAudio();

    if (!noScheduleChanges) {
      const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, ratingKey);
      if (nextState && nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES) {
        queueCardForAgain(currentDeckId, currentCard);
      }
    }

    voiceRatingButtons.classList.add("hidden");
    setStudyState(StudyState.IDLE);
    runVoiceLoop();
  });
}

    silentMainMenuBtn.addEventListener("click", () => {
      silentCompletionControls.classList.add("hidden");
      endStudySession();
    });

    silentStudyAheadBtn.addEventListener("click", () => {
      silentCompletionControls.classList.add("hidden");
      studyAheadSession = true;
      noScheduleChanges = true;

      aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
      aheadQueueIndex = 0;

      silentQuestion.classList.remove("hidden");
      showAnswerBtn.classList.remove("hidden");
      pauseBtn.classList.remove("hidden");
      resumeBtn.classList.remove("hidden");
      silentNextCardBtn.classList.remove("hidden");
      runSilentLoop();
    });

    startSilentBtn.addEventListener("click", () => {
      currentDeckId = selectedDeckId;
      if (!currentDeckId) return;
      skipInstructionsAfterFirst = !!skipInstructionsAfterFirstCheckbox.checked;
      autoEnterStudyAhead = !!autoEnterStudyAheadCheckbox.checked;
loopStudyAhead = !!loopStudyAheadCheckbox.checked;

      // Start in normal due-today mode; study-ahead entered from completion controls
      studyAheadSession = false;
      noScheduleChanges = false;
      reviewQueue = [];
      aheadQueue = [];
      aheadQueueIndex = 0;
      silentCompletionControls.classList.add("hidden");
      silentNextCardBtn.classList.add("hidden");

      silentUI.classList.remove("hidden");
      voiceUI.classList.add("hidden");

      showStudySection("silent");
      runSilentLoop();
    });

    // ===================== INIT & AUTO MODE WIRING =====================
    // Disable rating select when automatic mode is off (UX polish)
    autoRatingSelect.disabled = true;
    autoGoodToggle.addEventListener("change", () => {
      autoRatingSelect.disabled = !autoGoodToggle.checked;
    });

    function describeAutoIntro() {
      const desc = describeAutoModeBehavior();
      if (autoModeBehavior === "tomorrow") {
        return "Starting automatic hands free study session. I will read the question, then the answer, and " + desc + ".";
      }
      return "Starting automatic hands free study session. I will read the question, then the answer, and " + desc + ".";
    }

    // >>> MODIFIED: add async + inline mic permission request here <<<
    startVoiceBtn.addEventListener("click", async () => {
      // üîä Browser-only: Request microphone permission first (required in Safari/etc).
      // If we're using the native iOS plugin, it handles mic/speech permissions natively.
      if (!nativeVoicePlugin && !autoGoodMode && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          // Stop tracks immediately; we just needed the permission prompt
          if (stream && stream.getTracks) {
            stream.getTracks().forEach(track => track.stop());
          }
          console.log("Microphone permission requested.");
        } catch (err) {
          console.error("Microphone permission error:", err);
          alert(
            "Microphone access is required for hands-free study in the browser. " +
            "Please enable it in your browser's site settings and try again."
          );
          return; // Stop if user denied
        }
      }

      currentDeckId = selectedDeckId;
      if (!currentDeckId) return;
      autoModeBehavior = autoRatingSelect.value || "good";
      autoGoodMode = !!autoGoodToggle.checked;
      autoEnterStudyAhead = !!autoEnterStudyAheadCheckbox.checked;
loopStudyAhead = !!loopStudyAheadCheckbox.checked;

      // If there is NO native plugin and NO browser STT, and we are not in auto mode,
      // then we can't do voice commands.
      if (!nativeVoicePlugin && !speechSupported && !autoGoodMode) {
        alert("Speech recognition not supported in this environment.");
        return;
      }

      skipInstructionsAfterFirst = !!skipInstructionsAfterFirstCheckbox.checked;
      hasSpokenInstructionsOnce = false;
      // Start in normal "due today" mode; study-ahead is only entered after completion
      studyAheadSession = false;
      noScheduleChanges = false;
      studyAheadPromptedOnceVoice = false;
      reviewQueue = [];
      aheadQueue = [];
      aheadQueueIndex = 0;
      clearStudyAheadGapTimer();
      clearQuestionDelayTimer();
      hasSpokenCurrentQuestion = false;
      hasSpokenCurrentAnswer = false;

      // If auto mode is on, we force delay mode (no STT needed)
      if (autoGoodMode) {
        answerMode = "delay";
      } else {
        answerMode = answerModeVoiceRadio.checked ? "voice" : "delay";
      }

      const secs = parseInt(answerDelaySecondsInput.value, 10);
      answerDelayMs = isNaN(secs)
        ? 4000
        : Math.max(1, Math.min(60, secs)) * 1000;

      const gapSecs = parseInt(studyAheadGapSecondsInput.value, 10);
      studyAheadGapMs = isNaN(gapSecs)
        ? 4000
        : Math.max(1, Math.min(60, gapSecs)) * 1000;

      voiceUI.classList.remove("hidden");
      silentUI.classList.add("hidden");

      showStudySection("voice");
      const intro = autoGoodMode
        ? describeAutoIntro()
        : "Starting hands free study session. I will read a question, then the answer, then ask how hard it was.";
      setStudyState(StudyState.IDLE);
      speak(intro, () => {
        runVoiceLoop();
      });
    });
    // <<< END MODIFIED HANDLER <<<

    if (studyInstructionsBtn) {
  studyInstructionsBtn.addEventListener("click", () => {
    openInstructionsModal();
  });
}

 (async function init() {
  loadFromStorage();

  try {
    const { data: { session }, error } = await supabaseClient.auth.getSession();
    if (error) console.error("getSession error:", error);

    console.log("[app.html] session:", session);
    console.log("[app.html] user:", session?.user);

    if (session?.user) {
      if (typeof loadStateFromSupabase === "function") {
        await loadStateFromSupabase();
        hasLoadedRemote = true;
      } else {
        console.warn("loadStateFromSupabase() missing; skipping remote load.");
        hasLoadedRemote = false;
      }
    } else {
      hasLoadedRemote = false;
    }
  } catch (e) {
    console.error("init remote load failed", e);
    hasLoadedRemote = false;
  }
})();


  </script>
</body>
</html>
