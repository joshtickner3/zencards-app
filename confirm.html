<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ZenCards — Confirming…</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
</head>

<body style="font-family:system-ui;background:#0b1220;color:#e5e7eb;padding:24px;">
  <h2>Confirming your email…</h2>
  <p id="msg">One moment.</p>

  <script>
    const SUPABASE_URL = "https://elpfcnnrripftxoqeckv.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVscGZjbm5ycmlwZnR4b3FlY2t2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4NTk5MzQsImV4cCI6MjA4MDQzNTkzNH0.uiLHVcRfMXu0V7QRW41TARMIy-Hbhovc4h9uYFzzGLQ";

    const msgEl = document.getElementById("msg");
    const setMsg = (t) => { msgEl.textContent = t; console.log("[confirm]", t); };

    const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: false, // we handle parsing ourselves
      },
    });

    function scrubUrl() {
      history.replaceState({}, document.title, window.location.pathname + window.location.search);
    }

    function withTimeout(promise, ms, label) {
      return Promise.race([
        promise,
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error(`${label} timed out after ${ms}ms`)), ms)
        ),
      ]);
    }

    async function createCheckoutAndRedirect(accessToken) {
      setMsg("Email confirmed ✅ Creating checkout session…");

      let res, raw;
      try {
        res = await fetch(`${SUPABASE_URL}/functions/v1/create-checkout-session`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${accessToken}`,
          },
          body: JSON.stringify({
            success_url: "https://zencardstudy.com/app.html",
            cancel_url: "https://zencardstudy.com/app.html?canceled=1",
          }),
        });
        raw = await res.text();
      } catch (e) {
        console.error("Fetch failed:", e);
        setMsg("Checkout request failed (network/CORS). Open console.");
        return;
      }

      let json = null;
      try { json = JSON.parse(raw); } catch {}

      if (!res.ok || !json?.url) {
        console.error("Checkout error:", res.status, raw);
        setMsg(`Checkout failed (${res.status}). ${raw.slice(0, 250)}`);
        return;
      }

      setMsg("Redirecting to Stripe…");
      window.location.href = json.url;
    }

    async function go() {
      setMsg("Finalizing confirmation…");

      const url = new URL(window.location.href);
      const queryParams = url.searchParams;
      const hashParams = new URLSearchParams(url.hash.replace(/^#/, ""));

      // show error if supabase returned one
      const err = hashParams.get("error");
      if (err) {
        const errDesc = hashParams.get("error_description") || "";
        const errCode = hashParams.get("error_code") || "";
        setMsg(`Confirmation error: ${err}${errCode ? " (" + errCode + ")" : ""}${errDesc ? " — " + errDesc : ""}`);
        return;
      }

      // Try FLOW 1: implicit hash session (#access_token / #refresh_token)
      const access_token = hashParams.get("access_token");
      const refresh_token = hashParams.get("refresh_token");

      if (access_token && refresh_token) {
        setMsg("Saving session…");

        try {
          const result = await withTimeout(
            sb.auth.setSession({ access_token, refresh_token }),
            10000,
            "setSession"
          );

          if (result?.error) {
            console.error("setSession error:", result.error);
            setMsg("setSession error: " + (result.error.message || JSON.stringify(result.error)));
            return;
          }

          scrubUrl();
          await new Promise(r => setTimeout(r, 250));
        } catch (e) {
          console.error("setSession threw/hung:", e);
          setMsg("setSession failed: " + (e?.message || String(e)));
          return;
        }
      } else {
        // Try FLOW 2: PKCE code (?code=...)
        const code = queryParams.get("code");
        if (code) {
          setMsg("Finishing sign-in…");
          const { error } = await sb.auth.exchangeCodeForSession(code);
          if (error) {
            console.error("exchangeCodeForSession error:", error);
            setMsg("exchangeCodeForSession error: " + (error.message || JSON.stringify(error)));
            return;
          }
          scrubUrl();
          await new Promise(r => setTimeout(r, 250));
        } else {
          // Try FLOW 3: token_hash + type
          const token_hash = queryParams.get("token_hash") || hashParams.get("token_hash");
          const type = queryParams.get("type") || hashParams.get("type");
          if (token_hash && type) {
            setMsg("Verifying…");
            const { error } = await sb.auth.verifyOtp({ token_hash, type });
            if (error) {
              console.error("verifyOtp error:", error);
              setMsg("verifyOtp error: " + (error.message || JSON.stringify(error)));
              return;
            }
            scrubUrl();
            await new Promise(r => setTimeout(r, 250));
          } else {
            setMsg("Missing tokens/code in confirmation link. Please request a new link.");
            return;
          }
        }
      }

      // Now retrieve session
      setMsg("Checking session…");
      const { data: sessionData, error: sessErr } = await sb.auth.getSession();
      if (sessErr) {
        console.error("getSession error:", sessErr);
        setMsg("getSession error: " + (sessErr.message || JSON.stringify(sessErr)));
        return;
      }

      const token = sessionData?.session?.access_token;
      if (!token) {
        setMsg("Email verified but no session token found. Please log in again.");
        return;
      }

      await createCheckoutAndRedirect(token);
    }

    go().catch((e) => {
      console.error(e);
      setMsg("Something went wrong: " + (e?.message || String(e)));
    });
  </script>
</body>
</html>