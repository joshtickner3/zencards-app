<!DOCTYPE html>
<html lang="en">
<head>
    <style>
  .instructions-top-right {
    position: static;
    display: flex;
    justify-content: center;
    margin: 0.35rem 0 0.9rem;
    z-index: auto;
  }
  .instructions-top-right button{
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
  }
</style>
    <!-- Capacitor Preferences for robust session persistence on iOS -->
    <script type="module">
      import { Preferences } from '@capacitor/preferences';
      // Restore Supabase session from native storage before anything else
      (async function restoreSupabaseSession() {
        // Only run in native app
        const isNative = !!window.Capacitor || !!window.cordova || !!window.webkit?.messageHandlers?.bridge;
        if (!isNative) return;
        try {
          const { value } = await Preferences.get({ key: 'zencards-auth' });
          if (value) {
            localStorage.setItem('zencards-auth', value);
          }
        } catch (e) {
          console.warn('[Capacitor] Could not restore session from Preferences:', e);
        }
      })();
    </script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <meta charset="UTF-8" />
  <link rel="icon" href="favicon.png" />
  <link rel="shortcut icon" href="favicon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="favicon.png" />
  <meta property="og:title" content="Live Life to the Fullest as a Student" />
  <meta property="og:image" content="favicon.png" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Live Life to the Fullest as a Student" />
  <meta name="twitter:image" content="favicon.png" />
  <title>Live Life to the Fullest as a Student</title>
  <script>
    // --- Persist and Restore Study Settings ---
    function saveStudySettings() {
      const settings = {
        deck: document.getElementById('deckSelect')?.value || '',
        ttsRate: document.getElementById('ttsRateInput')?.value || '',
        ttsVolume: document.getElementById('ttsVolumeInput')?.value || '',
        bgMusicMuted: document.getElementById('bgMusicMute')?.checked || false,
        bgMusicVolume: document.getElementById('bgMusicVolume')?.value || '',
        // Add more as needed (e.g., mode, delay)
      };
      localStorage.setItem('zencards_study_settings', JSON.stringify(settings));
    }

    function restoreStudySettings() {
      const settings = JSON.parse(localStorage.getItem('zencards_study_settings') || '{}');
      if (settings.deck && document.getElementById('deckSelect')) {
        document.getElementById('deckSelect').value = settings.deck;
      }
      if (settings.ttsRate && document.getElementById('ttsRateInput')) {
        document.getElementById('ttsRateInput').value = settings.ttsRate;
      }
      if (settings.ttsVolume && document.getElementById('ttsVolumeInput')) {
        document.getElementById('ttsVolumeInput').value = settings.ttsVolume;
      }
      if (typeof settings.bgMusicMuted === 'boolean' && document.getElementById('bgMusicMute')) {
        document.getElementById('bgMusicMute').checked = settings.bgMusicMuted;
      }
      if (settings.bgMusicVolume && document.getElementById('bgMusicVolume')) {
        document.getElementById('bgMusicVolume').value = settings.bgMusicVolume;
      }
      // Add more as needed
    }

    document.addEventListener('DOMContentLoaded', () => {
      restoreStudySettings();
      // Save on change
      ['deckSelect','ttsRateInput','ttsVolumeInput','bgMusicMute','bgMusicVolume'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('change', saveStudySettings);
      });
    });
    // Prevent double-tap to zoom on iOS
    (function() {
      let lastTouchEnd = 0;
      document.addEventListener('touchend', function(event) {
        const now = Date.now();
        if (now - lastTouchEnd <= 350) {
          event.preventDefault();
        }
        lastTouchEnd = now;
      }, { passive: false });
    })();
  </script>
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=yes, maximum-scale=5.0"
/>
  <!-- MathJax for rendering LaTeX equations in cards -->
   <script>
    console.log("APP VERSION:", "2026-01-04 10:33am");
    
  window.MathJax = {
    startup: {
      ready: () => {
        console.log("MathJax ready");
        MathJax.startup.defaultReady();
      }
    }
  };


document.addEventListener('visibilitychange', function() {
  if (document.hidden) {
    // App is backgrounded
    if (!isPaused && currentMode === 'voice') {
      // Robust pause logic: match button/voice command
      isPaused = true;
      if (currentCard) window.restartCardOnResumeVoice = true;
      stopAllAudio();
      clearStudyAheadGapTimer();
      clearQuestionDelayTimer();
      clearAnswerAfterSpeechDelay();
      if (typeof pauseBtn !== 'undefined') pauseBtn.disabled = true;
      if (typeof resumeBtn !== 'undefined') resumeBtn.disabled = false;
      setStatus('Paused study session. Say "resume study session" or tap Resume.');
      speakSafe('Paused study session.', () => {
        listenForCommand(handleVoiceTranscript);
      });
    }
  } else {
    // App is foregrounded
    if (currentMode === 'voice' && isPaused) {
      isPaused = false;
      if (typeof pauseBtn !== 'undefined') pauseBtn.disabled = false;
      if (typeof resumeBtn !== 'undefined') resumeBtn.disabled = true;
      if (window.restartCardOnResumeVoice && currentCard) {
        window.restartCardOnResumeVoice = false;
        restartCurrentCardVoiceFlow();
      } else {
        runVoiceLoop();
      }
    }
  }
});
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter+Tight:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root{
  --bg1:#0b1222;
  --bg2:#020617;
  --bg3:#0a1224;
    /* ===== iOS safe-area handling (app only) ===== */
  --appSafeTop: env(safe-area-inset-top, 0px);
  --userBarTopPad: 14px;     /* breathing room below notch */
  --topBarClearance: 110px; /* keeps content from hiding behind fixed bar */


  --card: rgba(9,16,30,0.92);
  --border: rgba(148,163,184,0.12);

  --text:#eef2ff;
  --muted:#9aa8bf;

  --accent:#22d3ee;
  --accent2:#38bdf8;
  --green:#22c55e;
  --green2:#16a34a;

  --slate:#334155;
  --shadow: 0 18px 35px rgba(2,6,23,0.6), 0 0 0 1px rgba(148,163,184,0.08);
}
@media (max-width: 430px){
  :root{
    --userBarTopPad: 18px;
    --topBarClearance: 125px;
  }
}

  .brandLogo{
  height: clamp(56px, 7vw, 92px); /* grows on desktop, safe on small screens */
  width: auto;
  display: block;
}
    /* ===== Top-left signed-in bar ===== */
.topUserBar {
  position: fixed;
  top: calc(env(safe-area-inset-top, 0px) + 12px);
  left: 14px;
  z-index: 12000;

  background: rgba(2, 6, 23, 0.86);
  border: 1px solid #1f2937;
  border-radius: 14px;
  padding: 10px 12px;

  box-shadow: 0 18px 35px rgba(0,0,0,0.55);
  max-width: calc(100% - 28px);
}

.topUserBar .signedInLine {
  margin: 0 0 6px 0;
  font-size: 0.95rem;
  color: #e5e7eb;
}

.topUserBar .btnRow {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
   justify-content: center; /* ‚úÖ centers the buttons */
}

.topUserBar button {
  margin: 0; /* important: override your default button margin */
}

    /* Hide Sign Up button on app.html (users sign up on landing) */
#signUpBtn {
  display: none !important;
}
#authLoggedOut .row {
  justify-content: center;
}

    *{ box-sizing: border-box; }
    body{
  margin:0;
  padding:1.25rem;
  padding-top: calc(var(--topBarClearance) + env(safe-area-inset-top, 0px));
  font-family: "Inter Tight", -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
  color-scheme: dark;
  background:
    radial-gradient(800px 400px at 20% -10%, rgba(56,189,248,0.12), transparent 55%),
    radial-gradient(700px 380px at 85% -5%, rgba(34,211,238,0.12), transparent 60%),
    linear-gradient(160deg, var(--bg1), var(--bg2));
  color: var(--text);
  line-height:1.55;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  letter-spacing: -0.011em;
}
::selection{
  background: rgba(34,211,238,0.32);
  color: #001018;
}
    h1, h2, h3 {
      margin: 0.55rem 0;
      font-weight: 700;
      letter-spacing: 0.01em;
    }
    h2 { font-size: 1.35rem; }
    h3 { font-size: 1.05rem; color: #e2e8f0; }

    button:disabled {
  opacity: 0.45;
  cursor: not-allowed;
}
   
/* Logo header blending panel */
.appHeader{
  display:flex;
  align-items:center;
  justify-content:center;
  margin-bottom:0.12rem;
  padding: 10px 12px;
  border-radius: 16px;

  /* This is the "match" layer behind the logo */
  background:
    radial-gradient(circle at 50% 20%, rgba(56,189,248,0.12), rgba(2,6,23,0) 60%),
    linear-gradient(90deg, rgba(2,6,23,0.0), rgba(15,23,42,0.6), rgba(2,6,23,0.0));

  border: 1px solid rgba(148,163,184,0.18);
  box-shadow: 0 20px 40px rgba(2,6,23,0.45);
  width: fit-content;
  margin-left:auto;
  margin-right:auto;

  /* helps blend if your logo has subtle edges */
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}

.brandLogo{
  height: clamp(56px, 7vw, 92px);
  width: auto;
  display:block;
  /* mix-blend-mode: lighten;  <-- optional, only if you want it */
}

    .logoMark {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.9);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      background: radial-gradient(circle at 30% 0%, #22c55e 0, #22c55e22 45%, #020617 70%);
      box-shadow: 0 8px 18px rgba(15,23,42,0.9);
      color: #e5e7eb;
      flex-shrink: 0;
    }
    .appTitle {
      text-align: center;
      font-size: 1.9rem;
      letter-spacing: 0.04em;
    }
    .appSubtitle {
      text-align: center;
      font-size: 0.95rem;
      color: var(--muted);
      margin-top: 0.05rem;
      margin-bottom: 0.6rem;
    }
    .container {
      max-width: 980px;
      margin: 0 auto;
    }
    .card{
  background: linear-gradient(180deg, rgba(10,18,36,0.95), rgba(3,7,18,0.9));
  border-radius: 1rem;
  padding: 1.1rem 1.15rem;
  margin-top: 1rem;
  border: 1px solid var(--border);
  box-shadow: var(--shadow);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}
.card:hover{
  transform: translateY(-3px);
  box-shadow: 0 24px 50px rgba(2,6,23,0.72), 0 0 0 1px rgba(148,163,184,0.14);
}
    label {
      display: inline-block;
      margin: 0.25rem 0;
      font-size: 0.9rem;
    }
    input[type="text"], textarea, select, input[type="number"]{
  width:100%;
  padding:0.65rem 0.75rem;
  border-radius:0.7rem;
  border:1px solid rgba(148,163,184,0.18);
  background: linear-gradient(180deg, rgba(2,6,23,0.7), rgba(2,6,23,0.5));
  color:var(--text);
  box-sizing:border-box;
  font-size:0.92rem;
  transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
}
input::placeholder, textarea::placeholder{
  color: rgba(148,163,184,0.7);
}
    input[type="text"]:focus,
textarea:focus,
select:focus,
input[type="number"]:focus{
  outline:none;
  border-color: rgba(34,197,94,0.55);
  box-shadow: 0 0 0 3px rgba(34,197,94,0.12);
}
    textarea {
      min-height: 60px;
    }
    textarea.drag-hover {
  outline: 2px dashed #22c55e;
}

    button {
      margin: 0.25rem 0.25rem 0.25rem 0;
      padding: 0.55rem 1.3rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: #001018;
      font-weight: 700;
      font-size: 0.95rem;
      transition:
        background 0.2s ease,
        transform 0.08s ease,
        box-shadow 0.2s ease;
      box-shadow: 0 10px 24px rgba(56,189,248,0.28);
    }
    button:focus-visible,
input[type="text"]:focus-visible,
textarea:focus-visible,
select:focus-visible,
input[type="number"]:focus-visible{
  outline: none;
  box-shadow: 0 0 0 3px rgba(56,189,248,0.25);
}
    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 14px 28px rgba(56,189,248,0.4);
    }
    button:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(15,23,42,0.6);
    }
    button.secondary {
      background: linear-gradient(180deg, rgba(148,163,184,0.18), rgba(148,163,184,0.1));
      color: #e2e8f0;
      box-shadow: none;
      border: 1px solid rgba(148,163,184,0.22);
    }
    button.secondary:hover:not(:disabled) {
      background: rgba(148,163,184,0.22);
      box-shadow: 0 8px 16px rgba(2,6,23,0.55);
      transform: translateY(-1px);
    }
    button.small {
      padding: 0.25rem 0.7rem;
      font-size: 0.8rem;
    }
    button:disabled {
      background: #374151;
      cursor: default;
      box-shadow: none;
      opacity: 0.7;
    }
    .btn-disabled{
      pointer-events: none;
    }
    #voiceSkipToAnswerBtn:disabled{
      background: #374151;
      color: #9ca3af;
      border: 1px solid rgba(148,163,184,0.25);
      box-shadow: none;
      opacity: 0.65;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
    }
/* Decks layout fix for mobile */
.deckRow {
  align-items: flex-start;
}

@media (max-width: 600px) {
  .deckRow {
    flex-direction: column;
  }
  .deckRow > * {
    width: 100%;
  }
}

    .row > * {
      flex: 1;
      min-width: 0;
    }
    .inline {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      margin-right: 0.75rem;
    }
    .badge {
      display: inline-block;
      padding: 0.2rem 0.55rem;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(148,163,184,0.22), rgba(148,163,184,0.1));
      font-size: 0.75rem;
      margin-left: 0.25rem;
      color: #e2e8f0;
      border: 1px solid rgba(148,163,184,0.18);
    }
    .dueCount{
      color: #f87171;
      font-weight: 700;
    }
    #status {
      margin-top: 0.75rem;
      font-size: 0.9rem;
      color: #9ca3af;
      min-height: 1.2em;
    }
    #cardsList {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 0.6rem;
      border-top: 1px solid rgba(148,163,184,0.18);
      padding-top: 0.6rem;
      scrollbar-gutter: stable;
    }
    #cardsList::-webkit-scrollbar{
      width: 10px;
    }
    #cardsList::-webkit-scrollbar-thumb{
      background: rgba(148,163,184,0.25);
      border-radius: 999px;
      border: 2px solid rgba(2,6,23,0.8);
    }
    .cardRow {
      padding: 0.45rem 0.35rem;
      border-bottom: 1px solid rgba(148,163,184,0.08);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
      border-radius: 0.6rem;
      transition: background 0.15s ease, transform 0.12s ease;
    }
    .cardRow:hover {
      background: rgba(148,163,184,0.08);
      transform: translateY(-1px);
    }
    /* Horizontal rating layout */
.ratingRow {
  display: flex;
  gap: 0.6rem;
  flex-wrap: wrap;          /* wraps nicely on small screens */
  align-items: flex-start;
  margin-top: 0.5rem;
}

.ratingItem {
  display: flex;
  flex-direction: column;   /* button on top, hint under it */
  gap: 0.25rem;
}

.ratingItem .dueHint {
  margin: 0;                /* remove extra spacing */
}

    #cardsHeader {
  padding: 0.25rem 0;
      border-top: 1px solid rgba(148,163,184,0.18);
      border-bottom: 1px solid rgba(148,163,184,0.18);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.8rem;
  color: #9ca3af;
  text-transform: uppercase;
  letter-spacing: 0.06em;
}

#cardsHeader span:first-child {
  flex: 1;
  min-width: 0;
}

#cardsHeader .dueDateCell {
  flex: 0 0 130px;
  text-align: center;
  white-space: nowrap;
}

.cardRow .dueDateCell {
  flex: 0 0 130px;
  text-align: center;
  white-space: nowrap;
  font-size: 0.75rem;
  color: #9ca3af;
}
/* Visually mark overdue cards in the card list */
.cardRow.overdue .dueDateCell {
  color: #f97373;
  font-weight: 600;
}

.cardRow.overdue span:first-child {
  color: #f97373;
}

.cardActions {
  display: flex;
  gap: 0.25rem;
  flex: 0 0 auto;
}
    .cardRow span {
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: #e5e7eb;
    }
    .cardRow:hover span {
      color: #a5b4fc;
    }
    .hidden {
      display: none;
    }
    /* ===== Modal styling ===== */
.modal {
  position: fixed;
  inset: 0;
  z-index: 9999;
}
/* Prevent iOS zoom on input focus in modals */
.modal input, .modal select, .modal textarea {
  font-size: 16px !important;
}

.modalBackdrop {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.6);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
  animation: fadeIn 160ms ease-out;
}

    .modalCard {
  position: relative;
  width: min(720px, calc(100% - 2rem));
  margin: 10vh auto;
  background: rgba(2,6,23,0.96);
  border: 1px solid rgba(148,163,184,0.2);
  border-radius: 1rem;
  padding: 1.1rem;
  box-shadow: 0 25px 60px rgba(0,0,0,0.6);
  animation: slideUp 180ms ease-out;
}
    #studySection {
      margin-top: 1rem;
    }
    /* Flashcard flip UI */
    .flashcard{
      margin: 1rem auto 0;
      perspective: 1200px;
      width: min(92vw, 760px);
      height: clamp(260px, 38vh, 420px);
    }
    .flashcard-inner{
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 480ms ease;
      transform-style: preserve-3d;
    }
    .flashcard.flipped .flashcard-inner{
      transform: rotateX(180deg);
    }
    .flashcard-face{
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      padding: 1.2rem 1.35rem;
      background: linear-gradient(180deg, rgba(2,6,23,0.95), rgba(2,6,23,0.75));
      border-radius: 1rem;
      border: 1px solid rgba(148,163,184,0.18);
      overflow: auto;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      animation: softIn 180ms ease-out;
    }
    .flashcard-back{
      transform: rotateX(180deg);
    }
    .flashcard-label{
      font-size: 0.75rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(148,163,184,0.8);
      margin-bottom: 0.45rem;
      text-align: center;
      width: 100%;
    }
    #voiceQuestionText,
    #voiceAnswerText,
    #silentQuestionText,
    #silentAnswerText{
      flex: 1 1 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: clamp(1.05rem, 1.4vw + 0.7rem, 1.6rem);
      line-height: 1.45;
      width: 100%;
    }
@keyframes fadeIn{
  from{ opacity:0; }
  to{ opacity:1; }
}
@keyframes slideUp{
  from{ opacity:0; transform: translateY(10px) scale(0.99); }
  to{ opacity:1; transform: translateY(0) scale(1); }
}
@keyframes softIn{
  from{ opacity:0; transform: translateY(6px); }
  to{ opacity:1; transform: translateY(0); }
}
@media (prefers-reduced-motion: reduce){
  *{ animation-duration: 0.01ms !important; animation-iteration-count: 1 !important; transition-duration: 0.01ms !important; }
}
    #modeBadge {
      font-size: 0.8rem;
      margin-left: 0.5rem;
    }
    .dueHint {
      display: block;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.35rem;
    }
/* ===== app.html: make the top signed-in bar feel clean on small screens ===== */
@media (max-width: 430px){
  .topUserBar{
  top: calc(env(safe-area-inset-top, 0px) + 10px);
    left: 10px;
    right: 10px;                 /* allows it to size nicely */
    max-width: none;             /* override max-width calc */
    padding: 8px 10px;
    border-radius: 14px;
  }

  .topUserBar .signedInLine{
    font-size: 0.85rem;
    margin: 0 0 6px 0;
    line-height: 1.2;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;     /* prevents long emails from blowing layout */
  }

  .topUserBar .btnRow{
    gap: 6px;
  }

  .topUserBar .btnRow button{
    padding: 0.28rem 0.7rem;     /* smaller pill buttons */
    font-size: 0.82rem;
  }

  /* Important: remove your global button margins inside this bar
     so it never "double spaces" and pushes off-screen */
  .topUserBar button{
    margin: 0 !important;
  }
}

/* ===== app.html: prevent top UI from covering your header content ===== */
:root{
  --topBarClearance: 86px;  /* default space reserved for fixed top bar */
}

@media (max-width: 430px){
  :root{
    --topBarClearance: 98px; /* a bit more room because buttons may wrap */
  }
}

/* Push the main app content down so the fixed bar doesn't overlap */

  </style>
</head>
<body>
    <div>
  </div>
</div>

  <!-- Top-left signed-in bar -->

<div id="authLoggedIn" class="topUserBar hidden">
  <p class="signedInLine">
    Signed in as <strong id="userEmailLabel"></strong>
  </p>
  <div class="btnRow">
    <button id="logOutBtn" class="secondary small">Log Out</button>
    <button id="manageBillingBtn" class="small">Manage Billing</button>
    <button class="btn danger small" id="deleteAccountBtn" type="button" style="background:#dc2626;color:#fff;">Delete Account</button>
  </div>
</div>

   <div class="appHeader">
  <img src="zencards-logo.png" alt="ZenCards logo" class="brandLogo" />
</div>

    <p class="appSubtitle">Live the student experience to the fullest</p>

        <div class="instructions-top-right">
  <button id="openInstructionsBtn" class="secondary small" type="button">
    Instructions / Voice Commands
  </button>
</div>

    <!-- ========== MAIN SETTINGS / MENU ========== -->
    <div id="mainMenu" class="card">
      <h2>Main Menu</h2>

      <!-- Deck controls -->
      <div class="card">
        <h3>Decks</h3>
          <div class="row deckRow">
          <div>
            <label for="deckSelect">Select deck:</label>
            <select id="deckSelect"></select>
          </div>
          <div style="flex:0 0 auto;">
            <button id="editDeckNameBtn" class="secondary">Edit Deck Name</button>
          </div>
          <div>
            <label for="newDeckName">New deck name:</label>
            <input id="newDeckName" type="text" placeholder="e.g. Bio, Anatomy, etc." />
          </div>
          <div style="flex:0 0 auto;">
            <button id="addDeckBtn">Add Deck</button>
            <!-- Delete deck button -->
            <button id="deleteDeckBtn" class="secondary">Delete Deck</button>
          </div>
        </div>
        <!-- Legend for counts -->
        <p style="font-size:0.8rem;color:#9ca3af;margin-top:0.35rem;">
  Legend: <em>Deck name (new / learning / <span class="dueCount">due today</span>)</em>
</p>
        <p id="deckCountsDisplay" style="font-size:0.8rem;color:#9ca3af;margin-top:0.25rem;"></p>
      </div>

      <!-- Card editor / viewer -->
      <div class="card">
        <h3>Card Viewer & Editor</h3>
        <div class="row">
         <div>
  <div>
  <label for="cardQuestionLang">Question language (TTS):</label>
  <select id="cardQuestionLang"></select>

  <label for="cardQuestion">Question:</label>
  <textarea id="cardQuestion" placeholder="Enter question" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>

  <div style="margin-top:0.25rem;font-size:0.8rem;">
    <button type="button" class="secondary small" data-insert-image data-target="cardQuestion">
      Insert image‚Ä¶
    </button>
    <span style="color:#9ca3af;">
      (Paste URL, choose file, or drag &amp; drop an image here)
    </span>
  </div>
</div>

<div>
  <label for="cardAnswerLang">Answer language (TTS):</label>
  <select id="cardAnswerLang"></select>

  <label for="cardAnswer">Answer:</label>
  <textarea id="cardAnswer" placeholder="Enter answer" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>

  <div style="margin-top:0.25rem;font-size:0.8rem;">
    <button type="button" class="secondary small" data-insert-image data-target="cardAnswer">
      Insert image‚Ä¶
    </button>
    <span style="color:#9ca3af;">
      (Paste URL, choose file, or drag &amp; drop an image here)
    </span>
  </div>
</div>

</div>
  <!-- Only one Insert image button for answer field -->
        </div>
        <div class="row">
          <div style="flex:0 0 auto;">
            <button id="addCardBtn">Add Card</button>
            <button id="updateCardBtn" class="secondary" disabled>Update Selected Card</button>
          </div>
          <div>
            <span id="selectedCardInfo" style="font-size:0.85rem;color:#9ca3af;"></span>
          </div>
        </div>
        <!-- Move card to another deck -->
<div class="row" style="margin-top:0.5rem;">
  <div>
    <label for="moveDeckSelect">Move selected card to deck (edit a card to select it):</label>
    <select id="moveDeckSelect"></select>
  </div>
  <div style="flex:0 0 auto;">
    <button id="moveCardBtn" class="secondary" disabled>Move Card</button>
  </div>
</div>
                <!-- Cards table header -->
        <div id="cardsHeader">
          <span>Question</span>
          <span class="dueDateCell">Due date</span>
          <span style="flex:0 0 auto;text-align:right;">Actions</span>
        </div>
        <div id="cardsList"></div>

        <!-- NEW: Import from Anki block -->
        <div style="margin-top:0.75rem;border-top:1px solid #111827;padding-top:0.5rem;">
          <label for="ankiImport" style="display:block;margin-bottom:0.25rem;">
            Import from Anki (TSV export):
          </label>
          <input id="ankiImport" type="file" accept=".txt,.tsv,.csv" />
          <button id="ankiImportHelpBtn" class="secondary small" type="button">How?</button>
          <span id="ankiImportStatus" style="font-size:0.8rem;color:#9ca3af;margin-left:0.5rem;"></span>
        </div>
      </div>

      <!-- Study options -->
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;">
          <h3>Study Options</h3>
          <div style="flex:0 0 auto;text-align:right;">
            <button id="toggleStudyOptionsBtn" class="secondary small" type="button">Show</button>
          </div>
        </div>
        <div id="studyOptionsPanel" class="hidden" style="margin-top:0.5rem;">
          <div>
            <label class="inline">
              <input type="checkbox" id="skipInstructionsAfterFirst" checked />
              Skip difficulty instructions after first card
            </label>
          </div>
          <!-- Automatic mode -->
          <div>
            <label class="inline">
              <input type="checkbox" id="autoGoodToggle" />
              Enable automatic mode so each card is assigned
              <select id="autoRatingSelect" style="width:auto;min-width:120px;">
                <option value="again">Again</option>
                <option value="hard">Hard</option>
                <option value="good" selected>Good</option>
                <option value="easy">Easy</option>
                <option value="tomorrow">Show again tomorrow</option>
              </select>
              <span class="badge">New</span>
            </label>
          </div>
          <div style="margin-top:0.5rem;">
            <label class="inline" for="handsFreeNextDelaySeconds">
              Delay after rating before next question
            </label>
            <input type="number" id="handsFreeNextDelaySeconds" min="3" max="30" value="3" style="width:60px;" />
            <span>seconds</span>
          </div>
          <div style="margin-top:0.5rem;">
            <label class="inline" for="answerToRatingDelaySeconds">
              Delay after answer before rating prompt
            </label>
            <input type="number" id="answerToRatingDelaySeconds" min="3" max="30" value="5" style="width:60px;" />
            <span>seconds</span>
          </div>
          <!-- NEW: auto study-ahead options -->
          <div style="margin-top:0.5rem;">
            <label class="inline">
              <input type="checkbox" id="autoEnterStudyAhead" checked />
              After I finish all due cards, automatically enter study-ahead mode
            </label>
          </div>
          <div>
            <label class="inline">
              <input type="checkbox" id="loopStudyAhead" checked />
              In study-ahead mode, keep looping the deck automatically
            </label>
          </div>
          <div style="margin-top:0.5rem;">
            <strong>Hands-free answer behavior:</strong>
            <div class="row" style="margin-top:0.25rem;">
              <div class="inline">
                <input type="radio" name="answerMode" id="answerModeDelay" value="delay" />
                <label for="answerModeDelay">Wait</label>
                <input type="number" id="answerDelaySeconds" min="3" max="60" value="10" style="width:60px;" />
                <span>seconds before answer</span>
              </div>
              <div class="inline">
                <input type="radio" name="answerMode" id="answerModeVoice" value="voice" checked />
                <label for="answerModeVoice">Play answer after I speak</label>
              </div>
            </div>
          </div>
          <!-- NEW: study-ahead answer gap control -->
          <div style="margin-top:0.5rem;">
            <label class="inline" for="studyAheadGapSeconds">
              Study-ahead: delay after answer before next question
            </label>
            <input type="number" id="studyAheadGapSeconds" min="3" max="60" value="6" style="width:60px;" />
            <span>seconds</span>
          </div>
          <!-- NEW: Restate question in answer for better retention -->
          <div style="margin-top:0.5rem;">
            <label class="inline">
              <input type="checkbox" id="restateQuestionInAnswer" checked />
              Restate question as statement before answer (improves retention)
              <span class="badge">New</span>
            </label>
          </div>
          <!-- NEW: Disable opening prompt -->
          <div style="margin-top:0.5rem;">
            <label class="inline">
              <input type="checkbox" id="disableOpeningPrompt" />
              Disable opening prompt (skip intro, start with first question)
            </label>
          </div>
        </div>
      </div>

      <!-- NEW: Audio & Voice Settings (collapsible section) -->
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;">
          <h3>Audio &amp; Voice Settings</h3>
          <div style="flex:0 0 auto;text-align:right;">
            <button id="toggleAudioSettingsBtn" class="secondary small" type="button">Show</button>
          </div>
        </div>
        <div id="audioSettingsPanel" class="hidden" style="margin-top:0.5rem;">
          <div>
            <label for="ttsRateInput">
              TTS speed (0.5 = slower, 1.0 = normal, 2.0 = faster)
            </label>
            <input
              type="number"
              id="ttsRateInput"
              min="0.5"
              max="2"
              step="0.1"
              value="0.75"
            />
          </div>

          <div style="margin-top:0.5rem;">
  <label for="answerDelayAfterSpeechSecInput">
    Answer delay after I stop speaking (seconds)
    <br />
    <small style="opacity:0.7;">
      0 = instant (default). Any speech resets the timer.
    </small>
  </label>
  <input
    type="number"
    id="answerDelayAfterSpeechSecInput"
    min="0"
    max="30"
    step="1"
    value="5"
  />
</div>

          <div style="margin-top:0.5rem;">
            <label for="ttsVolumeInput">
              TTS volume (0 = mute, 1 = max)
            </label>
            <input
              type="number"
              id="ttsVolumeInput"
              min="0"
              max="1"
              step="0.05"
              value="1.0"
            />
          </div>

          <div style="margin-top:0.5rem;">
            <label>Background music</label>
            <div class="row" style="align-items:center;gap:0.75rem;flex-wrap:wrap;">
              <label class="inline" for="bgMusicMute">
                <input type="checkbox" id="bgMusicMute" />
                Mute background music
              </label>
              <div class="inline" style="gap:0.35rem;">
                <label for="bgMusicVolume">Volume</label>
                <input
                  type="range"
                  id="bgMusicVolume"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.04"
                />
                <span id="bgMusicVolumeValue">0.04</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <audio id="bgMusic" src="Zen-Meditation.mp3" loop preload="auto"></audio>
      <div style="text-align:center;font-size:0.7rem;color:#64748b;margin-top:0.5rem;opacity:0.6;">
        Music: "Zen meditation" by yura.megis
      </div>

      <!-- Study mode buttons -->
      <div class="card">
        <h3>Start Studying</h3>
        <div class="row">
          <button id="startVoiceBtn">Start Hands-Free Study</button>
          <button id="startSilentBtn" class="secondary">Start Silent Study</button>

        </div>

        <p style="font-size:0.85rem;color:#9ca3af;margin-top:0.5rem;">
          Voice commands (hands-free): "again", "hard", "good", "easy", "go to the next card",
          "repeat question", "repeat answer", "pause study session", "show answer", "skip to answer",
          "resume study session", "main menu", "mute microphone".
        </p>
      </div>
    </div>

    <!-- ========== STUDY SECTION ========== -->
    <div id="studySection" class="card hidden">
      <div class="row" style="justify-content:space-between;">
        <h2 style="margin:0;">
  Study Session
  <span id="modeBadge" class="badge"></span>
  <span id="deckBadge" class="badge" style="margin-left:0.5rem;"></span>
</h2>
        <div>
            <button id="studyAddCardBtn" class="secondary small">Add Card</button>
          <button id="backToMenuBtn" class="secondary small">Main Menu</button>
          <button id="pauseBtn" class="secondary small">Pause</button>
          <button id="resumeBtn" class="secondary small" disabled>Resume</button>
        </div>
      </div>
      <div id="status"></div>

      <!-- Voice mode UI (visual front/back during hands-free) -->
      <div id="voiceUI" class="hidden">
        <div id="voiceFlashcard" class="flashcard">
          <div class="flashcard-inner">
            <div id="voiceQuestion" class="flashcard-face flashcard-front">
              <div class="flashcard-label">Question</div>
              <div id="voiceQuestionText"></div>
            </div>
            <div id="voiceAnswer" class="flashcard-face flashcard-back">
              <div class="flashcard-label">Answer</div>
              <div id="voiceAnswerText"></div>
            </div>
          </div>
        </div>
        <div id="micMuteTimer" class="hidden" style="margin-top:0.5rem;">
  <span class="badge">
    Mic muted: <span id="micMuteSeconds">0</span>s
  </span>
</div>
        <div id="voiceTimers" class="hidden" style="margin-top:0.5rem;">
          <div class="badge" style="display:inline-block;margin-right:0.25rem;">
            Answer in: <span id="timerAnswerAfterSpeech">0</span>s
          </div>
          <div class="badge" style="display:inline-block;margin-right:0.25rem;">
            Rating prompt in: <span id="timerAnswerToRating">0</span>s
          </div>
          <div class="badge" style="display:inline-block;">
            Next question in: <span id="timerAfterRating">0</span>s
          </div>
        </div>

        <!-- Inline edit for voice mode -->
        <div style="margin-top:0.5rem;display:flex;justify-content:space-between;align-items:flex-start;gap:0.5rem;">
          <div>
            <button id="voiceRepeatQuestionBtn" class="secondary small">Repeat Question</button>
            <button id="voiceSkipToAnswerBtn" class="secondary small">Skip to Answer</button>
            <button id="voiceEditToggleBtn" class="secondary small">Edit Card</button>
          </div>
          
          <!-- Rating buttons for hands-free mode (optional tap) - aligned to the right -->
          <div id="voiceRatingButtons" class="hidden">
            <div class="ratingRow">
              <div class="ratingItem">
                <button data-voice-rating="again">Again</button>
                <span id="voice-hint-again" class="dueHint"></span>
              </div>

              <div class="ratingItem">
                <button data-voice-rating="hard">Hard</button>
                <span id="voice-hint-hard" class="dueHint"></span>
              </div>

              <div class="ratingItem">
                <button data-voice-rating="good">Good</button>
                <span id="voice-hint-good" class="dueHint"></span>
              </div>

              <div class="ratingItem">
                <button data-voice-rating="easy">Easy</button>
                <span id="voice-hint-easy" class="dueHint"></span>
              </div>
            </div>
          </div>
        </div>
        <div id="voiceEditPanel" class="hidden" style="margin-top:0.75rem;">
          <label for="voiceEditQuestionLang">Question language (TTS):</label>
<select id="voiceEditQuestionLang"></select>

<label for="voiceEditAnswerLang">Answer language (TTS):</label>
<select id="voiceEditAnswerLang"></select>

          <label for="voiceEditQuestion">Edit question:</label>
          <textarea id="voiceEditQuestion" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>
          <label for="voiceEditAnswer">Edit answer:</label>
          <textarea id="voiceEditAnswer" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>
          <div style="margin-top:0.5rem;">
            <button id="voiceSaveEditBtn">Save</button>
            <button id="voiceCancelEditBtn" class="secondary">Cancel</button>
          </div>
        </div>
      </div> <!-- end of #voiceUI -->

      <!-- Silent mode UI -->
      <div id="silentUI" class="hidden">
        <div id="silentFlashcard" class="flashcard">
          <div class="flashcard-inner">
            <div id="silentQuestion" class="flashcard-face flashcard-front">
              <div class="flashcard-label">Question</div>
              <div id="silentQuestionText"></div>
            </div>
            <div id="silentAnswer" class="flashcard-face flashcard-back">
              <div class="flashcard-label">Answer</div>
              <div id="silentAnswerText"></div>
            </div>
          </div>
        </div>

        <!-- Inline edit for silent mode -->
        <div style="margin-top:0.5rem;">
          <button id="silentEditToggleBtn" class="secondary small">Edit Card</button>
        </div>
        <div id="silentEditPanel" class="hidden" style="margin-top:0.75rem;">
          <label for="silentEditQuestionLang">Question language (TTS):</label>
<select id="silentEditQuestionLang"></select>

<label for="silentEditAnswerLang">Answer language (TTS):</label>
<select id="silentEditAnswerLang"></select>

          <label for="silentEditQuestion">Edit question:</label>
          <textarea id="silentEditQuestion" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>
          <label for="silentEditAnswer">Edit answer:</label>
          <textarea id="silentEditAnswer" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>
          <div style="margin-top:0.5rem;">
            <button id="silentSaveEditBtn">Save</button>
            <button id="silentCancelEditBtn" class="secondary">Cancel</button>
          </div>
        </div>

        <div style="margin-top:0.75rem;display:flex;justify-content:space-between;align-items:flex-start;gap:0.5rem;">
          <div>
            <button id="silentRepeatQuestionBtn" class="secondary">Repeat Question</button>
            <button id="showAnswerBtn">Show Answer</button>
            <!-- next card button for silent study-ahead -->
            <button id="silentNextCardBtn" class="secondary hidden">Next Card</button>
          </div>
          
          <!-- Rating buttons for silent mode - aligned to the right -->
          <div id="silentRatingButtons" class="hidden">
            <div class="ratingRow">
              <div class="ratingItem">
                <button data-rating="again">Again</button>
                <span id="hint-again" class="dueHint"></span>
              </div>

              <div class="ratingItem">
                <button data-rating="hard">Hard</button>
                <span id="hint-hard" class="dueHint"></span>
              </div>

              <div class="ratingItem">
                <button data-rating="good">Good</button>
                <span id="hint-good" class="dueHint"></span>
              </div>

              <div class="ratingItem">
                <button data-rating="easy">Easy</button>
                <span id="hint-easy" class="dueHint"></span>
              </div>
            </div>
          </div>
        </div>
        <!-- Completion controls for silent mode -->
        <div id="silentCompletionControls" class="hidden" style="margin-top:0.75rem;">
          <button id="silentMainMenuBtn">Main Menu</button>
          <button id="silentStudyAheadBtn" class="secondary">Study Ahead in this Deck</button>
        </div>
      </div>
    </div>
  </div>
<!-- ===== Add Card Modal (during study) ===== -->
<div id="addCardModal" class="modal hidden" aria-hidden="true">
  <div class="modalBackdrop"></div>

  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="addCardModalTitle">
    <div class="row" style="justify-content:space-between;align-items:center;">
      <h3 id="addCardModalTitle" style="margin:0;">Add a card to this deck</h3>
      <button id="addCardModalCloseBtn" class="secondary small" type="button">Close</button>
    </div>

    <div style="margin-top:0.75rem;">
  <label for="addCardModalQuestionLang">Question language (TTS)</label>
  <select id="addCardModalQuestionLang"></select>

  <label for="addCardModalQuestion">Question</label>
  <textarea id="addCardModalQuestion" placeholder="Enter question" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>
</div>

<div style="margin-top:0.75rem;">
  <label for="addCardModalAnswerLang">Answer language (TTS)</label>
  <select id="addCardModalAnswerLang"></select>

  <label for="addCardModalAnswer">Answer</label>
  <textarea id="addCardModalAnswer" placeholder="Enter answer" spellcheck="true" autocorrect="on" autocomplete="on" autocapitalize="sentences"></textarea>
</div>

    <div class="row" style="margin-top:0.75rem;">
      <button id="addCardModalSaveBtn" type="button">Save Card</button>
      <button id="addCardModalCancelBtn" class="secondary" type="button">Cancel</button>
      <span id="addCardModalStatus" style="font-size:0.85rem;color:#9ca3af;"></span>
    </div>
  </div>
</div>

<!-- ===== Instructions Modal ===== -->
<div id="instructionsModal" class="modal hidden" aria-hidden="true">
  <div class="modalBackdrop"></div>

  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="instructionsModalTitle">
    <div class="row" style="justify-content:space-between;align-items:center;">
      <h3 id="instructionsModalTitle" style="margin:0;">How to Study with ZenCards</h3>
      <button id="instructionsCloseBtn" class="secondary small" type="button">Close</button>
    </div>

    <div style="margin-top:0.75rem;max-height:70vh;overflow:auto;">

      <!-- QUICK START -->
      <div style="background:#064e3b;border:2px solid #10b981;border-radius:8px;padding:1rem;margin-bottom:1rem;">
        <h3 style="margin:0 0 0.5rem 0;color:#10b981;">üöÄ Quick Start</h3>
        <ol style="margin:0;padding-left:1.5rem;color:#d1d5db;">
          <li>Choose a deck and tap <strong>Hands-Free Study</strong></li>
          <li>Listen to the question, wait for the audio to finish, then say <strong>"answer"</strong> or <strong>"skip to answer"</strong>. You may use any of the voice commands from the list below at this time.</li>
          <li>After the answer plays, the system will prompt you ‚Äî say <strong>again / hard / good / easy</strong>. Any of the voice commands from the below list may be used here as well, except for "mute microphone".</li>
        </ol>
      </div>

      <!-- GOLDEN RULE -->
      <div style="background:#78350f;border:2px solid #f59e0b;border-radius:8px;padding:1rem;margin-bottom:1rem;">
        <h3 style="margin:0 0 0.5rem 0;color:#fbbf24;">‚ö†Ô∏è Golden Rule</h3>
        <p style="margin:0;color:#fde68a;font-size:1.05rem;">
          <strong>Only speak AFTER the audio finishes.</strong> Wait for the system to finish speaking the question audio or rating prompt before giving voice commands. Voice commands during playback will not work. ZenCards requires exact wording for voice commands and ratings to ensure users can maintain complete control over their study session without background noise interference.
        </p>
      </div>

      <!-- CARD FLOW -->
      <div style="background:#1e3a8a;border:2px solid #3b82f6;border-radius:8px;padding:1rem;margin-bottom:1rem;">
        <h3 style="margin:0 0 0.5rem 0;color:#60a5fa;">üîÑ How Each Card Works</h3>
        <ol style="margin:0;padding-left:1.5rem;color:#bfdbfe;">
          <li><strong>System reads the question</strong> ‚Üí Wait for it to finish</li>
          <li><strong>You say "answer"</strong> (or "skip to answer") ‚Üí System plays the answer</li>
          <li><strong>System asks for rating</strong> ‚Üí Say <strong>again / hard / good / easy</strong></li>
        </ol>
      </div>

      <!-- RATINGS -->
      <h3 style="margin-top:1.5rem;">üìä What Each Rating Means</h3>
      <ul style="margin-top:0.5rem;color:#9ca3af;">
        <li><strong style="color:#ef4444;">Again</strong> ‚Äî Didn't remember (card comes back soonest)</li>
        <li><strong style="color:#f97316;">Hard</strong> ‚Äî Remembered but tough (slower progress)</li>
        <li><strong style="color:#22c55e;">Good</strong> ‚Äî Remembered normally (standard progress)</li>
        <li><strong style="color:#3b82f6;">Easy</strong> ‚Äî Remembered instantly (fastest progress)</li>
      </ul>

      <!-- COLLAPSIBLE: VOICE COMMANDS -->
      <details style="margin-top:1.5rem;border:1px solid #374151;border-radius:6px;padding:0.75rem;">
        <summary style="cursor:pointer;font-weight:600;color:#60a5fa;">üó£Ô∏è All Voice Commands</summary>
        <ul style="margin-top:0.75rem;color:#9ca3af;">
          <li><strong>answer</strong> or <strong>skip to answer</strong> ‚Äî after question plays</li>
          <li><strong>again / hard / good / easy</strong> ‚Äî rate the card when prompted</li>
          <li><strong>repeat question</strong> ‚Äî hear the question again</li>
          <li><strong>repeat answer</strong> ‚Äî hear the answer again</li>
          <li><strong>pause study session</strong> / <strong>resume study session</strong></li>
          <li><strong>main menu</strong> ‚Äî exit to deck selection</li>
          <li><strong>go to the next card</strong> ‚Äî move to the next card, automatically assigns easy rating</li>
          <li><strong>mute microphone</strong> ‚Üí then say <strong>10 / 20 / 30 / 40 / 50 / 60</strong> seconds</li>
        </ul>
      </details>

      <!-- COLLAPSIBLE: STUDY OPTIONS -->
      <details style="margin-top:1rem;border:1px solid #374151;border-radius:6px;padding:0.75rem;">
        <summary style="cursor:pointer;font-weight:600;color:#60a5fa;">‚öôÔ∏è Study Options & Timing</summary>
        <div style="margin-top:0.75rem;color:#9ca3af;">
          <p><strong>Hands-Free Study</strong> ‚Äî Audio + voice commands (best for studying on the move)</p>
          <p><strong>Silent Study</strong> ‚Äî Traditional flashcards (tap to reveal, rate with buttons)</p>
          
          <p style="margin-top:1rem;"><strong>Timing Tips:</strong></p>
          <ul>
            <li><strong>Delay after rating</strong> ‚Äî We recommend 5+ seconds for better retention</li>
            <li><strong>Answer delay</strong> ‚Äî Set to 0 for instant, or 5+ seconds to give yourself think time</li>
            <li><strong>Study-ahead mode</strong> ‚Äî Review extra cards after completing your due cards</li>
          </ul>
        </div>
      </details>

    </div>
  </div>
</div>

  <script>
    // ‚úÖ Fix BFCache (Back button) issues: force a clean reload when restored
window.addEventListener("pageshow", (e) => {
  if (e.persisted) {
    console.log("[BFCache] Restored from back/forward cache -> reloading");
    window.location.reload();
  }
});

    // ===================== SUPABASE CONFIG =====================
const SUPABASE_URL = "https://elpfcnnrripftxoqeckv.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVscGZjbm5ycmlwZnR4b3FlY2t2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4NTk5MzQsImV4cCI6MjA4MDQzNTkzNH0.uiLHVcRfMXu0V7QRW41TARMIy-Hbhovc4h9uYFzzGLQ";
    const { createClient } = window.supabase;
    window.supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
        storage: window.localStorage,
        storageKey: "zencards-auth",
      },
    });

    // ===== Delete Account Modal =====
    function showDeleteAccountModal() {
      const modal = document.createElement('div');
      modal.style.position = 'fixed';
      modal.style.top = '0';
      modal.style.left = '0';
      modal.style.width = '100vw';
      modal.style.height = '100vh';
      modal.style.background = 'rgba(0,0,0,0.45)';
      modal.style.display = 'flex';
      modal.style.alignItems = 'center';
      modal.style.justifyContent = 'center';
      modal.style.zIndex = '20000';
      modal.innerHTML = `
        <div style="background:#1e293b;padding:2rem 2.5rem;border-radius:1rem;max-width:95vw;width:350px;box-shadow:0 8px 32px #000a;">
          <h2 style="color:#fff;margin-bottom:1rem;">Delete Account</h2>
          <p style="color:#f87171;margin-bottom:1rem;">This will permanently delete your account and all your data. This cannot be undone.</p>
          <input id="deleteAccountPassword" type="password" placeholder="Enter your password" style="width:100%;padding:0.6rem;margin-bottom:1rem;border-radius:0.5rem;border:1px solid #334155;background:#0f172a;color:#fff;" />
          <div id="deleteAccountError" style="color:#f87171;font-size:0.95em;margin-bottom:0.5rem;display:none;"></div>
          <button id="confirmDeleteAccountBtn" class="btn danger" style="width:100%;margin-bottom:0.5rem;">Delete My Account</button>
          <button id="cancelDeleteAccountBtn" class="btn secondary" style="width:100%;background:#334155;color:#fff;">Cancel</button>
        </div>
      `;
      document.body.appendChild(modal);

      document.getElementById('cancelDeleteAccountBtn').onclick = () => modal.remove();
      document.getElementById('deleteAccountPassword').onkeydown = (e) => { if (e.key === 'Enter') document.getElementById('confirmDeleteAccountBtn').click(); };
      document.getElementById('confirmDeleteAccountBtn').onclick = async () => {
        const password = document.getElementById('deleteAccountPassword').value;
        const errorDiv = document.getElementById('deleteAccountError');
        errorDiv.style.display = 'none';
        if (!password) {
          errorDiv.textContent = 'Password required.';
          errorDiv.style.display = 'block';
          return;
        }
        // Re-authenticate user
        const { data: { user }, error: userError } = await supabaseClient.auth.getUser();
        if (!user || userError) {
          errorDiv.textContent = 'Could not verify user.';
          errorDiv.style.display = 'block';
          return;
        }
        const { error: signInError } = await supabaseClient.auth.signInWithPassword({ email: user.email, password });
        if (signInError) {
          errorDiv.textContent = 'Incorrect password.';
          errorDiv.style.display = 'block';
          return;
        }
        // Confirm deletion
        if (!confirm('Are you sure you want to permanently delete your account and cancel your subscription? This cannot be undone.')) return;
        // Call Supabase Edge Function to delete account and cancel subscription
        try {
          console.log('[DeleteAccount] Attempting to call edge function...');
          const { data: sessionData } = await supabaseClient.auth.getSession();
          const accessToken = sessionData?.session?.access_token || '';
          const resp = await fetch('https://elpfcnnrripftxoqeckv.supabase.co/functions/v1/delete-account', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${accessToken}`
            },
            body: JSON.stringify({ user_id: user.id, email: user.email })
          });
          console.log('[DeleteAccount] Response status:', resp.status);
          const text = await resp.text();
          console.log('[DeleteAccount] Raw response:', text);
          let result = {};
          try { result = JSON.parse(text); } catch (err) { result = { error: 'Invalid JSON response', raw: text }; }
          if (!resp.ok || result.error) {
            errorDiv.textContent = result.error || 'Failed to delete account. Please contact support.';
            errorDiv.style.display = 'block';
            return;
          }
          await supabaseClient.auth.signOut();
          modal.remove();
          alert('Your account and subscription have been deleted.');
          // Redirect to landing page instead of reloading
          window.location.href = 'index.html';
        } catch (e) {
          console.error('[DeleteAccount] Exception:', e);
          errorDiv.textContent = 'Failed to delete account. Please contact support.';
          errorDiv.style.display = 'block';
        }
      };
    }

    document.getElementById('deleteAccountBtn')?.addEventListener('click', showDeleteAccountModal);

    // On every session change, sync to Capacitor Preferences (native only)
    (async function setupSessionSync() {
      const isNative = !!window.Capacitor || !!window.cordova || !!window.webkit?.messageHandlers?.bridge;
      if (!isNative) return;
      try {
        const { Preferences } = await import('@capacitor/preferences');
        window.supabaseClient.auth.onAuthStateChange(async (_event, session) => {
          try {
            if (session) {
              await Preferences.set({ key: 'zencards-auth', value: localStorage.getItem('zencards-auth') || '' });
            } else {
              await Preferences.remove({ key: 'zencards-auth' });
            }
          } catch (e) {
            console.warn('[Capacitor] Could not sync session to Preferences:', e);
          }
        });
      } catch (e) {
        console.warn('[Capacitor] Could not set up Preferences sync:', e);
      }
    })();
// ===================== BFCache SAFETY (Safari/iOS, back button) =====================
// If Safari restores this page from BFCache, JS state can be stale.
// Force a hard reload so auth + UI + listeners re-bootstrap cleanly.
window.addEventListener("pageshow", (event) => {
  const nav = performance.getEntriesByType?.("navigation")?.[0];
  const isBFCache =
    event.persisted === true ||
    (nav && nav.type === "back_forward") ||
    (performance && performance.navigation && performance.navigation.type === 2);

  if (isBFCache) {
    console.warn("[BFCache] pageshow restore detected -> hard reload");
    window.location.reload();
  }
});

// ‚úÖ Prevent double-init on iOS BFCache / pageshow
window.__zc_app_inited = window.__zc_app_inited || false;
window.__zc_auth_sub = window.__zc_auth_sub || null;
window.__zc_last_healthcheck_ms = window.__zc_last_healthcheck_ms || 0;


window.setSyncLock = window.setSyncLock || function () {};
window.lockUI = window.lockUI || function () {};

let currentUser = null;
let isSigningOut = false;
async function signOutFromApp() {
  if (isSigningOut) return;
  isSigningOut = true;

  try {
    console.log("[LOGOUT] signing out...");

    // Stop any study audio/listening
    try { stopAllAudio(); } catch (_) {}

    // Supabase sign out
    await supabaseClient.auth.signOut();

    // Clear ONLY your app‚Äôs local state (not everything)
    localStorage.removeItem("srsDecks");
    localStorage.removeItem("srsSchedule");

    // Clear Supabase session storage key
    localStorage.removeItem("zencards-auth");

    currentUser = null;
    hasLoadedRemote = false;
    pendingSaveBeforeRemote = false;

    console.log("[LOGOUT] done, redirecting to index.html");
    window.location.replace("index.html"); // Only redirect on explicit logout
  } catch (e) {
    console.error("[LOGOUT] failed:", e);
    alert("Logout failed. Check console.");
  } finally {
    isSigningOut = false;
  }
}



// ===== AUTH DOM REFERENCES =====
const deckBadge = document.getElementById("deckBadge");
// ===== AUTH UI refs =====
const authLoggedIn = document.getElementById("authLoggedIn");
const userEmailLabel = document.getElementById("userEmailLabel");
const signOutBtn = document.getElementById("logOutBtn");

// Optional buttons (keep if you use them)
const manageBillingBtn = document.getElementById("manageBillingBtn");
const studyAddCardBtn = document.getElementById("studyAddCardBtn");
const addCardModal = document.getElementById("addCardModal");
const addCardModalCloseBtn = document.getElementById("addCardModalCloseBtn");
const addCardModalCancelBtn = document.getElementById("addCardModalCancelBtn");
const addCardModalSaveBtn = document.getElementById("addCardModalSaveBtn");
const addCardModalQuestion = document.getElementById("addCardModalQuestion");
const addCardModalAnswer = document.getElementById("addCardModalAnswer");
const addCardModalStatus = document.getElementById("addCardModalStatus");
// ===== Instructions modal refs =====
const openInstructionsBtn = document.getElementById("openInstructionsBtn");
const instructionsModal = document.getElementById("instructionsModal");
const instructionsCloseBtn = document.getElementById("instructionsCloseBtn");

// ===== BUTTON EVENT HOOKS =====

if (signOutBtn) {
  signOutBtn.addEventListener("click", () => {
    signOutFromApp();
  });
}
// ===================== BILLING (STRIPE PORTAL) =====================

// Helper: returns a good redirect base for GitHub Pages + local
function getBaseUrlForSameFolder() {
  // app.html, reset.html, etc are in the same folder
  return new URL(".", window.location.href).href; // ends with trailing slash
}

async function openStripeCustomerPortal() {
  try {
    // Make sure we have a session token to authorize the edge function
    const { data: sessionData, error: sessErr } = await supabaseClient.auth.getSession();
    if (sessErr) throw sessErr;

    const session = sessionData?.session;
    if (!session?.access_token) {
      alert("No active session. Please log in again.");
      window.location.replace("index.html");
      return;
    }

    // Call your edge function: create-portal-link
    const fnUrl = `${SUPABASE_URL}/functions/v1/create-portal-link`;

    const res = await fetch(fnUrl, {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "apikey": SUPABASE_ANON_KEY,
    Authorization: `Bearer ${session.access_token}`,
  },
  body: JSON.stringify({
    return_url: getBaseUrlForSameFolder() + "app.html",
  }),
});

    const json = await res.json().catch(() => ({}));

    if (!res.ok) {
      console.error("[PORTAL] Edge function error:", json);
      alert("Could not open billing portal. Check console.");
      return;
    }

    const url = json?.url;
    if (!url) {
      console.error("[PORTAL] No url returned:", json);
      alert("Billing portal link not returned. Check console.");
      return;
    }

    // Redirect to Stripe portal
    window.location.assign(url);
  } catch (e) {
    console.error("[PORTAL] Failed:", e);
    alert("Could not open billing portal. Check console.");
  }
}

// Hook up the button
if (manageBillingBtn) {
  manageBillingBtn.addEventListener("click", openStripeCustomerPortal);
}


    // ===================== DATA & STORAGE =====================
    let decks = [];
    // schedule[deckId_cardId] = {
    //   phase: "ladder" | "mature1" | "mature2",
    //   level: 1..5 (only for ladder),
    //   intervalMinutes: number,
    //   timesGraduated: number,
    //   dueTime: ms since epoch
    // }
    let schedule = {};
    let hasLoadedRemote = false;

function getCurrentState() {
  return {
    decks,
    schedule,
  };
}

    const MINUTES_PER_DAY = 1440;
    const LADDER_LEVEL_MINUTES = {
      1: 5,                 // level 1: ~5 minutes
      2: 10,                // level 2: 10 minutes
      3: 1 * MINUTES_PER_DAY,   // 1 day
      4: 3 * MINUTES_PER_DAY,   // 3 days
      5: 7 * MINUTES_PER_DAY    // 7 days
    };

    // threshold for "show again in this session" behavior
    const SHORT_REVIEW_THRESHOLD_MINUTES = 10;

    function loadFromStorage() {
  try {
    const d = localStorage.getItem("srsDecks");
    decks = d ? JSON.parse(d) : [];
  } catch (_) {
    decks = [];
  }
  if (!Array.isArray(decks)) decks = [];

  try {
    const s = localStorage.getItem("srsSchedule");
    schedule = s ? JSON.parse(s) : {};
  } catch (_) {
    schedule = {};
  }
  if (typeof schedule !== "object" || schedule === null) schedule = {};

  // ‚úÖ Only create sample deck if NOT logged in
  if (decks.length === 0 && !currentUser) {
    decks = [{
      id: "deck1",
      name: "Sample Deck",
      qLang: "en-US",
aLang: "en-US",
      cards: [
        { id: "c1", question: "What does DOMS stand for?", answer: "Delayed onset muscle soreness." },
        { id: "c2", question: "In a dumbbell incline press, what area of the chest is emphasized?", answer: "The upper chest, especially the clavicular head of the pectoralis major." }
      ]
    }];
  }
}

// ===================== SUPABASE SAVE QUEUE (prevents overlaps) =====================
let saveInFlight = false;
let saveQueued = false;
let pendingSaveBeforeRemote = false;

async function queueSaveToSupabase() {
  if (!currentUser) {
  pendingSaveBeforeRemote = true;
  console.warn("[QUEUE] No currentUser yet; deferring save");
  return;
}
  console.log("[QUEUE] queueSaveToSupabase() hit", {
    hasLoadedRemote,
    saveInFlight,
    saveQueued
  });

  try {
    // If remote hasn't loaded yet, allow a write ONLY if user exists
    if (!hasLoadedRemote) {
      const { data: u, error: userErr } = await supabaseClient.auth.getUser();

      console.log("[QUEUE] hasLoadedRemote=false; getUser check:", {
        userErr: userErr ? { message: userErr.message, name: userErr.name } : null,
        hasUser: !!u?.user,
        userId: u?.user?.id || null
      });

      if (userErr) {
        console.error("‚ùå [QUEUE] getUser error (this is why saves stop):", userErr);
        pendingSaveBeforeRemote = true;
        return;
      }

      if (!u?.user) {
        pendingSaveBeforeRemote = true;
        console.warn("‚è≥ [QUEUE] Deferring save until remote is loaded (no user yet)");
        return;
      }

      console.warn("‚úÖ [QUEUE] User exists; allowing save before remote load");
    }

    if (saveInFlight) {
      saveQueued = true;
      console.log("[QUEUE] saveInFlight=true -> queued next save");
      return;
    }

    saveInFlight = true;

    const res = await saveStateToSupabase();
    console.log("[QUEUE] saveStateToSupabase result:", res);
  } catch (e) {
    console.error("‚ùå [QUEUE] queueSaveToSupabase crashed:", e);
  } finally {
    saveInFlight = false;

    if (saveQueued) {
      saveQueued = false;
      console.log("[QUEUE] running queued save now‚Ä¶");
      // important: await so errors don‚Äôt get swallowed again
      await queueSaveToSupabase();
    }
  }
}


  function saveDecks() {
  console.log("üíæ saveDecks() firing. decks.length =", decks.length);

  localStorage.setItem("srsDecks", JSON.stringify(decks));

  // THIS is the critical wiring line:
 queueSaveToSupabase().catch(e => console.error("‚ùå queueSaveToSupabase rejected:", e));
}


function saveSchedule() {
  console.log("üü© saveSchedule() firing. schedule keys =", Object.keys(schedule || {}).length);
  localStorage.setItem("srsSchedule", JSON.stringify(schedule));

  queueSaveToSupabase().catch(e => console.error("‚ùå queueSaveToSupabase rejected:", e));
}

// ===================== SUPABASE SYNC HELPERS =====================
async function saveStateToSupabase() {
  console.log("[SAVE] called", new Date().toISOString(), {
    hasLoadedRemote,
    decksLen: Array.isArray(decks) ? decks.length : null,
    hasSchedule: !!schedule
  });

  try {
    // MUST have a logged-in user
    const { data: userData, error: userErr } = await supabaseClient.auth.getUser();

    console.log("[SAVE] getUser()", {
      userErr: userErr
        ? { message: userErr.message, name: userErr.name, status: userErr.status }
        : null,
      userId: userData?.user?.id || null,
      email: userData?.user?.email || null
    });

    if (userErr) {
      console.error("[SAVE] getUser error:", userErr);
      return { ok: false, step: "getUser", error: userErr };
    }

    const user = userData?.user;
    if (!user) {
      console.warn("[SAVE] No user ‚Äî skipping Supabase save");
      return { ok: false, step: "no_user" };
    }

    const payload = {
      user_id: user.id,
      state_json: { decks, schedule },
      updated_at: new Date().toISOString()
    };

    console.log("[SAVE] about to upsert payload", {
      table: "zencards_state",
      user_id: payload.user_id,
      stateSize: JSON.stringify(payload.state_json || {}).length
    });

    const { data, error, status } = await supabaseClient
      .from("zencards_state")
      .upsert(payload, { onConflict: "user_id" });

    console.log("[SAVE] upsert response", {
      status,
      error: error
        ? { message: error.message, code: error.code, details: error.details, hint: error.hint }
        : null,
      data
    });

    if (error) {
      console.error("[SAVE] Supabase save failed:", error);
      if (typeof setAuthStatus === "function") {
        setAuthStatus("Supabase save failed: " + (error.message || "unknown"));
      }
      return { ok: false, step: "upsert", error };
    }

    console.log("‚úÖ [SAVE] Supabase save OK");
    return { ok: true, status, data };
  } catch (e) {
    console.error("[SAVE] crashed:", e);
    return { ok: false, step: "crash", error: e };
  }
}

async function loadStateFromSupabase() {
  console.log("‚úÖ loadStateFromSupabase called");

  console.log("üì• loadStateFromSupabase() start");

  try {
    // Make sure token is fresh
    try { await supabaseClient.auth.refreshSession(); } catch (_) {}

    // Get user
    const { data: userData, error: userErr } = await supabaseClient.auth.getUser();
    const user = userData?.user;

    console.log("üü¶ loadStateFromSupabase getUser()", { user, userErr });

    // ‚úÖ If no user, we still "unlock" in finally.
    if (!user) {
      console.warn("üü® No user in loadStateFromSupabase(). Skipping remote load.");
      return;
    }

    // Load row
    const { data, error } = await supabaseClient
      .from("zencards_state")
      .select("state_json, updated_at")
      .eq("user_id", user.id)
      .maybeSingle();

    if (error) {
      console.error("üü• Supabase load error:", error);
      setAuthStatus("Supabase load error: " + (error.message || "unknown"));
      return;
    }

    console.log("üü¶ Supabase load row:", data);

    // ‚úÖ FIRST-TIME USER CASE: no row yet
    if (!data?.state_json) {
      console.log("üü® No remote state yet; creating from local‚Ä¶");
      await queueSaveToSupabase();     // create their row via queue/locking
return;                        // ‚úÖ still safe because finally runs
    }

    // Apply remote -> memory
    const remote = data.state_json;

    if (Array.isArray(remote.decks)) decks = remote.decks;
    if (remote.schedule && typeof remote.schedule === "object") schedule = remote.schedule;

    // Persist remote -> local
    localStorage.setItem("srsDecks", JSON.stringify(decks));
    localStorage.setItem("srsSchedule", JSON.stringify(schedule));

    console.log("‚úÖ Loaded remote state into app + localStorage");
  } catch (e) {
    console.error("‚ùå loadStateFromSupabase crashed:", e);
  } finally {
    // ‚úÖ CRITICAL: ALWAYS release the gate so saves can proceed
    hasLoadedRemote = true;
    console.log("‚úÖ hasLoadedRemote = true");

    setSyncLock(false); // unlock UI if you use this lock

    // ‚úÖ CRITICAL: flush any deferred save that happened before remote loaded
    if (pendingSaveBeforeRemote) {
      pendingSaveBeforeRemote = false;
      console.log("‚è© Flushing deferred save now that remote is loaded/checked");
     queueSaveToSupabase().catch(e => console.error("‚ùå queueSaveToSupabase rejected:", e));
    }
  }
}
initAppSession().catch(e => console.error("‚ùå initAppSession crashed:", e));
function restoreLastDeckSelection() {
  const lastDeckId = getLastDeckId();
  if (!lastDeckId) return;

  if (decks && decks.some(d => d.id === lastDeckId)) {
    selectedDeckId = lastDeckId;
    if (deckSelect) deckSelect.value = lastDeckId;
  }
}
async function ensureSessionHealthy({ reason = "unknown", redirectOnFail = true } = {}) {
  // throttle: don't spam refresh calls
  const now = Date.now();
  if (now - (window.__zc_last_healthcheck_ms || 0) < 1500) return true;
  window.__zc_last_healthcheck_ms = now;

  try {
    // Try to refresh tokens (safe even if already fresh)
    try { await supabaseClient.auth.refreshSession(); } catch (_) {}

    const { data: sessData } = await supabaseClient.auth.getSession();
    const session = sessData?.session || null;

    if (!session) {
      console.warn("[AUTH] ensureSessionHealthy: no session", { reason });
      // Do not redirect to index.html on app version; show message instead
      showSessionError("No session found. Please log in again.");
      return false;
    }

    const { data: userData, error: userErr } = await supabaseClient.auth.getUser();
    if (userErr || !userData?.user) {
      console.warn("[AUTH] ensureSessionHealthy: getUser failed", {
        reason,
        userErr: userErr ? { message: userErr.message, name: userErr.name, status: userErr.status } : null
      });

      // If the session is present but user lookup fails, it's usually a broken token state.
      // Clear all Supabase auth tokens and force relogin.
      try {
        for (let i = localStorage.length - 1; i >= 0; i--) {
          const k = localStorage.key(i);
          if (k && (k.endsWith("-auth-token") || k === "zencards-auth")) {
            localStorage.removeItem(k);
          }
        }
      } catch (_) {}
      try { await supabaseClient.auth.signOut(); } catch (_) {}

      // Do not redirect to index.html on app version; show message instead
      showSessionError("Session invalid or expired. Please log in again.");
      return false;
    }

    // Good state: keep globals aligned
    currentUser = userData.user;
    return true;
  } catch (e) {
    console.warn("[AUTH] ensureSessionHealthy crashed", { reason, e });
    // Do not redirect to index.html on app version; show message instead
    showSessionError("Session error. Please log in again.");
    return false;
  }
}

async function initAppSession() {
    // ‚úÖ install auth listener once
  if (!window.__zc_auth_sub) {
    const { data } = supabaseClient.auth.onAuthStateChange((event, session) => {
      console.log("[AUTH] event:", event, { hasSession: !!session });

      if (event === "SIGNED_OUT") {
         if (isSigningOut) return; 
        currentUser = null;
        hasLoadedRemote = false;
        window.location.replace("index.html");
        return;
      }

      if (session?.user) {
        currentUser = session.user;
        if (userEmailLabel) userEmailLabel.textContent = currentUser.email || "";
        if (authLoggedIn) authLoggedIn.classList.remove("hidden");
      }
    });

    window.__zc_auth_sub = data?.subscription || null;
  }

  console.log("[BOOT] initAppSession()");
 
  // 1) Check session first (fast)
  // ‚úÖ Heal / verify session before deciding
const ok = await ensureSessionHealthy({ reason: "boot", redirectOnFail: false });
if (!ok) {
  console.warn("[BOOT] Session not healthy. Not redirecting to index.html (app mode)");
  // showSessionError will handle UI
  return;
}

// Session is healthy here
const { data: sessionData } = await supabaseClient.auth.getSession();
const session = sessionData?.session || null;

if (!session?.user) {
  console.warn("[BOOT] No session user after healthy check. Not redirecting to index.html (app mode)");
  showSessionError("No user found in session. Please log in again.");
  return;
}

currentUser = session.user;

  if (userEmailLabel) userEmailLabel.textContent = currentUser.email || "";
  if (authLoggedIn) authLoggedIn.classList.remove("hidden");

  // 4) Load local immediately so app feels instant
  loadFromStorage();
  refreshDeckSelect();
  restoreLastDeckSelection();
  refreshCardsList();
  refreshCardLanguageDropdownsForCurrentDeck(null);

  // Start background music on app load (may be blocked until user gesture)
  ensureBgMusicPlayback();


  // 5) Load remote once (this will set hasLoadedRemote=true in finally)
  await loadStateFromSupabase();

  // 6) After remote load, re-render (remote may overwrite local)
  refreshDeckSelect();
  restoreLastDeckSelection();
  refreshCardsList();
  refreshCardLanguageDropdownsForCurrentDeck(null);


  console.log("[BOOT] done", { hasLoadedRemote, userId: currentUser?.id });
}

// If autoplay is blocked, start music on first user gesture
document.addEventListener("click", () => {
  ensureBgMusicPlayback();
}, { once: true });

    function scheduleKey(deckId, cardId) {
      return `${deckId}_${cardId}`;
    }

    // NEW: simple Fisher-Yates shuffle helper (returns a new array)
    function shuffleArray(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
      }
      return a;
    }

    // Normalize old/new schedule entries into our new shape
    function normalizeScheduleEntry(raw) {
      const now = Date.now();
      if (!raw || typeof raw !== "object") {
        return {
          phase: "ladder",
          level: 1,
          intervalMinutes: LADDER_LEVEL_MINUTES[1],
          timesGraduated: 0,
          easeFactor: 2.5,
          relearnStep: 0,
          lastInterval: 0,
          dueTime: now
        };
      }
      let phase = raw.phase || "ladder";
      let level = typeof raw.level === "number" ? raw.level : 1;
      let timesGraduated =
        typeof raw.timesGraduated === "number" ? raw.timesGraduated : 0;
      let easeFactor =
        typeof raw.easeFactor === "number" ? raw.easeFactor : 2.5;
      let relearnStep =
        typeof raw.relearnStep === "number" ? raw.relearnStep : 0;
      let lastInterval =
        typeof raw.lastInterval === "number" ? raw.lastInterval : 0;
      let intervalMinutes =
        typeof raw.intervalMinutes === "number" && raw.intervalMinutes > 0
          ? raw.intervalMinutes
          : (LADDER_LEVEL_MINUTES[level] || LADDER_LEVEL_MINUTES[1]);

      let dueTime;
      if (typeof raw.dueTime === "number") {
        dueTime = raw.dueTime;
      } else if (raw.dueDate) {
        const t = Date.parse(raw.dueDate);
        dueTime = isNaN(t) ? now : t;
      } else {
        dueTime = now;
      }

      const clampedEase = Math.max(1.3, Math.min(3.0, easeFactor));
      return { phase, level, intervalMinutes, timesGraduated, easeFactor: clampedEase, relearnStep, lastInterval, dueTime };
    }

    // Relearning steps (Anki-like): 10m, 1d
    const RELEARN_STEPS = [10, MINUTES_PER_DAY];

    // Core scheduling logic implementing your rules
    function computeNextState(entry, ratingKey) {
      const s = normalizeScheduleEntry(entry);
      const result = { ...s };
      const updateEase = (key) => {
        let next = s.easeFactor || 2.5;
        if (key === "again") next -= 0.3;
        if (key === "hard") next -= 0.2;
        if (key === "good") next += 0.05;
        if (key === "easy") next += 0.1;
        result.easeFactor = Math.max(1.3, Math.min(3.0, next));
      };
      const easeMult = (s.easeFactor || 2.5) / 2.5;

      // Handle relearning phase
      if (s.phase === "relearn") {
        const step = s.relearnStep || 0;
        if (ratingKey === "again") {
          updateEase("again");
          result.relearnStep = 0;
          result.intervalMinutes = RELEARN_STEPS[0];
          return result;
        }
        if (ratingKey === "hard") {
          updateEase("hard");
          result.relearnStep = step;
          result.intervalMinutes = RELEARN_STEPS[step];
          return result;
        }
        if (ratingKey === "good" || ratingKey === "easy") {
          updateEase(ratingKey);
          const nextStep = step + 1;
          if (nextStep < RELEARN_STEPS.length) {
            result.relearnStep = nextStep;
            result.intervalMinutes = RELEARN_STEPS[nextStep];
            return result;
          }
          // Graduated from relearning, return to mature with reduced interval
          const alreadyGraduated = (s.timesGraduated || 0) > 0;
          result.phase = alreadyGraduated ? "mature2" : "mature1";
          result.level = 0;
          result.relearnStep = 0;
          // Return to last mature interval but reduced
          const reducedInterval = Math.max(
            MINUTES_PER_DAY,
            (s.lastInterval || MINUTES_PER_DAY) * 0.5
          );
          result.intervalMinutes = reducedInterval;
          result.lastInterval = result.intervalMinutes;
          return result;
        }
      }

      // "again": lapse handling (mature enters relearning, ladder resets to level 1)
      if (ratingKey === "again") {
        updateEase("again");
        const isMature = s.phase === "mature1" || s.phase === "mature2";
        if (isMature) {
          // Enter relearning with first step
          result.phase = "relearn";
          result.relearnStep = 0;
          result.intervalMinutes = RELEARN_STEPS[0];
          result.lastInterval = s.intervalMinutes;
          // keep timesGraduated
          return result;
        } else {
          // Ladder: reset to level 1
          result.phase = "ladder";
          result.level = 1;
          result.intervalMinutes = LADDER_LEVEL_MINUTES[1];
          return result;
        }
      }

      // Ladder phase: 5 levels
      if (s.phase === "ladder") {
        let lvl = s.level || 1;

        if (ratingKey === "hard") {
          updateEase("hard");
          // Stay on same level, same interval as that level
          result.level = lvl;
          result.intervalMinutes = LADDER_LEVEL_MINUTES[lvl];
          return result;
        }

        if (ratingKey === "good" || ratingKey === "easy") {
          updateEase(ratingKey);
          const jump = ratingKey === "good" ? 1 : 2;
          let target = lvl + jump;

          // Still within ladder (1‚Äì5)
          if (target <= 5) {
            result.level = target;
            result.intervalMinutes = LADDER_LEVEL_MINUTES[target];
            return result;
          }

          // We are "past level 5" -> enter mature phase
          const prevInterval = LADDER_LEVEL_MINUTES[lvl];
          const alreadyGraduated = (s.timesGraduated || 0) > 0;

          result.level = 0;
          result.phase = alreadyGraduated ? "mature2" : "mature1";
          result.timesGraduated = (s.timesGraduated || 0) + 1;

          if (result.phase === "mature1") {
            // First time past level 5: apply mature1 multipliers from level 5 interval
            if (ratingKey === "good") {
              result.intervalMinutes = prevInterval * 1.6 * easeMult;
            } else {
              // easy from level 5 into mature1
              result.intervalMinutes = prevInterval * 2.2 * easeMult;
            }
          } else {
            // mature2 = after you've already been mature before,
            // passed through the ladder again and gone past level 5:
            // hard: 1.2x, good: 2.2x, easy: 2.5x
            const base = prevInterval;
            if (ratingKey === "hard") {
              result.intervalMinutes = base * 1.2;
            } else if (ratingKey === "good") {
              result.intervalMinutes = base * 2.2 * easeMult;
            } else {
              result.intervalMinutes = base * 2.5 * easeMult;
            }
          }

          return result;
        }
      }

      // Mature phases (ease-based interval formula)
      const base = s.intervalMinutes || MINUTES_PER_DAY;

      if (s.phase === "mature1") {
        // First mature phase: ease-based with Hard/Good/Easy multipliers
        updateEase(ratingKey);
        let newInterval;
        if (ratingKey === "hard") {
          // Hard: 1.2x with ease adjustment
          newInterval = base * 1.2 * (result.easeFactor / 2.5);
        } else if (ratingKey === "good") {
          // Good: use ease factor directly
          newInterval = base * result.easeFactor;
        } else if (ratingKey === "easy") {
          // Easy: ease * 1.3
          newInterval = base * result.easeFactor * 1.3;
        }
        // Minimum interval: always grow by at least 1 day
        result.intervalMinutes = Math.max(newInterval, base + MINUTES_PER_DAY);
        result.lastInterval = result.intervalMinutes;
        return result;
      }

      if (s.phase === "mature2") {
        // Second+ mature phase: same ease-based formula
        updateEase(ratingKey);
        let newInterval;
        if (ratingKey === "hard") {
          newInterval = base * 1.2 * (result.easeFactor / 2.5);
        } else if (ratingKey === "good") {
          newInterval = base * result.easeFactor;
        } else if (ratingKey === "easy") {
          newInterval = base * result.easeFactor * 1.3;
        }
        // Minimum interval: always grow by at least 1 day
        result.intervalMinutes = Math.max(newInterval, base + MINUTES_PER_DAY);
        result.lastInterval = result.intervalMinutes;
        return result;
      }

      // Fallback: keep same interval
      return result;
    }

    // Apply scheduling (mutates global schedule) ‚Äî now returns the new entry
    function applyAnkiScheduling(deckId, cardId, ratingKey) {
      const key = scheduleKey(deckId, cardId);
      const existing = schedule[key] || {};
      const nextState = computeNextState(existing, ratingKey);
      const now = Date.now();
      nextState.dueTime = now + nextState.intervalMinutes * 60000;
      schedule[key] = nextState;
      saveSchedule();
      // Update deck dropdown counts when schedule changes
      refreshDeckSelect();
      return nextState;
    }

    // NEW: apply "show again tomorrow" behavior for automatic mode
    function applyTomorrowScheduling(deckId, cardId) {
      const key = scheduleKey(deckId, cardId);
      const existing = normalizeScheduleEntry(schedule[key] || {});
      const now = Date.now();
      const nextState = { ...existing };
      // Keep phase/level/interval the same, just snooze dueTime by 1 day
      nextState.dueTime = now + MINUTES_PER_DAY * 60000;
      schedule[key] = nextState;
      saveSchedule();
      refreshDeckSelect();
      return nextState;
    }

    // Preview next interval (in minutes) without changing schedule
    function previewIntervalMinutes(deckId, cardId, ratingKey) {
      const key = scheduleKey(deckId, cardId);
      const existing = schedule[key] || {};
      const nextState = computeNextState(existing, ratingKey);

      const minutes =
        typeof nextState.intervalMinutes === "number" && nextState.intervalMinutes > 0
          ? nextState.intervalMinutes
          : LADDER_LEVEL_MINUTES[1]; // default to 5 minutes

      return minutes;
    }

    // ===================== DECK & CARD UI =====================
    const editDeckNameBtn = document.getElementById("editDeckNameBtn");

function updateEditDeckNameBtnState() {
  if (!editDeckNameBtn) return;
  // Disable if no deck is selected or no decks exist
  editDeckNameBtn.disabled = !selectedDeckId || !getDeckById(selectedDeckId);
}

if (editDeckNameBtn) {
  editDeckNameBtn.addEventListener("click", () => {
    if (!selectedDeckId) return;
    const deck = getDeckById(selectedDeckId);
    if (!deck) return;
    const newName = prompt("Edit deck name:", deck.name);
    if (newName && newName.trim() && newName.trim() !== deck.name) {
      deck.name = newName.trim();
      saveDecks();
      refreshDeckSelect();
      refreshCardsList();
    }
    updateEditDeckNameBtnState();
  });
}

// Call this after deck select is refreshed
const _origRefreshDeckSelect = refreshDeckSelect;
refreshDeckSelect = function() {
  _origRefreshDeckSelect.apply(this, arguments);
  updateEditDeckNameBtnState();
};
    const deckSelect = document.getElementById("deckSelect");
    const newDeckNameInput = document.getElementById("newDeckName");
    const addDeckBtn = document.getElementById("addDeckBtn");
    const deleteDeckBtn = document.getElementById("deleteDeckBtn");

    // Disable/enable Add Deck button based on input
function updateAddDeckButtonState() {
  const name = (newDeckNameInput?.value || "").trim();
  if (addDeckBtn) addDeckBtn.disabled = name.length === 0;
}

// Run once on load
updateAddDeckButtonState();

// Update live while typing
if (newDeckNameInput) {
  newDeckNameInput.addEventListener("input", updateAddDeckButtonState);
}

    const cardQuestionInput = document.getElementById("cardQuestion");
    const cardAnswerInput = document.getElementById("cardAnswer");
    const addCardBtn = document.getElementById("addCardBtn");
    const updateCardBtn = document.getElementById("updateCardBtn");
    const cardsListDiv = document.getElementById("cardsList");
    const selectedCardInfo = document.getElementById("selectedCardInfo");
    // Main editor language selects
const cardQuestionLangSelect = document.getElementById("cardQuestionLang");
const cardAnswerLangSelect = document.getElementById("cardAnswerLang");

// Add Card Modal language selects
const addCardModalQuestionLangSelect = document.getElementById("addCardModalQuestionLang");
const addCardModalAnswerLangSelect = document.getElementById("addCardModalAnswerLang");

// Inline edit language selects (if you added them)
const silentEditQuestionLangSelect = document.getElementById("silentEditQuestionLang");
const silentEditAnswerLangSelect   = document.getElementById("silentEditAnswerLang");
const voiceEditQuestionLangSelect  = document.getElementById("voiceEditQuestionLang");
const voiceEditAnswerLangSelect    = document.getElementById("voiceEditAnswerLang");

    // ===== Move card UI =====
const moveDeckSelect = document.getElementById("moveDeckSelect");
const moveCardBtn = document.getElementById("moveCardBtn");

function refreshCardLanguageDropdownsForCurrentDeck(cardObj = null) {
  const deck = getDeckById(selectedDeckId);

  // Main editor
  fillLangSelect(cardQuestionLangSelect, getDefaultQLangFor(deck, cardObj));
  fillLangSelect(cardAnswerLangSelect, getDefaultALangFor(deck, cardObj));

  // Add modal
  fillLangSelect(addCardModalQuestionLangSelect, getDefaultQLangFor(deck, cardObj));
  fillLangSelect(addCardModalAnswerLangSelect, getDefaultALangFor(deck, cardObj));

  // Inline edit (optional)
  fillLangSelect(silentEditQuestionLangSelect, getDefaultQLangFor(deck, cardObj));
  fillLangSelect(silentEditAnswerLangSelect, getDefaultALangFor(deck, cardObj));
  fillLangSelect(voiceEditQuestionLangSelect, getDefaultQLangFor(deck, cardObj));
  fillLangSelect(voiceEditAnswerLangSelect, getDefaultALangFor(deck, cardObj));
}


function refreshMoveDeckSelect() {
  if (!moveDeckSelect) return;
  moveDeckSelect.innerHTML = "";

  decks.forEach(deck => {
    const opt = document.createElement("option");
    opt.value = deck.id;
    opt.textContent = deck.name;
    moveDeckSelect.appendChild(opt);
  });

  // Default to current deck (or first deck)
  if (selectedDeckId) moveDeckSelect.value = selectedDeckId;

  // Enable button only when a card is selected and there's at least 1 other deck
  const hasOtherDeck =
    decks.filter(d => d.id !== selectedDeckId).length > 0;

  if (moveCardBtn) {
    moveCardBtn.disabled = !selectedCardId || !hasOtherDeck;
  }
}

    // ================= IMAGE INSERT HELPERS =================
function insertImageTagInto(textarea, imgSrc) {
  if (!textarea || !imgSrc) return;

  const tag = `\n<img src="${imgSrc}" alt="" style="max-width:100%;height:auto;" />\n`;

  const start = textarea.selectionStart ?? textarea.value.length;
  const end   = textarea.selectionEnd ?? textarea.value.length;

  textarea.value =
    textarea.value.slice(0, start) +
    tag +
    textarea.value.slice(end);

  textarea.focus();
  const pos = start + tag.length;
  textarea.selectionStart = textarea.selectionEnd = pos;
}

// Allow dragging & dropping images directly onto a textarea
function makeTextareaAcceptImageDrops(textarea) {
  if (!textarea) return;

  textarea.addEventListener("dragover", (e) => {
    e.preventDefault();
    textarea.classList.add("drag-hover");
  });

  textarea.addEventListener("dragenter", (e) => {
    e.preventDefault();
    textarea.classList.add("drag-hover");
  });

  textarea.addEventListener("dragleave", (e) => {
    e.preventDefault();
    textarea.classList.remove("drag-hover");
  });

  textarea.addEventListener("drop", (e) => {
    e.preventDefault();
    textarea.classList.remove("drag-hover");

    const dt = e.dataTransfer;
    if (!dt || !dt.files || dt.files.length === 0) return;

    const file = dt.files[0];
    if (!file.type.startsWith("image/")) return;

    const reader = new FileReader();
    reader.onload = (ev) => {
      insertImageTagInto(textarea, ev.target.result);
    };
    reader.readAsDataURL(file);
  });
}

// Enable drag/drop on the main editor textareas
makeTextareaAcceptImageDrops(cardQuestionInput);
makeTextareaAcceptImageDrops(cardAnswerInput);

// Insert image button: paste URL or pick a file (stored as data: URL)
document.querySelectorAll("[data-insert-image]").forEach(btn => {
  btn.addEventListener("click", () => {
    const targetId = btn.getAttribute("data-target");
    const textarea = document.getElementById(targetId);
    if (!textarea) return;

    const url = prompt(
      "Paste an image URL, or leave blank to choose a file from your device."
    );

    if (url && url.trim()) {
      insertImageTagInto(textarea, url.trim());
      return;
    }

    // If no URL, open a file picker and embed as data URL
    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = "image/*";
    fileInput.onchange = () => {
      const file = fileInput.files && fileInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        insertImageTagInto(textarea, e.target.result); // data:image/...
      };
      reader.readAsDataURL(file);
    };
    fileInput.click();
  });
});

    // NEW: Anki import elements
    const ankiImportInput   = document.getElementById("ankiImport");
    const ankiImportStatus  = document.getElementById("ankiImportStatus");
    const ankiImportHelpBtn = document.getElementById("ankiImportHelpBtn");

    let selectedDeckId = null;
    let selectedCardId = null;
    // ===================== CONTINUE WHERE I LEFT OFF =====================
const LAST_DECK_KEY = "zc_lastDeckId";
const LAST_MODE_KEY = "zc_lastMode";
const AUTO_RESUME_KEY = "zc_autoResume"; // optional toggle (default false)

function saveLastDeckId(deckId) {
  if (!deckId) return;
  localStorage.setItem(LAST_DECK_KEY, String(deckId));
}

function saveLastMode(mode) {
  if (!mode) return;
  localStorage.setItem(LAST_MODE_KEY, String(mode));
}

function getLastDeckId() {
  return localStorage.getItem(LAST_DECK_KEY);
}

function getLastMode() {
  return localStorage.getItem(LAST_MODE_KEY);
}


    function getDeckById(id) {
      return decks.find(d => d.id === id) || null;
    }
    // ===== Languages for TTS dropdowns =====
const ZC_LANGS = [
  ["en-US", "English (US)"],
  ["en-GB", "English (UK)"],
  ["es-ES", "Spanish (Spain)"],
  ["es-MX", "Spanish (Mexico)"],
  ["fr-FR", "French"],
  ["de-DE", "German"],
  ["it-IT", "Italian"],
  ["pt-PT", "Portuguese (Portugal)"],
  ["pt-BR", "Portuguese (Brazil)"],
  ["ru-RU", "Russian"],
  ["ja-JP", "Japanese"],
  ["zh-CN", "Chinese (Mandarin)"],
  ["ko-KR", "Korean"],
  ["ar-SA", "Arabic"],
  ["hi-IN", "Hindi"],
];

function fillLangSelect(selectEl, defaultValue = "en-US") {
  if (!selectEl) return;
  selectEl.innerHTML = "";
  for (const [code, label] of ZC_LANGS) {
    const opt = document.createElement("option");
    opt.value = code;
    opt.textContent = label;
    selectEl.appendChild(opt);
  }
  selectEl.value = defaultValue;
  if (selectEl.value !== defaultValue) {
    // fallback if default isn't in list
    selectEl.value = "en-US";
  }
}

// returns the best default based on deck/card
function getDefaultQLangFor(deck, card) {
  return (card && card.qLang) || (deck && deck.qLang) || "en-US";
}
function getDefaultALangFor(deck, card) {
  return (card && card.aLang) || (deck && deck.aLang) || "en-US";
}


   // New: compute TOTAL counts per deck (new / learning / review)
// - new: no schedule yet
// - learning: phase === "ladder" (levels 1‚Äì5)
// - review: phase === "mature1" or "mature2" (i.e. past level 5)
function getDeckPhaseCounts(deck) {
  let newCount = 0;
  let learningCount = 0;
  let dueTodayCount = 0;
  const now = Date.now();
  const endOfDay = new Date();
  endOfDay.setHours(23, 59, 59, 999);
  const endOfDayMs = endOfDay.getTime();

  deck.cards.forEach(card => {
    const key = scheduleKey(deck.id, card.id);
    const s = schedule[key];

    // New card: never scheduled
    if (!s) {
      newCount++;
      dueTodayCount++;
      return;
    }

    const normalized = normalizeScheduleEntry(s);
    const level = typeof normalized.level === "number" ? normalized.level : 1;
    const dueTime = typeof normalized.dueTime === "number" ? normalized.dueTime : now;

    if (dueTime <= endOfDayMs) {
      dueTodayCount++;
    }

    if (normalized.phase === "ladder" && level <= 5) {
      // Learning cards (still in the 5-step ladder)
      learningCount++;
    }
  });

  return { newCount, learningCount, dueTodayCount };
}

// ===== Rebuild entire deck UI (called on init and after remote load) =====
function rebuildDeckUI() {
  console.log("[REBUILD] rebuildDeckUI called", { decksLen: decks.length });
  refreshDeckSelect();
  refreshCardsList();
}

    function refreshDeckSelect() {
  const currentValue = selectedDeckId;
  deckSelect.innerHTML = "";

  decks.forEach(deck => {
    const opt = document.createElement("option");
    opt.value = deck.id;

    const counts = getDeckPhaseCounts(deck);
    opt.textContent = `${deck.name} (${counts.newCount}/${counts.learningCount}/${counts.dueTodayCount})`;
    deckSelect.appendChild(opt);
  });

  // ‚úÖ Preserve previously selected deck if possible
  if (!selectedDeckId && decks.length > 0) {
    selectedDeckId = decks[0].id;
  }

  if (currentValue && decks.some(d => d.id === currentValue)) {
    selectedDeckId = currentValue;
  }

  if (selectedDeckId && decks.some(d => d.id === selectedDeckId)) {
    deckSelect.value = selectedDeckId;
  } else if (decks.length > 0) {
    selectedDeckId = decks[0].id;
    deckSelect.value = selectedDeckId;
  } else {
    selectedDeckId = null;
  }

  refreshMoveDeckSelect();
  updateDeckCountsDisplay();
}

function updateDeckCountsDisplay() {
  const el = document.getElementById("deckCountsDisplay");
  if (!el) return;
  const deck = getDeckById(selectedDeckId);
  if (!deck) {
    el.textContent = "";
    return;
  }
  const counts = getDeckPhaseCounts(deck);
  el.innerHTML = `Selected deck: ${counts.newCount}/${counts.learningCount}/<span class="dueCount">${counts.dueTodayCount}</span>`;
}

// --- Web Speech API TTS for cards ---
// --- Daniel voice cache ---
window._danielVoice = null;
function cacheDanielVoice() {
  const voices = window.speechSynthesis.getVoices();
  for (let v of voices) {
    if (v.name && v.name.toLowerCase().includes('daniel')) {
      window._danielVoice = v;
      break;
    }
  }
}

function getActiveDeckAndCardForTts() {
  const deck = currentDeckId ? getDeckById(currentDeckId) : null;
  const card = currentCard || null;
  return { deck, card };
}

function speakCurrentAnswerWithLang(onEnd) {
  const { deck, card } = getActiveDeckAndCardForTts();
  const { aLang } = getCardLangs(deck, card);

  const answer = getPlainTextFromCard(card?.answer || "");
  if (!answer.trim()) {
    if (onEnd) onEnd();
    return;
  }

  speakWithWebTts(answer, onEnd, { lang: aLang });
}

function speakCurrentQuestionWithLang(onEnd) {
  const { deck, card } = getActiveDeckAndCardForTts();
  const { qLang } = getCardLangs(deck, card);

  const question = getPlainTextFromCard(card?.question || "");
  if (!question.trim()) {
    if (onEnd) onEnd();
    return;
  }

  speakWithWebTts(question, onEnd, { lang: qLang });
}

function getCardLangs(deck, card) {
  const qLang = (card && card.qLang) || (deck && deck.qLang) || "en-US";
  const aLang = (card && card.aLang) || (deck && deck.aLang) || "en-US";
  return { qLang, aLang };
}

function speakPlainAnswerWithCardLang(prefixText = "", onEnd) {
  const { deck, card } = getActiveDeckAndCardForTts();
  if (!card) { if (onEnd) onEnd(); return; }

  const { aLang } = getCardLangs(deck, card);
  let answer = getPlainTextFromCard(card.answer || "");
  if (!answer.trim()) { if (onEnd) onEnd(); return; }

  // Add question restatement if enabled
  if (restateQuestionEnabled && card.question && !prefixText) {
    const questionText = getPlainTextFromCard(card.question);
    const statementPrefix = questionToStatement(questionText);
    if (statementPrefix) {
      answer = statementPrefix + ' ' + answer;
    }
  }

  const textToSpeak = prefixText ? (prefixText + answer) : answer;
  speakWithWebTts(textToSpeak, onEnd, { lang: aLang });
}

if (typeof window.speechSynthesis !== 'undefined') {
  window.speechSynthesis.onvoiceschanged = cacheDanielVoice;
  cacheDanielVoice();
}

window.speakCardText = function(questionRaw, answerRaw, deckId, cardObj) {
  const deck = deckId ? getDeckById(deckId) : null;
  const { qLang, aLang } = getCardLangs(deck, cardObj);

  const question = getPlainTextFromCard(questionRaw);
  const answer = getPlainTextFromCard(answerRaw);

  // Speak question, then answer after 5s pause, using your unified TTS with correct languages
  speakWithWebTts(question, () => {
    if (answer && answer.trim()) {
      setTimeout(() => {
        speakWithWebTts(answer, null, { lang: aLang });
      }, 5000);
    }
  }, { lang: qLang });
};


    // Format the next due date for a given card
    function formatDueDate(deckId, cardId) {
      const key = scheduleKey(deckId, cardId);
      const entry = schedule[key];
      if (!entry) {
        // Never scheduled = brand new card
        return "New";
      }

      const normalized = normalizeScheduleEntry(entry);
      const dueMs = normalized.dueTime;
      if (typeof dueMs !== "number") return "New";

      const nowMs = Date.now();
      const due = new Date(dueMs);
      if (Number.isNaN(due.getTime())) return "New";

      const now = new Date();
      const todayStr = now.toDateString();
      const dueStr = due.toDateString();

      if (dueMs <= nowMs) {
        return "Due now";
      }

      // Today later
      if (dueStr === todayStr) {
        return "Today " + due.toLocaleTimeString([], {
          hour: "numeric",
          minute: "2-digit"
        });
      }

      // Otherwise just show date (local)
      return due.toLocaleDateString();
    }

        function refreshCardsList() {
      const deck = getDeckById(selectedDeckId);
      cardsListDiv.innerHTML = "";
      selectedCardId = null;
      selectedCardInfo.textContent = "";
      updateCardBtn.disabled = true;
      if (!deck) return;

      [...deck.cards].reverse().forEach(card => {
        const row = document.createElement("div");
        row.className = "cardRow";

        // Question column
        const questionSpan = document.createElement("span");
        questionSpan.textContent = getPlainTextFromCard(card.question);
        row.appendChild(questionSpan);

        // Due date column
        const dueSpan = document.createElement("span");
        dueSpan.className = "dueDateCell";
        dueSpan.textContent = formatDueDate(selectedDeckId, card.id);
        row.appendChild(dueSpan);

        // Actions column (Edit / Delete)

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "cardActions";

        // Play (TTS) button
        const playBtn = document.createElement("button");
        playBtn.textContent = "üîä";
        playBtn.title = "Play card (TTS)";
        playBtn.className = "secondary small";
       playBtn.addEventListener("click", () => {
  window.speakCardText(card.question, card.answer, selectedDeckId, card);
});
        actionsDiv.appendChild(playBtn);

        const editBtn = document.createElement("button");
        editBtn.textContent = "Edit";
        editBtn.className = "secondary small";
        editBtn.addEventListener("click", () => {
  selectedCardId = card.id;
  cardQuestionInput.value = card.question;
  cardAnswerInput.value = card.answer;

  refreshCardLanguageDropdownsForCurrentDeck(card);

  selectedCardInfo.textContent = ''; // Don't show card ID
  updateCardBtn.disabled = false;
  refreshMoveDeckSelect();
});

        actionsDiv.appendChild(editBtn);

        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "Delete";
        deleteBtn.className = "secondary small";
        deleteBtn.addEventListener("click", () => {
          if (!confirm("Delete this card?")) return;
          const d = getDeckById(selectedDeckId);
          if (!d) return;
          const idx = d.cards.findIndex(c => c.id === card.id);
          if (idx !== -1) {
            d.cards.splice(idx, 1);
          }
          const key = scheduleKey(selectedDeckId, card.id);
          delete schedule[key];
          saveDecks();
          saveSchedule();
          if (selectedCardId === card.id) {
            selectedCardId = null;
            cardQuestionInput.value = "";
            cardAnswerInput.value = "";
            selectedCardInfo.textContent = "";
            updateCardBtn.disabled = true;
          }
          refreshCardsList();
          refreshDeckSelect();
        });
        actionsDiv.appendChild(deleteBtn);

        row.appendChild(actionsDiv);
        cardsListDiv.appendChild(row);
      });
    }

    addDeckBtn.addEventListener("click", () => {
  console.log("‚úÖ Add Deck clicked");

  const raw = newDeckNameInput.value;
  console.log("Deck name raw:", raw);

  if (!raw || !raw.trim()) {
    console.warn("‚ùå No deck name; aborting");
    return;
  }

  const name = raw.trim();
  const id = "deck_" + Date.now();

  console.log("Creating deck:", { id, name });

 decks.push({ id, name, qLang: "en-US", aLang: "en-US", cards: [] });

  console.log("Decks after push:", decks);

  saveDecks();

  console.log("‚úÖ saveDecks() called");

  newDeckNameInput.value = "";
  updateAddDeckButtonState();
  selectedDeckId = id;
  saveLastDeckId(selectedDeckId);
  refreshDeckSelect();
  refreshCardsList();
});

    deleteDeckBtn.addEventListener("click", () => {
      if (!selectedDeckId) return;
      const deck = getDeckById(selectedDeckId);
      if (!deck) return;
      if (!confirm(`Delete deck "${deck.name}" and all its cards?`)) return;

      decks = decks.filter(d => d.id !== selectedDeckId);
      saveDecks();

      const prefix = selectedDeckId + "_";
      Object.keys(schedule).forEach(key => {
        if (key.startsWith(prefix)) {
          delete schedule[key];
        }
      });
      saveSchedule();

      if (decks.length > 0) {
        selectedDeckId = decks[0].id;
      } else {
        selectedDeckId = null;
      }
      refreshDeckSelect();
      refreshCardsList();
    });

    deckSelect.addEventListener("change", () => {
  selectedDeckId = deckSelect.value;
  saveLastDeckId(selectedDeckId);
  refreshCardsList();
  refreshCardLanguageDropdownsForCurrentDeck(null);
  updateDeckCountsDisplay();
});

    addCardBtn.addEventListener("click", () => {
      const q = cardQuestionInput.value.trim();
      const a = cardAnswerInput.value.trim();
      if (!q || !a) return;
      const deck = getDeckById(selectedDeckId);
      if (!deck) return;
      const id = "c_" + Date.now();
const qLang = cardQuestionLangSelect?.value || null;
const aLang = cardAnswerLangSelect?.value || null;

deck.cards.push({ id, question: q, answer: a, qLang, aLang });

      saveDecks();
      cardQuestionInput.value = "";
      cardAnswerInput.value = "";
      selectedCardId = null;
      selectedCardInfo.textContent = "";
      updateCardBtn.disabled = true;
      refreshCardsList();
      refreshDeckSelect();
    });

    updateCardBtn.addEventListener("click", () => {
      if (!selectedCardId) return;
      const q = cardQuestionInput.value.trim();
      const a = cardAnswerInput.value.trim();
      if (!q || !a) return;
      const deck = getDeckById(selectedDeckId);
      if (!deck) return;
      const card = deck.cards.find(c => c.id === selectedCardId);
      if (!card) return;
      card.question = q;
      card.qLang = cardQuestionLangSelect?.value || null;
card.aLang = cardAnswerLangSelect?.value || null;
      card.answer = a;
      saveDecks();
      refreshCardsList();
      cardQuestionInput.value = "";
      cardAnswerInput.value = "";
      selectedCardId = null;
      selectedCardInfo.textContent = "";
      updateCardBtn.disabled = true;
    });
    if (moveCardBtn) {
  moveCardBtn.addEventListener("click", () => {
    if (!selectedCardId) return;
    const fromDeckId = selectedDeckId;
    const toDeckId = moveDeckSelect ? moveDeckSelect.value : null;

    if (!fromDeckId || !toDeckId) return;
    if (fromDeckId === toDeckId) return;

    const fromDeck = getDeckById(fromDeckId);
    const toDeck = getDeckById(toDeckId);
    if (!fromDeck || !toDeck) return;

    const idx = fromDeck.cards.findIndex(c => c.id === selectedCardId);
    if (idx === -1) return;

    // Move the card object
    const [movedCard] = fromDeck.cards.splice(idx, 1);
    toDeck.cards.push(movedCard);

    // Move schedule entry (because key includes deckId)
    const oldKey = scheduleKey(fromDeckId, movedCard.id);
    const newKey = scheduleKey(toDeckId, movedCard.id);

    if (schedule[oldKey]) {
      schedule[newKey] = schedule[oldKey];
      delete schedule[oldKey];
      saveSchedule();
    }

    // Persist + reset editor selection
    saveDecks();

    selectedCardId = null;
    cardQuestionInput.value = "";
    cardAnswerInput.value = "";
    selectedCardInfo.textContent = "";
    updateCardBtn.disabled = true;

    refreshCardsList();
    refreshDeckSelect();     // also refreshes move dropdown + counts
  });
}

    // NEW: Anki import help button
    ankiImportHelpBtn.addEventListener("click", () => {
      alert(
        "How to export from Anki:\n\n" +
        "1. Open Anki on desktop and select settings next to the deck you would like to export.\n" +
        "2. Hit export.\n" +
        "3. Set export format to 'notes in plain text', include the deck you wish to export, and select 'include HTML and media references' as well as 'include tags'.\n" +
        "4. Hit Export... and then save to your computer.\n" +
        "5. Choose that file from your computer to import.\n\n" +
        "You're done!"
      );
    });

    // NEW: Anki import handler
    ankiImportInput.addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      if (!selectedDeckId) {
        alert("Please select a deck first, so I know where to import the cards.");
        ankiImportInput.value = "";
        return;
      }

      const deck = getDeckById(selectedDeckId);
      if (!deck) {
        alert("Selected deck not found.");
        ankiImportInput.value = "";
        return;
      }

      const reader = new FileReader();
      reader.onload = (ev) => {
        const text = ev.target.result || "";
        const lines = text.split(/\r?\n/).filter((l) => l.trim().length > 0);

        let imported = 0;
        const timestamp = Date.now();

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];

          // Try TAB first (typical Anki export), fall back to comma
          let parts = line.split("\t");
          if (parts.length < 2) {
            parts = line.split(",");
          }
          if (parts.length < 2) continue;

          const q = parts[0].trim();
          const a = parts[1].trim();
          if (!q || !a) continue;

          const id = "c_" + timestamp + "_" + imported;
          deck.cards.push({ id, question: q, answer: a, qLang: null, aLang: null });
          imported++;
        }

        if (imported > 0) {
          saveDecks();
          refreshCardsList();
          refreshDeckSelect();
          ankiImportStatus.textContent = `Imported ${imported} cards.`;
        } else {
          ankiImportStatus.textContent = "No valid cards found in file.";
        }

        // Reset file input so you can import the same file again if needed
        ankiImportInput.value = "";
      };

      reader.onerror = () => {
        alert("Error reading file.");
        ankiImportInput.value = "";
      };

      reader.readAsText(file);
    });

    // ===================== TTS & STT =====================
    const statusDiv = document.getElementById("status");

// Takes card text (which may contain HTML/LaTeX) and renders it into an element.
// Then asks MathJax to typeset any equations in that element.
function setCardContent(el, raw) {
  if (!el) return;
  el.innerHTML = raw || "";

  // Let MathJax typeset any LaTeX in this element
  if (window.MathJax && window.MathJax.typesetPromise) {
    MathJax.typesetPromise([el]).catch(err => {
      console.error("MathJax error:", err);
    });
  }
}

// Convert a question into a statement for answer reinforcement
// Examples:
//   "What is the capital of France?" -> "The capital of France is"
//   "Who invented the telephone?" -> "The inventor of the telephone is"
//   "When did WWII end?" -> "WWII ended"
//   "How does photosynthesis work?" -> "Photosynthesis works"
//   "Why is the sky blue?" -> "The sky is blue because"
function questionToStatement(question) {
  if (!question || typeof question !== 'string') return '';
  
  let q = question.trim();
  
  // Remove question mark and any trailing punctuation
  q = q.replace(/[?!.]+$/, '').trim();
  
  // Common question patterns with transformations
  
  // "What is/are/was/were..." -> "... is/are/was/were"
  if (/^what\s+(is|are|was|were|will be|has been)\s+/i.test(q)) {
    return q.replace(/^what\s+(is|are|was|were|will be|has been)\s+(.+)/i, 'The $2 $1') + ',';
  }
  
  // "Who is/was/invented/discovered..." -> "... is/was"
  if (/^who\s+(is|are|was|were|invented|discovered|created|founded)\s+/i.test(q)) {
    return q.replace(/^who\s+(invented|discovered|created|founded)\s+(.+)/i, 'The inventor of $2 is') + ',';
  }
  if (/^who\s+(is|are|was|were)\s+/i.test(q)) {
    return q.replace(/^who\s+(is|are|was|were)\s+(.+)/i, '$2 $1') + ',';
  }
  
  // "When did/does/will..." -> "... happened/occurs/will occur in"
  if (/^when\s+(did|does|will|was|is)\s+/i.test(q)) {
    return q.replace(/^when\s+(did)\s+(.+)/i, '$2,') + '';
  }
  
  // "Where is/was/are..." -> "... is/was/are located at/in"
  if (/^where\s+(is|are|was|were)\s+/i.test(q)) {
    return q.replace(/^where\s+(is|are|was|were)\s+(.+)/i, '$2 $1 located at') + ',';
  }
  
  // "How does/do/did..." -> "... works/work/worked"
  if (/^how\s+(does|do|did|can|could)\s+/i.test(q)) {
    return q.replace(/^how\s+does\s+(.+)/i, '$1') + ',';
  }
  if (/^how\s+(many|much)\s+/i.test(q)) {
    return q.replace(/^how\s+(many|much)\s+(.+)/i, 'The number of $2 is') + ',';
  }
  
  // "Why is/does/did..." -> "... is/does/did ... because"
  if (/^why\s+(is|are|does|do|did|was|were)\s+/i.test(q)) {
    return q.replace(/^why\s+(is|are|does|do|did|was|were)\s+(.+)/i, '$2 $1,') + ' because';
  }
  
  // "Which..." -> "The one that..."
  if (/^which\s+/i.test(q)) {
    return q.replace(/^which\s+(.+)/i, 'The $1 that') + ',';
  }
  
  // "Can/Could/Should/Would..." -> "Yes/No,"
  if (/^(can|could|should|would|will|is|are|do|does|did)\s+/i.test(q)) {
    return 'The answer is,';
  }
  
  // Imperative/command prompts: "Describe...", "Explain...", "List...", "Name...", "Define..."
  if (/^(describe|explain|list|name|define|identify|compare|contrast|discuss|summarize|outline|state|give|provide|calculate|determine|find|solve|prove|show|demonstrate)\s+/i.test(q)) {
    return q.replace(/^(describe|explain|list|name|define|identify|compare|contrast|discuss|summarize|outline|state|give|provide|calculate|determine|find|solve|prove|show|demonstrate)\s+(.+)/i, 
      function(match, verb, rest) {
        // Convert imperative to gerund form when possible
        const verbMap = {
          'describe': 'Describing',
          'explain': 'Explaining',
          'list': 'Listing',
          'name': 'Naming',
          'define': 'Defining',
          'identify': 'Identifying',
          'compare': 'Comparing',
          'contrast': 'Contrasting',
          'discuss': 'Discussing',
          'summarize': 'Summarizing',
          'outline': 'Outlining',
          'state': 'Stating',
          'give': 'Giving',
          'provide': 'Providing',
          'calculate': 'Calculating',
          'determine': 'Determining',
          'find': 'Finding',
          'solve': 'Solving',
          'prove': 'Proving',
          'show': 'Showing',
          'demonstrate': 'Demonstrating'
        };
        const gerund = verbMap[verb.toLowerCase()] || verb;
        return gerund + ' ' + rest + ':';
      }
    );
  }
  
  // "What are the..." (plural form) -> "The ... are"
  if (/^what\s+are\s+the\s+/i.test(q)) {
    return q.replace(/^what\s+are\s+the\s+(.+)/i, 'The $1 are') + ',';
  }
  
  // "True or false" questions -> "The statement is"
  if (/^(true\s+or\s+false|t\/f)/i.test(q)) {
    return 'The statement is';
  }
  
  // "Fill in the blank" or similar -> just use the text
  if (/^(fill\s+in|complete\s+the)/i.test(q)) {
    return q + ':';
  }
  
  // "Translate..." -> "Translating..."
  if (/^translate\s+/i.test(q)) {
    return q.replace(/^translate\s+(.+)/i, 'Translating $1:');
  }
  
  // "Convert..." -> "Converting..."
  if (/^convert\s+/i.test(q)) {
    return q.replace(/^convert\s+(.+)/i, 'Converting $1:');
  }
  
  // Default: just return the question text with a comma (no transformation)
  return q + ',';
}

// Strip HTML tags so TTS doesn't try to read "<img ...>" etc
function getPlainTextFromCard(raw) {
  const tmp = document.createElement("div");
  tmp.innerHTML = raw || "";
  return tmp.textContent || tmp.innerText || "";
}
    function setStatus(text) {
      statusDiv.textContent = text;
    }

    let isSpeaking = false;
    // Every time we start or forcibly stop TTS, bump this.
// Old TTS callbacks check this and no-op if they're "stale".
let speakGeneration = 0;

    // ===== Browser Web SpeechRecognition fallback =====
    const SpeechRecognition =
      window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let speechSupported = !!SpeechRecognition;

    // NEW: track whether we *expect* recognition to keep listening
    let keepListening = false;

    if (speechSupported) {
      recognition = new SpeechRecognition();
      recognition.lang = "en-US";
      recognition.interimResults = false;
      recognition.continuous = false;
      recognition.maxAlternatives = 3; // tiny robustness boost, still using top result
      
      // Request higher quality audio for better accuracy
      try {
        if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {
          const constraints = navigator.mediaDevices.getSupportedConstraints();
          if (constraints.echoCancellation) recognition.echoCancellation = true;
          if (constraints.noiseSuppression) recognition.noiseSuppression = true;
          if (constraints.autoGainControl) recognition.autoGainControl = true;
        }
      } catch (e) {
        console.warn("Could not set audio quality constraints:", e);
      }
      
      // Grammar hints - tell browser what commands to expect
      // (Note: SpeechGrammarList support is limited, but helps in supported browsers)
      try {
        const SpeechGrammarList = window.SpeechGrammarList || window.webkitSpeechGrammarList;
        if (SpeechGrammarList) {
          const grammarList = new SpeechGrammarList();
          const commands = [
            "again", "hard", "good", "easy",
            "repeat question", "repeat answer",
            "show answer", "skip to answer",
            "pause study session", "resume study session",
            "main menu", "go to the next card",
            "study ahead mode", "study ahead",
            "edit card", "delete card"
          ];
          // Create a simple grammar (higher weight = more likely)
          const grammar = '#JSGF V1.0; grammar commands; public <command> = ' + 
            commands.join(' | ') + ' ;';
          grammarList.addFromString(grammar, 1);
          recognition.grammars = grammarList;
        }
      } catch (e) {
        console.warn("Could not set grammar hints:", e);
      }
    }

    // >>> NEW: explicit microphone permission helper (kept as-is, though not called now) <<<
    function requestMicrophoneAccess() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        console.warn("getUserMedia not supported in this browser.");
        return;
      }
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          // Immediately stop the stream; we just needed the permission prompt.
          stream.getTracks().forEach(track => track.stop());
          console.log("Microphone permission granted.");
        })
        .catch(err => {
          console.error("Microphone permission denied:", err);
          setStatus("Please allow microphone access in your browser to use hands-free mode.");
        });
    }
    // <<< END MIC HELPER <<<

    // NEW: TTS settings (rate & volume)
    let ttsRate = 1.0;
    let ttsVolume = 1.0;
    let bgmVolume = 0.04;
    let bgmMuted = false;
    let bgmDucked = false;
    const TTS_SETTINGS_KEY = "srsTtsSettings";
    function clamp(n, min, max) {
  return Math.max(min, Math.min(max, n));
}

// Reads the full settings object (rate, volume, + new delay)
function getTtsSettingsObj() {
  const raw = localStorage.getItem(TTS_SETTINGS_KEY);
  let s = {};
  try { s = raw ? JSON.parse(raw) : {}; } catch { s = {}; }

  if (typeof s.rate !== "number") s.rate = 0.75;
  if (typeof s.volume !== "number") s.volume = 1.0;
  if (typeof s.answerDelayAfterSpeechSec !== "number") s.answerDelayAfterSpeechSec = 0;
  if (typeof s.bgmVolume !== "number") s.bgmVolume = 0.04;
  if (typeof s.bgmMuted !== "boolean") s.bgmMuted = false;

  s.rate = clamp(s.rate, 0.5, 2.0);
  s.volume = clamp(s.volume, 0.0, 1.0);
  s.answerDelayAfterSpeechSec = clamp(Math.round(s.answerDelayAfterSpeechSec), 0, 30);
  s.bgmVolume = clamp(Number(s.bgmVolume), 0.0, 1.0);
  s.bgmMuted = !!s.bgmMuted;

  return s;
}

function saveTtsSettingsObj(s) {
  const out = {
    rate: clamp(Number(s.rate ?? 1.0), 0.5, 2.0),
    volume: clamp(Number(s.volume ?? 1.0), 0.0, 1.0),
    answerDelayAfterSpeechSec: clamp(Math.round(Number(s.answerDelayAfterSpeechSec ?? 0)), 0, 30),
    bgmVolume: clamp(Number(s.bgmVolume ?? 0.04), 0.0, 1.0),
    bgmMuted: !!s.bgmMuted,
  };
  localStorage.setItem(TTS_SETTINGS_KEY, JSON.stringify(out));
}

    const toggleStudyOptionsBtn = document.getElementById("toggleStudyOptionsBtn");
    const studyOptionsPanel = document.getElementById("studyOptionsPanel");
    const toggleAudioSettingsBtn = document.getElementById("toggleAudioSettingsBtn");
    const audioSettingsPanel = document.getElementById("audioSettingsPanel");
    const ttsRateInput = document.getElementById("ttsRateInput");
    const ttsVolumeInput = document.getElementById("ttsVolumeInput");
    const answerDelayAfterSpeechSecInput = document.getElementById("answerDelayAfterSpeechSecInput");
    const bgMusicEl = document.getElementById("bgMusic");
    const bgMusicMuteInput = document.getElementById("bgMusicMute");
    const bgMusicVolumeInput = document.getElementById("bgMusicVolume");
    const bgMusicVolumeValue = document.getElementById("bgMusicVolumeValue");
    
if (answerDelayAfterSpeechSecInput) {
  answerDelayAfterSpeechSecInput.addEventListener("change", () => {
    const v = Math.max(
      0,
      Math.min(30, parseInt(answerDelayAfterSpeechSecInput.value, 10) || 0)
    );

    answerDelayAfterSpeechSecInput.value = String(v);

    const s = getTtsSettingsObj();
    s.answerDelayAfterSpeechSec = v;
    saveTtsSettingsObj(s);
  });
}
    // Load TTS settings from storage
    (function loadTtsSettings() {
  const s = getTtsSettingsObj();
  ttsRate = s.rate;
  ttsVolume = s.volume;
  bgmVolume = s.bgmVolume;
  bgmMuted = !!s.bgmMuted;

  if (ttsRateInput) ttsRateInput.value = String(ttsRate);
  if (ttsVolumeInput) ttsVolumeInput.value = String(ttsVolume);
  if (bgMusicMuteInput) bgMusicMuteInput.checked = !!bgmMuted;
  if (bgMusicVolumeInput) bgMusicVolumeInput.value = String(bgmVolume);
  if (bgMusicVolumeValue) bgMusicVolumeValue.textContent = String(bgmVolume);

  const delayInput = document.getElementById("answerDelayAfterSpeechSecInput");
  if (delayInput) delayInput.value = String(s.answerDelayAfterSpeechSec ?? 0);
})();

function getEffectiveBgmVolume() {
  if (bgmMuted) return 0;
  const base = clamp(Number(bgmVolume || 0), 0, 1);
  if (bgmDucked) return Math.min(base, 0.02);
  return base;
}

function applyBgMusicVolume() {
  if (!bgMusicEl) return;
  bgMusicEl.volume = getEffectiveBgmVolume();
}

function ensureBgMusicPlayback() {
  if (!bgMusicEl) return;
  if (bgmMuted) {
    try { bgMusicEl.pause(); } catch (_) {}
    return;
  }
  applyBgMusicVolume();
  const p = bgMusicEl.play();
  if (p && typeof p.catch === "function") {
    p.catch(() => {});
  }
}

function setBgMusicDucked(ducked) {
  bgmDucked = !!ducked;
  applyBgMusicVolume();
}


    function saveTtsSettings() {
  const current = getTtsSettingsObj();
  current.rate = ttsRate;
  current.volume = ttsVolume;
  current.bgmVolume = bgmVolume;
  current.bgmMuted = bgmMuted;

  // keep existing value unless you set it elsewhere
  saveTtsSettingsObj(current);
}

    if (toggleStudyOptionsBtn && studyOptionsPanel) {
      toggleStudyOptionsBtn.addEventListener("click", () => {
        const isHidden = studyOptionsPanel.classList.contains("hidden");
        if (isHidden) {
          studyOptionsPanel.classList.remove("hidden");
          toggleStudyOptionsBtn.textContent = "Hide";
        } else {
          studyOptionsPanel.classList.add("hidden");
          toggleStudyOptionsBtn.textContent = "Show";
        }
      });
    }

    if (toggleAudioSettingsBtn && audioSettingsPanel) {
      toggleAudioSettingsBtn.addEventListener("click", () => {
        const isHidden = audioSettingsPanel.classList.contains("hidden");
        if (isHidden) {
          audioSettingsPanel.classList.remove("hidden");
          toggleAudioSettingsBtn.textContent = "Hide";
        } else {
          audioSettingsPanel.classList.add("hidden");
          toggleAudioSettingsBtn.textContent = "Show";
        }
      });
    }

    if (ttsRateInput) {
      ttsRateInput.addEventListener("change", () => {
        let v = parseFloat(ttsRateInput.value);
        if (isNaN(v)) v = 1.0;
        v = Math.max(0.5, Math.min(2, v));
        ttsRate = v;
        ttsRateInput.value = String(v);
        saveTtsSettings();
      });
    }

    if (ttsVolumeInput) {
      ttsVolumeInput.addEventListener("change", () => {
        let v = parseFloat(ttsVolumeInput.value);
        if (isNaN(v)) v = 1.0;
        v = Math.max(0, Math.min(1, v));
        ttsVolume = v;
        ttsVolumeInput.value = String(v);
        saveTtsSettings();
      });
    }

    if (bgMusicMuteInput) {
      bgMusicMuteInput.addEventListener("change", () => {
        bgmMuted = !!bgMusicMuteInput.checked;
        saveTtsSettings();
        ensureBgMusicPlayback();
      });
    }

    if (bgMusicVolumeInput) {
      const onVolumeChange = () => {
        let v = parseFloat(bgMusicVolumeInput.value);
        if (isNaN(v)) v = 0.04;
        v = Math.max(0, Math.min(1, v));
        bgmVolume = v;
        bgMusicVolumeInput.value = String(v);
        if (bgMusicVolumeValue) bgMusicVolumeValue.textContent = String(v);
        saveTtsSettings();
        ensureBgMusicPlayback();
      };
      bgMusicVolumeInput.addEventListener("input", onVolumeChange);
      bgMusicVolumeInput.addEventListener("change", onVolumeChange);
    }
    if (answerDelayAfterSpeechSecInput) {
  answerDelayAfterSpeechSecInput.addEventListener("change", () => {
    const v = Math.max(
      0,
      Math.min(30, parseInt(answerDelayAfterSpeechSecInput.value, 10) || 0)
    );

    answerDelayAfterSpeechSecInput.value = String(v);

    const s = getTtsSettingsObj();
    s.answerDelayAfterSpeechSec = v;
    saveTtsSettingsObj(s);
  });
}

    // Helper: stop all audio + listening
    async function stopAllAudio() {
  // Invalidate any in-flight TTS callbacks
  speakGeneration++;
  clearAnswerAfterSpeechDelay();
      clearAutoGoodNextCardTimer();
      clearAnswerToRatingDelayTimer();
      clearAfterRatingDelayTimer();
  setBgMusicDucked(false);

  // Stop browser TTS
  if (window.speechSynthesis) {
    try { window.speechSynthesis.cancel(); } catch (e) {}
  }

  isSpeaking = false;
  setRepeatQuestionEnabled(true);

  // Stop browser speech recognition
  if (recognition) {
    try {
      keepListening = false;
      recognition.onresult = null;
      recognition.onerror = null;
      recognition.onend = null;
      recognition.stop();
    } catch (e) {}
  }
}

  // Wrapper: choose NativeTTS (iOS app) or browser TTS (web)
function speak(text, onEnd) {
  speakWithWebTts(text, onEnd);
}

function speakSafe(text, onEnd) {
  speakWithWebTts(text, onEnd);
}

// Pure browser TTS (this is basically your old speak() body)
function speakWithWebTts(text, onEnd, opts = {}) {
  const { lang = "en-US" } = opts;
  if (!window.speechSynthesis) {
    setStatus("Text-to-speech not supported in this browser.");
    setRepeatQuestionEnabled(true);
    if (onEnd) onEnd();
    return;
  }

    // ‚úÖ IMPORTANT: stop STT while we speak so we don‚Äôt ‚Äúhear ourselves‚Äù
  try {
    keepListening = false;
    if (recognition) recognition.stop();
  } catch (e) {}


  // üßπ Clear any queued / half-finished utterances so we get a clean read.
  try {
    window.speechSynthesis.cancel();
  } catch (e) {
    console.error("Error cancelling previous speech:", e);
  }

  // This is a new TTS "generation"
  speakGeneration++;
  const myGeneration = speakGeneration;

  // Expand acronyms (2+ consecutive capital letters) to spaced letters for TTS
  function expandAcronyms(str) {
    return str.replace(/\b([A-Z]{2,})\b/g, (m) => m.split('').join(' '));
  }

  // Humanize numbers for better TTS pronunciation
  function humanizeNumbers(str) {
    // Convert decimals: "2.5" ‚Üí "2 point 5"
    str = str.replace(/(\d+)\.(\d+)/g, "$1 point $2");
    
    // Convert percentages: "95%" ‚Üí "95 percent"
    str = str.replace(/(\d+)%/g, "$1 percent");
    
    // Convert large numbers to words for better pronunciation
    // Must be done before year conversion to avoid conflicts
    str = str.replace(/\b(\d+)\b/g, (match) => {
      const num = parseInt(match);
      
      // Skip if it's a year (2000-2099)
      if (num >= 2000 && num <= 2099) return match;
      
      // Millions
      if (num >= 1000000) {
        const millions = Math.floor(num / 1000000);
        const remainder = num % 1000000;
        if (remainder === 0) return `${millions} million`;
        const thousands = Math.floor(remainder / 1000);
        if (thousands > 0 && remainder % 1000 === 0) {
          return `${millions} million ${thousands} thousand`;
        }
        return `${millions} point ${Math.floor(remainder / 100000)} million`;
      }
      
      // Thousands
      if (num >= 1000) {
        const thousands = Math.floor(num / 1000);
        const remainder = num % 1000;
        if (remainder === 0) return `${thousands} thousand`;
        if (remainder < 100) return `${thousands} thousand ${remainder}`;
        return `${thousands} thousand ${remainder}`;
      }
      
      return match;
    });
    
    // Convert years: "2024" ‚Üí "twenty twenty-four" (for years 2000+)
    str = str.replace(/\b(20\d{2})\b/g, (match) => {
      const year = parseInt(match);
      if (year >= 2000 && year <= 2099) {
        const decade = Math.floor((year % 100) / 10);
        const single = year % 10;
        if (year % 100 === 0) return "two thousand";
        if (year < 2010) return `two thousand ${single}`;
        return `twenty ${decade > 1 ? decade + "ty" : ""} ${single || ""}`.trim();
      }
      return match;
    });
    
    // Convert ordinals: "1st" ‚Üí "first", "2nd" ‚Üí "second"
    const ordinals = {
      "1st": "first", "2nd": "second", "3rd": "third", "4th": "fourth",
      "5th": "fifth", "6th": "sixth", "7th": "seventh", "8th": "eighth",
      "9th": "ninth", "10th": "tenth"
    };
    Object.keys(ordinals).forEach(key => {
      str = str.replace(new RegExp(`\\b${key}\\b`, "gi"), ordinals[key]);
    });
    
    return str;
  }

  // Add breath pauses naturally like humans need
  function addBreathPauses(str) {
    const words = str.split(/\s+/);
    const result = [];
    let wordsSinceBreath = 0;
    
    for (let i = 0; i < words.length; i++) {
      result.push(words[i]);
      wordsSinceBreath++;
      
      // Add breath pause every 12-15 words at natural breaks
      if (wordsSinceBreath >= 12) {
        const nextWord = words[i + 1] || "";
        // Only pause at natural breaks (commas, conjunctions, etc.)
        if ([",", ".", "and", "but", "or", "so", "yet"].some(w => 
            words[i].endsWith(w) || nextWord.toLowerCase() === w)) {
          result.push("___BREATH___");
          wordsSinceBreath = 0;
        }
      }
      
      // Reset counter after periods
      if (words[i].endsWith(".")) {
        wordsSinceBreath = 0;
      }
    }
    
    return result.join(" ");
  }

  // Handle lists with appropriate pausing
  function handleLists(str) {
    // Detect bulleted/numbered lists
    str = str.replace(/([‚Ä¢\-*]|\d+\.)\s+/g, "___LISTITEM___ $1 ");
    
    // Detect comma-separated lists: "apples, oranges, and bananas"
    // Add slight pause before "and" in lists
    str = str.replace(/(,\s+\w+){2,},\s+and\s+/gi, (match) => {
      return match.replace(/,\s+and\s+/gi, ", ___LISTPAUSE___ and ");
    });
    
    return str;
  }

  // Add pauses around parenthetical phrases
  function handleParentheticals(str) {
    // Detect em-dashes or parenthetical commas
    str = str.replace(/\s*‚Äî\s*/g, " ___PARENTHETICAL___ ");
    
    // Detect phrases like "however,", "therefore,", "in fact,"
    const parentheticalPhrases = [
      "however", "therefore", "moreover", "furthermore", "nevertheless",
      "in fact", "for example", "for instance", "in other words", "that is"
    ];
    
    parentheticalPhrases.forEach(phrase => {
      const re = new RegExp(`\\b(${phrase}),`, "gi");
      str = str.replace(re, `___PARENTHETICAL___ $1,`);
    });
    
    return str;
  }

  // Detect important/emphasis words for subtle rate changes
  function markEmphasisWords(str) {
    // Words that typically carry emphasis
    const emphasisWords = [
      "very", "extremely", "absolutely", "never", "always", "must", "critical",
      "important", "essential", "key", "fundamental", "crucial", "vital"
    ];
    
    emphasisWords.forEach(word => {
      const re = new RegExp(`\\b(${word})\\b`, "gi");
      str = str.replace(re, "___EMPHASIS___$1___/EMPHASIS___");
    });
    
    return str;
  }

  // Fix run-on sentences by adding virtual punctuation at natural breaks
  function fixRunOnSentences(str) {
    if (!str) return str;
    
    // 1) Add comma before coordinating conjunctions that connect independent clauses
    // Pattern: [word] and/but/or/so/yet [word] (but not short phrases)
    const coordinatingConjunctions = ["and", "but", "or", "so", "yet"];
    coordinatingConjunctions.forEach(conj => {
      // Look for pattern: multiple words, then conjunction, then more words
      // Only add comma if there are enough words on both sides (likely independent clauses)
      const pattern = new RegExp(`(\\w+\\s+\\w+\\s+\\w+)\\s+(${conj})\\s+(?=\\w+\\s+\\w+)`, "gi");
      str = str.replace(pattern, "$1, $2 ");
    });
    
    // 2) Add pauses after relative clause starters if missing
    const relativePronouns = ["that", "which", "who", "whom", "whose", "where"];
    relativePronouns.forEach(pronoun => {
      // Add comma before relative pronoun if it's starting a non-restrictive clause
      // (after multiple words, suggesting it's additional info)
      const pattern = new RegExp(`(\\w+\\s+\\w+\\s+\\w+)\\s+(${pronoun})\\s+`, "gi");
      str = str.replace(pattern, (match, before, pron) => {
        // Don't add comma if one already exists
        if (before.trim().endsWith(",")) return match;
        return `${before}, ${pron} `;
      });
    });
    
    // 3) Break up very long sentences (40+ words) at subordinating conjunctions
    const sentences = str.split(/([.!?]+)/);
    const fixedSentences = [];
    
    for (let i = 0; i < sentences.length; i++) {
      let sentence = sentences[i];
      
      // Skip delimiters
      if (/^[.!?]+$/.test(sentence)) {
        fixedSentences.push(sentence);
        continue;
      }
      
      const wordCount = sentence.trim().split(/\s+/).length;
      
      // If sentence is very long, add virtual commas at natural breaks
      if (wordCount > 40) {
        // Add comma after introductory subordinate clauses
        const subordClauseStarters = [
          "when", "while", "as", "since", "if", "although", "though",
          "because", "unless", "until", "before", "after", "whereas"
        ];
        
        subordClauseStarters.forEach(starter => {
          // Pattern: sentence starts with subordinate clause (5-15 words) then main clause
          const pattern = new RegExp(`^(${starter}\\s+(?:\\w+\\s+){4,14})(\\w+)`, "gi");
          sentence = sentence.replace(pattern, "$1, $2");
        });
        
        // Add virtual commas every 15-20 words at conjunctions/prepositions if none exist
        const words = sentence.split(/\s+/);
        let wordsSinceComma = 0;
        const result = [];
        
        for (let j = 0; j < words.length; j++) {
          result.push(words[j]);
          wordsSinceComma++;
          
          // Every 15-20 words, try to add a comma at next conjunction/transition
          if (wordsSinceComma >= 15 && wordsSinceComma <= 20) {
            const nextWord = words[j + 1] ? words[j + 1].toLowerCase() : "";
            const breakWords = ["and", "but", "or", "so", "yet", "for", "nor"];
            
            if (breakWords.includes(nextWord) && !words[j].endsWith(",")) {
              result[result.length - 1] = words[j] + ",";
              wordsSinceComma = 0;
            }
          }
          
          // Reset counter at existing punctuation
          if (words[j].match(/[,;:]/)) {
            wordsSinceComma = 0;
          }
        }
        
        sentence = result.join(" ");
      }
      
      fixedSentences.push(sentence);
    }
    
    return fixedSentences.join("");
  }

  // Normalize punctuation so TTS doesn't read symbols aloud
  function normalizePunctuation(str) {
    return str
      .replace(/[?!]+/g, ".")
      .replace(/[:;]+/g, ",")
      .replace(/[‚Äú‚Äù"'`]/g, "")
      .replace(/[()\[\]{}]/g, "")
      .replace(/\s{2,}/g, " ");
  }

   const processedText = markEmphasisWords(
     handleParentheticals(
       handleLists(
         addBreathPauses(
           addCognitivePauses(
             normalizePunctuation(
               fixRunOnSentences(
                 humanizeNumbers(
                   expandAcronyms(text)
                 )
               )
             )
           )
         )
       )
     )
   );

  // Split text into segments with enhanced pause detection
  const segments = [];
  let regex = /([^.,?!]+)([.,?!]?)/g;
  let match;
  let sentenceWordCount = 0;
  
  while ((match = regex.exec(processedText)) !== null) {
    const phrase = match[1].trim();
    const delim = match[2];
    
    if (!phrase) continue;
    
    // Count words in this phrase
    const wordCount = phrase.split(/\s+/).length;
    sentenceWordCount += wordCount;
    
    // Determine pause duration based on context
    let pause = 0;
    
    if (delim === '.') {
      // Longer pause after complex sentences (15+ words)
      pause = sentenceWordCount > 15 ? 900 : 700;
      sentenceWordCount = 0; // Reset for next sentence
    } else if (delim === '?') {
      // Questions get a thoughtful pause
      pause = 800;
      sentenceWordCount = 0;
    } else if (delim === '!') {
      pause = 750;
      sentenceWordCount = 0;
    } else if (delim === ',') {
      pause = 350;
    }
    
    // Add special pauses for markers
    let processedPhrase = phrase + (delim || "");
    let rateMultiplier = 1.0;
    let pitchShift = 0;
    
    // Breath pause
    if (processedPhrase.includes("___BREATH___")) {
      processedPhrase = processedPhrase.replace(/___BREATH___/g, "");
      pause = Math.max(pause, 400);
    }
    
    // List pauses
    if (processedPhrase.includes("___LISTITEM___")) {
      processedPhrase = processedPhrase.replace(/___LISTITEM___/g, "");
      pause = Math.max(pause, 500);
    }
    
    if (processedPhrase.includes("___LISTPAUSE___")) {
      processedPhrase = processedPhrase.replace(/___LISTPAUSE___/g, "");
      pause = Math.max(pause, 300);
    }
    
    // Parenthetical pause
    if (processedPhrase.includes("___PARENTHETICAL___")) {
      processedPhrase = processedPhrase.replace(/___PARENTHETICAL___/g, "");
      pause = Math.max(pause, 450);
    }
    
    // Emphasis (slow down slightly)
    if (processedPhrase.includes("___EMPHASIS___")) {
      processedPhrase = processedPhrase.replace(/___EMPHASIS___/g, "");
      processedPhrase = processedPhrase.replace(/___\/EMPHASIS___/g, "");
      rateMultiplier = 0.85; // Speak 15% slower for emphasis
    }
    
    // Question intonation (raise pitch slightly)
    if (delim === '?') {
      pitchShift = 0.1;
    }
    
    segments.push({
      text: processedPhrase,
      pause: pause,
      rateMultiplier: rateMultiplier,
      pitchShift: pitchShift
    });
  }

function addCognitivePauses(str) {
  if (!str) return str;

  // Words that should get a pause BEFORE they are spoken
  // Focus on strong transition words that signal a shift in thought
  const pauseWords = [
    "so", "but", "since", "although", "while", "after", "before", "because",
    "until", "nor", "yet", "either", "though", "unless"
  ];

  // 1) Pause BEFORE conjunctions / transition words
  // We insert a comma before the word if it is a standalone word
  pauseWords.forEach(word => {
    const re = new RegExp(`\\s+\\b(${word})\\b`, "gi");
    str = str.replace(re, ", $1");
  });

  // 2) Pause BEFORE quoted text
  // "something" or "something"
  str = str
    .replace(/\s+(")/g, ", $1")
    .replace(/\s+(")/g, ", $1");
  
  // 3) Pause after hesitation markers (if present in flashcards)
  const hesitations = ["um", "uh", "well", "you know", "I mean"];
  hesitations.forEach(h => {
    const re = new RegExp(`\\b(${h})\\b`, "gi");
    str = str.replace(re, "$1,");
  });
  
  // 4) Small pause at sentence beginnings after conjunctions
  str = str.replace(/\.\s+(And|But|So|Or|Yet)\s+/gi, ". , $1 ");

  return str;
}


  function getPreferredVoice() {
  const voices = window.speechSynthesis.getVoices();
  
  // Debug: log all available voices for this language
  console.log("[TTS] All available voices for", lang, ":", voices.filter(v => {
    if (!v || !v.lang) return false;
    const vPrefix = v.lang.split("-")[0];
    const langPrefix = String(lang).split("-")[0];
    return v.lang === lang || vPrefix === langPrefix;
  }).map(v => v.name));

  // 1) Prefer voices that match the requested language
  // Match either exact lang (e.g., "es-ES") or prefix (e.g., "es")
  const langPrefix = String(lang).split("-")[0];

  const matching = voices.filter(v => {
    if (!v || !v.lang) return false;
    const vPrefix = v.lang.split("-")[0];
    return v.lang === lang || vPrefix === langPrefix;
  });

  // 2) If user asked for English, keep your "Daniel, not Samantha" preference
  if (langPrefix === "en") {
    let preferredVoice = 
      // Prefer Google's neural voices (best quality on Chrome/Android)
      matching.find(v => v.name.includes("Google") && v.name.includes("English")) ||
      matching.find(v => v.name.includes("Google")) ||
      // iOS: Prefer ANY Premium or Enhanced voice (neural quality on Apple devices)
      // This catches whatever premium voices are actually installed on the device
      matching.find(v => v.name.includes("Premium") || v.name.includes("Enhanced")) ||
      // Fallback to Alex (always available on iOS, better than Daniel)
      matching.find(v => v.name === "Alex") ||
      // Last resort - Daniel
      matching.find(v => v.name === "Daniel") ||
      matching.find(v => v.name === "Daniel (Enhanced)");

    // fall back to any matching English voice
    if (!preferredVoice) preferredVoice = matching.find(v => !v.name.toLowerCase().includes("samantha") || v.name.includes("Enhanced"));
    if (!preferredVoice) preferredVoice = matching[0] || null;
    return preferredVoice;
  }

  // 3) For non-English, just take the first matching voice (usually best pronunciation)
  if (matching.length > 0) return matching[0];

  // 4) Fallback: any voice at all (last resort)
  return voices[0] || null;
}

  function startSpeaking() {
    setBgMusicDucked(true);
    const preferredVoice = getPreferredVoice();
    // Debug: log which voice is being used
    console.log("[TTS] Using voice:", preferredVoice?.name || "default");
    let idx = 0;
    function speakSegment() {
      if (idx >= segments.length) {
        isSpeaking = false;
        setStatus("");
        setBgMusicDucked(false);
        setRepeatQuestionEnabled(true);
        if (onEnd) onEnd();
        return;
      }
      const seg = segments[idx++];
      const utt = new SpeechSynthesisUtterance(seg.text);
      utt.lang = lang;
      if (preferredVoice) {
        utt.voice = preferredVoice;
      }
      // Apply base rate, then adjust for emphasis
      // Slightly faster (0.9) sounds more natural and conversational
      const baseRate = typeof ttsRate === "number" ? ttsRate : 0.9;
      utt.rate = baseRate * (seg.rateMultiplier || 1.0);
      
      // Apply pitch shift for questions with slight natural variation
      // Add tiny random variation (0.98-1.02) to avoid robotic monotone
      const pitchVariation = 0.98 + (Math.random() * 0.04);
      utt.pitch = pitchVariation + (seg.pitchShift || 0);
      
      // Normalize volume at 0.95 (prevents clipping while staying clear)
      utt.volume = typeof ttsVolume === "number" ? ttsVolume : 0.95;
      utt.onstart = () => {
        if (myGeneration !== speakGeneration) return;
        isSpeaking = true;
        setStatus("Speaking...");
        setRepeatQuestionEnabled(false);
      };
      utt.onend = () => {
        if (myGeneration !== speakGeneration) return;
        setTimeout(speakSegment, seg.pause);
      };
      utt.onerror = (err) => {
        console.error("TTS error:", err);
        setTimeout(speakSegment, seg.pause);
      };
      window.speechSynthesis.speak(utt);
    }
    speakSegment();
  }

  // Ensure voices are loaded before speaking
  if (window.speechSynthesis.getVoices().length === 0) {
    window.speechSynthesis.onvoiceschanged = function handler() {
      window.speechSynthesis.onvoiceschanged = null;
      startSpeaking();
    };
  } else {
    startSpeaking();
  }
}

    function stopListeningForCommand() {
      keepListening = false;
      if (recognition) {
        try {
          recognition.onresult = null;
          recognition.onerror = null;
          recognition.onend = null;
          recognition.stop();
        } catch (e) {}
      }
    }

    function listenForCommand(callback) {
      if (isMicMuted) {
  // Don‚Äôt listen while muted
  return;
}

      // 2) Fallback: Browser Web SpeechRecognition
      if (!speechSupported || !recognition) {
        setStatus("Speech recognition not supported in this browser.");
        return;
      }
      setStatus("Listening...");
      keepListening = true;

      recognition.onresult = (event) => {
  keepListening = false;

  const res = event.results && event.results[0];
  if (!res) return callback("");

  // Collect all alternatives (you set recognition.maxAlternatives = 3)
  const alts = [];
  for (let i = 0; i < res.length; i++) {
    if (res[i] && res[i].transcript) alts.push(res[i].transcript);
  }
  if (alts.length === 0) return callback("");

  // Pick the first alternative that parses into a rating command
  for (const alt of alts) {
    if (parseRatingFromText(alt)) {
      callback(alt);
      return;
    }
  }

  // Otherwise fall back to the top alternative for global commands, etc.
  callback(alts[0]);
};
      recognition.onerror = (event) => {
        console.error("STT error:", event.error);
        keepListening = false;
        if (event.error !== "not-allowed") {
          setTimeout(() => listenForCommand(callback), 800);
        } else {
          setStatus("Microphone access blocked.");
        }
      };
      recognition.onend = () => {
  if (keepListening && currentMode === "voice" && !isMicMuted) {
    try {
      recognition.start();
    } catch (e) {
      console.error("Error restarting recognition:", e);
    }
  }
};
      try {
        recognition.start();
      } catch (e) {
        console.error("Error starting recognition:", e);
      }
    }

    // ===================== STUDY LOGIC (DUE / AHEAD) =====================
    function getTodayBounds() {
  const start = new Date();
  start.setHours(0, 0, 0, 0);
  const end = new Date();
  end.setHours(23, 59, 59, 999);
  return { startMs: start.getTime(), endMs: end.getTime() };
}

    function splitOverdueAndDue(deckId, cards) {
  const now = Date.now();
  const { startMs, endMs } = getTodayBounds();
  const overdue = [];
  const due = [];

  cards.forEach(card => {
    const key = scheduleKey(deckId, card.id);
    const s = schedule[key];

    // New cards = due today (not overdue)
    if (!s) {
      due.push(card);
      return;
    }

    const { dueTime } = normalizeScheduleEntry(s);
    if (dueTime <= endMs) {
      if (dueTime < startMs) {
        overdue.push(card);
      } else {
        due.push(card);
      }
    }
  });

  return { overdue, due };
}

    function getDueCardsForDeck(deckId, allowAhead, includeOverdue) {
      const deck = getDeckById(deckId);
      if (!deck) return [];
      const now = Date.now();
      const { startMs, endMs } = getTodayBounds();

      const filtered = deck.cards.filter(card => {
        const key = scheduleKey(deckId, card.id);
        const s = schedule[key];

        // New cards: treat as due now
        if (!s) {
          if (!allowAhead) return true;
          if (includeOverdue) return true;
          return true;
        }

        const normalized = normalizeScheduleEntry(s);
        const due = normalized.dueTime || now;
        const isDueToday = due <= endMs;
        const isOverdue = due < startMs;
        const isFuture = due > endMs;

        if (!allowAhead) {
          return isDueToday;
        }

        if (isFuture) return true;
        if (includeOverdue && (isOverdue || isDueToday)) return true;
        return isDueToday;
      });

      // üö® NEW: If no cards are due, check for short-interval cards and include them immediately
      if (!allowAhead && filtered.length === 0) {
        const shortIntervalCards = deck.cards.filter(card => {
          const key = scheduleKey(deckId, card.id);
          const s = schedule[key];
          if (!s) return false;
          const normalized = normalizeScheduleEntry(s);
          return normalized.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES && normalized.dueTime > now;
        });
        filtered.push(...shortIntervalCards);
      }

      // Still sort by dueTime so earlier due cards are "earlier" in the day,
      // but we will add randomness at selection time.
      return filtered.sort((a, b) => {
        const ka = scheduleKey(deckId, a.id);
        const kb = scheduleKey(deckId, b.id);
        const sa = schedule[ka];
        const sb = schedule[kb];
        const na = sa ? normalizeScheduleEntry(sa).dueTime : 0;
        const nb = sb ? normalizeScheduleEntry(sb).dueTime : 0;
        return na - nb;
      });
    }

    function getNextCardForDeck(deckId, allowAhead, includeOverdue) {
      const dueCards = getDueCardsForDeck(deckId, allowAhead, includeOverdue);
      if (dueCards.length === 0) return null;
      return dueCards[0];
    }
    // ===================== STUDY PREFS (persist across sessions) =====================
const STUDY_PREFS_KEY = "zc_studyPrefs";

function getStudyPrefs() {
  let p = {};
  try { p = JSON.parse(localStorage.getItem(STUDY_PREFS_KEY) || "{}"); } catch { p = {}; }

  // Defaults (match your current defaults)
  if (typeof p.skipInstructionsAfterFirst !== "boolean") p.skipInstructionsAfterFirst = true;
  if (typeof p.disableOpeningPrompt !== "boolean") p.disableOpeningPrompt = false;
  if (typeof p.answerMode !== "string") p.answerMode = "voice"; // "delay" | "voice"
  if (typeof p.answerDelaySec !== "number") p.answerDelaySec = 10;
  if (typeof p.answerToRatingDelaySec !== "number") p.answerToRatingDelaySec = 5;
  if (typeof p.autoGoodMode !== "boolean") p.autoGoodMode = false;
  if (typeof p.autoModeBehavior !== "string") p.autoModeBehavior = "good"; // again|hard|good|easy|tomorrow
  if (typeof p.handsFreeNextDelaySec !== "number") p.handsFreeNextDelaySec = 3;
  if (typeof p.studyAheadGapSec !== "number") p.studyAheadGapSec = 6;
  if (typeof p.autoEnterStudyAhead !== "boolean") p.autoEnterStudyAhead = true;
  if (typeof p.loopStudyAhead !== "boolean") p.loopStudyAhead = true;
  if (typeof p.restateQuestionInAnswer !== "boolean") p.restateQuestionInAnswer = true; // default enabled

  // Clamp numeric values
  p.answerDelaySec = Math.max(3, Math.min(60, Math.floor(p.answerDelaySec)));
  p.answerToRatingDelaySec = Math.max(3, Math.min(30, Math.floor(p.answerToRatingDelaySec)));
  p.handsFreeNextDelaySec = Math.max(3, Math.min(30, Math.floor(p.handsFreeNextDelaySec)));
  p.studyAheadGapSec = Math.max(3, Math.min(60, Math.floor(p.studyAheadGapSec)));

  return p;
}

function saveStudyPrefs(patch = {}) {
  const cur = getStudyPrefs();
  const next = { ...cur, ...patch };
  localStorage.setItem(STUDY_PREFS_KEY, JSON.stringify(next));
  return next;
}


    // ===================== STUDY SESSION STATE =====================
    const mainMenuDiv = document.getElementById("mainMenu");
    const studySectionDiv = document.getElementById("studySection");
    const modeBadge = document.getElementById("modeBadge");
    const backToMenuBtn = document.getElementById("backToMenuBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const resumeBtn = document.getElementById("resumeBtn");
    const studyInstructionsBtn = document.getElementById("studyInstructionsBtn");

    const skipInstructionsAfterFirstCheckbox = document.getElementById("skipInstructionsAfterFirst");
    const disableOpeningPromptCheckbox = document.getElementById("disableOpeningPrompt");
    const autoGoodToggle = document.getElementById("autoGoodToggle");
    const autoRatingSelect = document.getElementById("autoRatingSelect");
    const answerModeDelayRadio = document.getElementById("answerModeDelay");
    const answerModeVoiceRadio = document.getElementById("answerModeVoice");
    const answerDelaySecondsInput = document.getElementById("answerDelaySeconds");
    const answerToRatingDelaySecondsInput = document.getElementById("answerToRatingDelaySeconds");
      const handsFreeNextDelaySecondsInput = document.getElementById("handsFreeNextDelaySeconds");
    const studyAheadGapSecondsInput = document.getElementById("studyAheadGapSeconds");
const autoEnterStudyAheadCheckbox = document.getElementById("autoEnterStudyAhead");
const loopStudyAheadCheckbox = document.getElementById("loopStudyAhead");
    const restateQuestionInAnswerCheckbox = document.getElementById("restateQuestionInAnswer");
    const startVoiceBtn = document.getElementById("startVoiceBtn");

    const startSilentBtn = document.getElementById("startSilentBtn");


    const silentUI = document.getElementById("silentUI");
    const silentQuestion = document.getElementById("silentQuestion");
    const silentQuestionText = document.getElementById("silentQuestionText");
    const silentAnswer = document.getElementById("silentAnswer");
    const silentAnswerText = document.getElementById("silentAnswerText");
    const showAnswerBtn = document.getElementById("showAnswerBtn");
    const silentRatingButtons = document.getElementById("silentRatingButtons");

    const hintAgain = document.getElementById("hint-again");
    const hintHard = document.getElementById("hint-hard");
    const hintGood = document.getElementById("hint-good");
    const hintEasy = document.getElementById("hint-easy");

    const voiceHintAgain = document.getElementById("voice-hint-again");
    const voiceHintHard = document.getElementById("voice-hint-hard");
    const voiceHintGood = document.getElementById("voice-hint-good");
    const voiceHintEasy = document.getElementById("voice-hint-easy");

    const voiceUI = document.getElementById("voiceUI");
    const voiceQuestion = document.getElementById("voiceQuestion");
    const voiceQuestionText = document.getElementById("voiceQuestionText");
    const voiceAnswer = document.getElementById("voiceAnswer");
    const voiceAnswerText = document.getElementById("voiceAnswerText");
        const voiceRatingButtons = document.getElementById("voiceRatingButtons");
        const voiceFlashcard = document.getElementById("voiceFlashcard");
        const silentFlashcard = document.getElementById("silentFlashcard");
        function setFlashcardFlipped(mode, flipped) {
        const el = mode === "voice" ? voiceFlashcard : silentFlashcard;
        if (!el) return;
        el.classList.toggle("flipped", !!flipped);
      }
        function isFlashcardFlipped(mode) {
        const el = mode === "voice" ? voiceFlashcard : silentFlashcard;
        return !!el?.classList?.contains("flipped");
      }
        function setVoiceRatingButtonsEnabled(enabled) {
  if (!voiceRatingButtons) return;
  voiceRatingButtons
    .querySelectorAll('button[data-voice-rating]')
    .forEach(b => (b.disabled = !enabled));
}
        function setVoiceSkipToAnswerEnabled(enabled) {
  if (!voiceSkipToAnswerBtn) return;
  voiceSkipToAnswerBtn.disabled = !enabled;
}
        function setPauseResumeEnabled(enabled) {
  if (!pauseBtn || !resumeBtn) return;
  // Only enable pause if not currently paused, only enable resume if paused
  if (enabled) {
    pauseBtn.disabled = isPaused;
    resumeBtn.disabled = !isPaused;
  } else {
    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
  }
}
        function setRepeatQuestionEnabled(enabled) {
  if (voiceRepeatQuestionBtn) voiceRepeatQuestionBtn.disabled = !enabled;
  if (silentRepeatQuestionBtn) silentRepeatQuestionBtn.disabled = !enabled;
}
        function setAddCardEnabled(enabled) {
  if (studyAddCardBtn) studyAddCardBtn.disabled = !enabled;
}

    const silentNextCardBtn = document.getElementById("silentNextCardBtn");

    const silentEditToggleBtn = document.getElementById("silentEditToggleBtn");
    const silentEditPanel = document.getElementById("silentEditPanel");
    const silentEditQuestion = document.getElementById("silentEditQuestion");
    const silentEditAnswer = document.getElementById("silentEditAnswer");
    const silentSaveEditBtn = document.getElementById("silentSaveEditBtn");
    const silentCancelEditBtn = document.getElementById("silentCancelEditBtn");
    const silentRepeatQuestionBtn = document.getElementById("silentRepeatQuestionBtn");

    const voiceSkipToAnswerBtn = document.getElementById("voiceSkipToAnswerBtn");
    const voiceRepeatQuestionBtn = document.getElementById("voiceRepeatQuestionBtn");
    const voiceEditToggleBtn = document.getElementById("voiceEditToggleBtn");
    const voiceEditPanel = document.getElementById("voiceEditPanel");
    const voiceEditQuestion = document.getElementById("voiceEditQuestion");
    const voiceEditAnswer = document.getElementById("voiceEditAnswer");
    const voiceSaveEditBtn = document.getElementById("voiceSaveEditBtn");
    const voiceCancelEditBtn = document.getElementById("voiceCancelEditBtn");

    const silentCompletionControls = document.getElementById("silentCompletionControls");
    const silentMainMenuBtn = document.getElementById("silentMainMenuBtn");
    const silentStudyAheadBtn = document.getElementById("silentStudyAheadBtn");

    let currentMode = null;
    let currentDeckId = null;
    let currentCard = null;

    function applyStudyPrefsToUIAndState() {
  const p = getStudyPrefs();

  // UI controls
  if (skipInstructionsAfterFirstCheckbox) skipInstructionsAfterFirstCheckbox.checked = !!p.skipInstructionsAfterFirst;
  if (disableOpeningPromptCheckbox) disableOpeningPromptCheckbox.checked = !!p.disableOpeningPrompt;

  if (answerModeVoiceRadio && answerModeDelayRadio) {
    answerModeVoiceRadio.checked = (p.answerMode === "voice");
    answerModeDelayRadio.checked = (p.answerMode !== "voice");
  }

  if (answerDelaySecondsInput) answerDelaySecondsInput.value = String(p.answerDelaySec);
  if (answerToRatingDelaySecondsInput) answerToRatingDelaySecondsInput.value = String(p.answerToRatingDelaySec);

  if (autoGoodToggle) autoGoodToggle.checked = !!p.autoGoodMode;

  if (autoRatingSelect) autoRatingSelect.value = p.autoModeBehavior || "good";

  if (handsFreeNextDelaySecondsInput) handsFreeNextDelaySecondsInput.value = String(p.handsFreeNextDelaySec);

  if (studyAheadGapSecondsInput) studyAheadGapSecondsInput.value = String(p.studyAheadGapSec);

  if (autoEnterStudyAheadCheckbox) autoEnterStudyAheadCheckbox.checked = !!p.autoEnterStudyAhead;
  if (loopStudyAheadCheckbox) loopStudyAheadCheckbox.checked = !!p.loopStudyAhead;

  if (restateQuestionInAnswerCheckbox) {
    restateQuestionInAnswerCheckbox.checked = (p.restateQuestionInAnswer !== false); // default true
  }

  // Make auto rating select enabled/disabled correctly
  if (autoRatingSelect && autoGoodToggle) {
    autoRatingSelect.disabled = !autoGoodToggle.checked;
  }

  // Hands-free next delay disabled when autoGoodMode is enabled (your existing behavior)
  if (handsFreeNextDelaySecondsInput && autoGoodToggle) {
    handsFreeNextDelaySecondsInput.disabled = autoGoodToggle.checked;
  }

  // State variables (these are what your runtime uses)
  skipInstructionsAfterFirst = !!p.skipInstructionsAfterFirst;
  disableOpeningPrompt = !!p.disableOpeningPrompt;
  answerMode = p.answerMode === "voice" ? "voice" : "delay";
  answerDelayMs = p.answerDelaySec * 1000;
  answerToRatingDelayMs = p.answerToRatingDelaySec * 1000;

  autoGoodMode = !!p.autoGoodMode;
  autoModeBehavior = p.autoModeBehavior || "good";

  handsFreeNextDelayMs = p.handsFreeNextDelaySec * 1000;
  studyAheadGapMs = p.studyAheadGapSec * 1000;

  autoEnterStudyAhead = !!p.autoEnterStudyAhead;
  loopStudyAhead = !!p.loopStudyAhead;

  restateQuestionEnabled = (p.restateQuestionInAnswer !== false); // default true
}
function wireStudyPrefsListeners() {
  if (skipInstructionsAfterFirstCheckbox) {
    skipInstructionsAfterFirstCheckbox.addEventListener("change", () => {
      const next = saveStudyPrefs({ skipInstructionsAfterFirst: !!skipInstructionsAfterFirstCheckbox.checked });
      applyStudyPrefsToUIAndState();
    });
  }

  if (disableOpeningPromptCheckbox) {
    disableOpeningPromptCheckbox.addEventListener("change", () => {
      const next = saveStudyPrefs({ disableOpeningPrompt: !!disableOpeningPromptCheckbox.checked });
      applyStudyPrefsToUIAndState();
    });
  }

  if (answerModeVoiceRadio) {
    answerModeVoiceRadio.addEventListener("change", () => {
      if (answerModeVoiceRadio.checked) {
        saveStudyPrefs({ answerMode: "voice" });
        applyStudyPrefsToUIAndState();
      }
    });
  }

  if (answerModeDelayRadio) {
    answerModeDelayRadio.addEventListener("change", () => {
      if (answerModeDelayRadio.checked) {
        saveStudyPrefs({ answerMode: "delay" });
        applyStudyPrefsToUIAndState();
      }
    });
  }

  if (answerDelaySecondsInput) {
    answerDelaySecondsInput.addEventListener("change", () => {
      const sec = Math.max(1, Math.min(60, parseInt(answerDelaySecondsInput.value, 10) || 4));
      answerDelaySecondsInput.value = String(sec);
      saveStudyPrefs({ answerDelaySec: sec });
      applyStudyPrefsToUIAndState();
    });
  }

  if (answerToRatingDelaySecondsInput) {
    answerToRatingDelaySecondsInput.addEventListener("change", () => {
      const sec = Math.max(0, Math.min(30, parseInt(answerToRatingDelaySecondsInput.value, 10) || 0));
      answerToRatingDelaySecondsInput.value = String(sec);
      saveStudyPrefs({ answerToRatingDelaySec: sec });
      applyStudyPrefsToUIAndState();
    });
  }

  if (autoGoodToggle) {
    autoGoodToggle.addEventListener("change", () => {
      saveStudyPrefs({ autoGoodMode: !!autoGoodToggle.checked });
      applyStudyPrefsToUIAndState();
    });
  }

  if (autoRatingSelect) {
    autoRatingSelect.addEventListener("change", () => {
      saveStudyPrefs({ autoModeBehavior: autoRatingSelect.value || "good" });
      applyStudyPrefsToUIAndState();
    });
  }

  if (handsFreeNextDelaySecondsInput) {
    handsFreeNextDelaySecondsInput.addEventListener("change", () => {
      const sec = Math.max(0, Math.min(30, parseInt(handsFreeNextDelaySecondsInput.value, 10) || 0));
      handsFreeNextDelaySecondsInput.value = String(sec);
      saveStudyPrefs({ handsFreeNextDelaySec: sec });
      applyStudyPrefsToUIAndState();
    });
  }

  if (studyAheadGapSecondsInput) {
    studyAheadGapSecondsInput.addEventListener("change", () => {
      const sec = Math.max(1, Math.min(60, parseInt(studyAheadGapSecondsInput.value, 10) || 4));
      studyAheadGapSecondsInput.value = String(sec);
      saveStudyPrefs({ studyAheadGapSec: sec });
      applyStudyPrefsToUIAndState();
    });
  }

  if (autoEnterStudyAheadCheckbox) {
    autoEnterStudyAheadCheckbox.addEventListener("change", () => {
      saveStudyPrefs({ autoEnterStudyAhead: !!autoEnterStudyAheadCheckbox.checked });
      applyStudyPrefsToUIAndState();
    });
  }

  if (loopStudyAheadCheckbox) {
    loopStudyAheadCheckbox.addEventListener("change", () => {
      saveStudyPrefs({ loopStudyAhead: !!loopStudyAheadCheckbox.checked });
      applyStudyPrefsToUIAndState();
    });
  }

  if (restateQuestionInAnswerCheckbox) {
    restateQuestionInAnswerCheckbox.addEventListener("change", () => {
      saveStudyPrefs({ restateQuestionInAnswer: !!restateQuestionInAnswerCheckbox.checked });
      applyStudyPrefsToUIAndState();
    });
  }
}



    // ***** STATE MACHINE FOR CARD FLOW *****
    const StudyState = {
      IDLE: "idle",
      SHOWING_QUESTION: "showing_question",
      WAITING_FOR_ANSWER: "waiting_for_answer",
      SHOWING_ANSWER: "showing_answer",
      WAITING_FOR_RATING: "waiting_for_rating"
    };

    let studyState = StudyState.IDLE;

    function setStudyState(newState) {
      studyState = newState;
    }
    // ***** END STATE MACHINE DEFINITIONS *****

    let studyAheadSession = false;
    let noScheduleChanges = false;
    let studyAheadPromptedOnceVoice = false;
    let autoEnterStudyAhead = false;  // from Study Options
let loopStudyAhead = false;       // from Study Options
    let skipInstructionsAfterFirst = true;
    let disableOpeningPrompt = false;
    let hasSpokenInstructionsOnce = false;
    let answerMode = "delay";
    let answerDelayMs = 4000;
    let answerToRatingDelayMs = 0;
    let autoGoodMode = false;
    let handsFreeNextDelayMs = 2000;
    // Disable handsFreeNextDelaySecondsInput when autoGood is enabled
    if (handsFreeNextDelaySecondsInput && autoGoodToggle) {
      function updateHandsFreeDelayEnabled() {
        handsFreeNextDelaySecondsInput.disabled = autoGoodToggle.checked;
      }
      autoGoodToggle.addEventListener('change', updateHandsFreeDelayEnabled);
      updateHandsFreeDelayEnabled();
      handsFreeNextDelaySecondsInput.addEventListener('input', () => {
        handsFreeNextDelayMs = Math.max(0, Math.min(30, Number(handsFreeNextDelaySecondsInput.value))) * 1000;
      });
      // Initialize value
      handsFreeNextDelayMs = Math.max(0, Math.min(30, Number(handsFreeNextDelaySecondsInput.value))) * 1000;
    }
    let autoModeBehavior = "good"; // again | hard | good | easy | tomorrow
    let restateQuestionEnabled = true; // Whether to prepend question-as-statement to answers

    function runVoiceLoopAfterRating() {
      setStudyState(StudyState.IDLE);
      const autoGoodEnabled = !!autoGoodToggle?.checked;
      const delayMs = Math.max(0, Number(handsFreeNextDelayMs || 0));
      clearAfterRatingDelayTimer();
      if (!autoGoodEnabled && delayMs > 0) {
        afterRatingDueMs = Date.now() + delayMs;
        afterRatingTimerId = setTimeout(() => {
          afterRatingTimerId = null;
          afterRatingDueMs = 0;
          if (!isPaused) runVoiceLoop();
        }, delayMs);
      } else {
        afterRatingDueMs = 0;
        runVoiceLoop();
      }
    }

    let studyAheadGapMs = 4000;
    const difficultyPromptGraceMs = 1200;
    let lastDifficultyPromptAt = 0;
    let cardSuspendedForAddCard = null;
    let cardSuspendedFlippedState = false;

    function startDifficultyListening() {
      lastDifficultyPromptAt = Date.now();
      listenForCommand(handleVoiceTranscript);
    }
    let inStudyAheadAnswerGap = false;
    let studyAheadRepeatAnswerActive = false;
    let pendingStudyAheadAdvance = false;
    let answerAfterSpeechTimerId = null;
let answerAfterSpeechDueMs = 0;
  let answerToRatingDueMs = 0;
  let afterRatingDueMs = 0;
let inAnswerAfterSpeechDelay = false;
let answerAfterSpeechCountdownInterval = null;

function clearAnswerAfterSpeechDelay() {
  if (answerAfterSpeechTimerId !== null) {
    clearTimeout(answerAfterSpeechTimerId);
    answerAfterSpeechTimerId = null;
  }
  if (answerAfterSpeechCountdownInterval !== null) {
    clearInterval(answerAfterSpeechCountdownInterval);
    answerAfterSpeechCountdownInterval = null;
  }
  inAnswerAfterSpeechDelay = false;
  answerAfterSpeechDueMs = 0;
}
function startOrResetAnswerAfterSpeechDelay() {
  const s = getTtsSettingsObj();
  const sec = clamp(Number(s.answerDelayAfterSpeechSec || 0), 0, 30);

  if (sec === 0) {
    clearAnswerAfterSpeechDelay();
    speakAnswerThenAskDifficulty();
    return;
  }

  clearAnswerAfterSpeechDelay();
  inAnswerAfterSpeechDelay = true;
  answerAfterSpeechDueMs = Date.now() + sec * 1000;

  // Start countdown display
  const startTime = Date.now();
  const updateCountdown = () => {
    const elapsed = Date.now() - startTime;
    const remaining = Math.max(0, Math.ceil((sec * 1000 - elapsed) / 1000));
    if (remaining > 0) {
      setStatus(`Answer in ${remaining} second${remaining !== 1 ? 's' : ''}...`);
    } else {
      setStatus('');
    }
  };
  updateCountdown(); // Show immediately
  answerAfterSpeechCountdownInterval = setInterval(updateCountdown, 1000);

  // ‚úÖ keep the mic open during this window so any speech resets the timer
  if (currentMode === "voice" && !isPaused) {
    listenForCommand(handleVoiceTranscript);
  }

  answerAfterSpeechTimerId = setTimeout(() => {
    inAnswerAfterSpeechDelay = false;
    answerAfterSpeechTimerId = null;
    if (answerAfterSpeechCountdownInterval !== null) {
      clearInterval(answerAfterSpeechCountdownInterval);
      answerAfterSpeechCountdownInterval = null;
    }
    setStatus('');
    speakAnswerThenAskDifficulty();
  }, sec * 1000);
}

    let studyAheadGapTimerId = null;
    let studyAheadCountdownInterval = null;

    let isPaused = false;
    let restartCardOnResumeVoice = false; // NEW: when resuming voice mode, replay current card
    let awaitingDifficulty = false;
    let awaitingAnswerSignal = false;
    let awaitingPostCompletionChoice = false;

    let reviewQueue = [];
    let aheadQueue = [];
    let aheadQueueIndex = 0;
// ===== Mic mute feature (voice-answer gap only) =====
let isMicMuted = false;
let micMutedUntilMs = 0;
let micMuteIntervalId = null;
let awaitingMuteSeconds = false;

// DOM refs (safe here because index.html already loaded)
const micMuteTimerEl = document.getElementById("micMuteTimer");
const micMuteSecondsEl = document.getElementById("micMuteSeconds");
const voiceTimersEl = document.getElementById("voiceTimers");
const timerAnswerAfterSpeechEl = document.getElementById("timerAnswerAfterSpeech");
const timerAnswerToRatingEl = document.getElementById("timerAnswerToRating");
const timerAfterRatingEl = document.getElementById("timerAfterRating");


    // NEW: track if question/answer have been spoken for current card
    let hasSpokenCurrentQuestion = false;
    let hasSpokenCurrentAnswer = false;

    // NEW: track delay window between question and answer in delay mode
    let questionDelayTimerId = null;
    let questionDelayCountdownInterval = null;
     let autoGoodNextCardTimerId = null;
    let answerToRatingDelayTimerId = null;

function clearAnswerToRatingDelayTimer() {
  if (answerToRatingDelayTimerId !== null) {
    clearTimeout(answerToRatingDelayTimerId);
    answerToRatingDelayTimerId = null;
  }
  answerToRatingDueMs = 0;
}

let afterRatingTimerId = null;
function clearAfterRatingDelayTimer() {
  if (afterRatingTimerId !== null) {
    clearTimeout(afterRatingTimerId);
    afterRatingTimerId = null;
  }
  afterRatingDueMs = 0;
}

function updateVoiceTimers() {
  if (!voiceTimersEl || currentMode !== "voice") return;
  const now = Date.now();
  const answerRemaining = Math.max(0, Math.ceil((answerAfterSpeechDueMs - now) / 1000));
  const ratingRemaining = Math.max(0, Math.ceil((answerToRatingDueMs - now) / 1000));
  const nextRemaining = Math.max(0, Math.ceil((afterRatingDueMs - now) / 1000));

  const showAnswer = answerAfterSpeechDueMs > now;
  const showRating = answerToRatingDueMs > now;
  const showNext = afterRatingDueMs > now;

  if (!showAnswer && !showRating && !showNext) {
    voiceTimersEl.classList.add("hidden");
    return;
  }

  voiceTimersEl.classList.remove("hidden");
  if (timerAnswerAfterSpeechEl) timerAnswerAfterSpeechEl.textContent = String(answerRemaining);
  if (timerAnswerToRatingEl) timerAnswerToRatingEl.textContent = String(ratingRemaining);
  if (timerAfterRatingEl) timerAfterRatingEl.textContent = String(nextRemaining);
}

setInterval(updateVoiceTimers, 250);

function clearAutoGoodNextCardTimer() {
  if (autoGoodNextCardTimerId !== null) {
    clearTimeout(autoGoodNextCardTimerId);
    autoGoodNextCardTimerId = null;
  }
}


    function clearStudyAheadGapTimer() {
      if (studyAheadGapTimerId !== null) {
        clearTimeout(studyAheadGapTimerId);
        studyAheadGapTimerId = null;
      }
      if (studyAheadCountdownInterval !== null) {
        clearInterval(studyAheadCountdownInterval);
        studyAheadCountdownInterval = null;
      }
      inStudyAheadAnswerGap = false;
    }

    function clearQuestionDelayTimer() {
      if (questionDelayTimerId !== null) {
        clearTimeout(questionDelayTimerId);
        questionDelayTimerId = null;
      }
      if (questionDelayCountdownInterval !== null) {
        clearInterval(questionDelayCountdownInterval);
        questionDelayCountdownInterval = null;
      }
      questionDelayDueMs = 0;
    }

    function startOrResetQuestionDelayTimer() {
      clearQuestionDelayTimer();
      const delay = Math.max(
        1,
        Math.min(60, Math.floor(answerDelayMs / 1000))
      );
      setStudyState(StudyState.WAITING_FOR_ANSWER);
      
      // Start countdown display
      const startTime = Date.now();
      const updateCountdown = () => {
        const elapsed = Date.now() - startTime;
        const remaining = Math.max(0, Math.ceil((delay * 1000 - elapsed) / 1000));
        if (remaining > 0) {
          setStatus(`Answer in ${remaining} second${remaining !== 1 ? 's' : ''}...`);
        } else {
          setStatus('');
        }
      };
      updateCountdown(); // Show immediately
      questionDelayCountdownInterval = setInterval(updateCountdown, 1000);
      
      questionDelayTimerId = setTimeout(() => {
        questionDelayTimerId = null;
        questionDelayDueMs = 0;
        if (questionDelayCountdownInterval !== null) {
          clearInterval(questionDelayCountdownInterval);
          questionDelayCountdownInterval = null;
        }
        setStatus('');
        if (!isPaused) {
          speakAnswerThenAskDifficulty();
        }
      }, delay * 1000);
    }
    function clearMicMuteTimer() {
  if (micMuteIntervalId !== null) {
    clearInterval(micMuteIntervalId);
    micMuteIntervalId = null;
  }
  isMicMuted = false;
  micMutedUntilMs = 0;
  awaitingMuteSeconds = false;
  if (micMuteTimerEl) micMuteTimerEl.classList.add("hidden");
}

function updateMicMuteCountdownUI() {
  if (!micMuteTimerEl || !micMuteSecondsEl) return;
  const remainingMs = Math.max(0, micMutedUntilMs - Date.now());
  const remainingSec = Math.ceil(remainingMs / 1000);
  micMuteSecondsEl.textContent = String(remainingSec);
}

function startMicMute(seconds) {
  const sec = Math.max(0, Math.min(60, Number(seconds || 0)));
  isMicMuted = true;
  setStatus("Mic temporarily muted...");
  micMutedUntilMs = Date.now() + sec * 1000;

  // Stop any live listening immediately
  keepListening = false;
  if (recognition) {
    try { recognition.stop(); } catch (_) {}
  }

  if (micMuteTimerEl) micMuteTimerEl.classList.remove("hidden");
  updateMicMuteCountdownUI();

  if (micMuteIntervalId !== null) clearInterval(micMuteIntervalId);
  micMuteIntervalId = setInterval(() => {
    const remaining = micMutedUntilMs - Date.now();
    if (remaining <= 0) {
      clearInterval(micMuteIntervalId);
      micMuteIntervalId = null;
      isMicMuted = false;
      if (micMuteTimerEl) micMuteTimerEl.classList.add("hidden");

      // If we are STILL in the answer gap, resume listening for the ‚Äúanswer to show answer‚Äù
      if (!isPaused && currentMode === "voice" && awaitingAnswerSignal) {
        setStatus("Listening for your answer...");
        listenForCommand(handleVoiceTranscript);
      }
      return;
    }
    updateMicMuteCountdownUI();
  }, 250);
}

    function queueCardForAgain(deckId, cardObj) {
      if (!cardObj) return;
      const key = scheduleKey(deckId, cardObj.id);
      const exists = reviewQueue.some((c) => scheduleKey(deckId, c.id) === key);
      if (!exists) {
        reviewQueue.push(cardObj);
      }
    }

    async function showMainMenu() {
    await stopAllAudio();
      clearStudyAheadGapTimer();
      clearQuestionDelayTimer();
      clearAnswerToRatingDelayTimer();

      // Do NOT clear currentCard here, so it is preserved for resuming study
      currentMode = null;
      mainMenuDiv.classList.remove("hidden");
      studySectionDiv.classList.add("hidden");
      setStatus("");
      isPaused = false;
      awaitingDifficulty = false;
      awaitingAnswerSignal = false;
      awaitingPostCompletionChoice = false;
      resumeBtn.disabled = true;
      pauseBtn.disabled = false;
      pauseBtn.classList.remove("hidden");
      resumeBtn.classList.remove("hidden");
      silentNextCardBtn.classList.add("hidden");
      studyAheadSession = false;
      noScheduleChanges = false;
      studyAheadPromptedOnceVoice = false;
      reviewQueue = [];
      aheadQueue = [];
      aheadQueueIndex = 0;
      hasSpokenCurrentQuestion = false;
      hasSpokenCurrentAnswer = false;
      silentCompletionControls.classList.add("hidden");
      if (voiceQuestionText) voiceQuestionText.textContent = "";
      if (voiceAnswerText) voiceAnswerText.textContent = "";
      setFlashcardFlipped("voice", false);
      silentEditPanel.classList.add("hidden");
      voiceEditPanel.classList.add("hidden");
            if (voiceRatingButtons) voiceRatingButtons.classList.add("hidden");
      setStudyState(StudyState.IDLE);
    }
function updateDeckBadge() {
  if (!deckBadge) return;
  const deck = getDeckById(currentDeckId);
  deckBadge.textContent = deck ? `Deck: ${deck.name}` : "";
}

async function openAddCardModal() {
  // Store the current card so we can resume it after closing the modal
  cardSuspendedForAddCard = currentCard;
  cardSuspendedFlippedState = isFlashcardFlipped(currentMode);
  
  // Stop audio/listening so the modal is calm in hands-free mode
  await stopAllAudio();
  clearStudyAheadGapTimer();
  clearQuestionDelayTimer();
  refreshCardLanguageDropdownsForCurrentDeck(null);


  if (addCardModalStatus) addCardModalStatus.textContent = "";
  if (addCardModalQuestion) addCardModalQuestion.value = "";
  if (addCardModalAnswer) addCardModalAnswer.value = "";

  addCardModal.classList.remove("hidden");
  addCardModal.setAttribute("aria-hidden", "false");
  if (addCardModalQuestion) addCardModalQuestion.focus();
}

function closeAddCardModal() {
  addCardModal.classList.add("hidden");
  addCardModal.setAttribute("aria-hidden", "true");

  // If we had a suspended card, restore it instead of advancing to next card
  if (cardSuspendedForAddCard && !isPaused) {
    currentCard = cardSuspendedForAddCard;
    const wasFlipped = cardSuspendedFlippedState;
    cardSuspendedForAddCard = null;
    cardSuspendedFlippedState = false;
    
    if (currentMode === "voice") {
      // Re-show the card content
      setCardContent(voiceQuestionText, currentCard.question);
      setCardContent(voiceAnswerText, currentCard.answer);
      setFlashcardFlipped("voice", wasFlipped);
      
      // Replay the answer and continue to rating prompt
      speakAnswerThenAskDifficulty();
      return;
    }
    
    if (currentMode === "silent") {
      // Restore the same card and side in silent mode
      setCardContent(silentQuestionText, currentCard.question);
      setCardContent(silentAnswerText, currentCard.answer);
      setFlashcardFlipped("silent", wasFlipped);
      
      // Restore UI state based on which side was showing
      if (wasFlipped) {
        // Answer was showing - show rating buttons
        if (showAnswerBtn) showAnswerBtn.classList.add("hidden");
        if (silentRatingButtons && !noScheduleChanges) {
          silentRatingButtons.classList.remove("hidden");
          updateSilentDueHints();
        }
        if (noScheduleChanges && silentNextCardBtn) {
          silentNextCardBtn.classList.remove("hidden");
        }
      } else {
        // Question was showing - show "Show Answer" button
        if (showAnswerBtn) showAnswerBtn.classList.remove("hidden");
        if (silentRatingButtons) silentRatingButtons.classList.add("hidden");
        if (silentNextCardBtn) silentNextCardBtn.classList.add("hidden");
      }
      return;
    }
  }
  
  // Clear the suspended card flag
  cardSuspendedForAddCard = null;
  cardSuspendedFlippedState = false;
  
  // Normal flow: advance to next card (only if no suspended card)
  if (currentMode === "voice" && !isPaused) runVoiceLoop();
  if (currentMode === "silent" && !isPaused) runSilentLoop();
}
async function openInstructionsModal() {
  // pause audio/listening so the modal isn‚Äôt chaotic in hands-free mode
 await stopAllAudio();
  clearStudyAheadGapTimer();
  clearQuestionDelayTimer();
  clearAnswerAfterSpeechDelay();
  clearAnswerToRatingDelayTimer();

  if (!instructionsModal) return;
  instructionsModal.classList.remove("hidden");
  instructionsModal.setAttribute("aria-hidden", "false");
}

function closeInstructionsModal() {
  if (!instructionsModal) return;
  instructionsModal.classList.add("hidden");
  instructionsModal.setAttribute("aria-hidden", "true");

  // If you were studying, resume the correct loop
  if (currentMode === "voice" && !isPaused) runVoiceLoop();
  if (currentMode === "silent" && !isPaused) runSilentLoop();
}

if (openInstructionsBtn) {
  openInstructionsBtn.addEventListener("click", openInstructionsModal);
}

if (instructionsCloseBtn) {
  instructionsCloseBtn.addEventListener("click", closeInstructionsModal);
}

// click backdrop to close
if (instructionsModal) {
  instructionsModal.addEventListener("click", (e) => {
    if (e.target && e.target.classList && e.target.classList.contains("modalBackdrop")) {
      closeInstructionsModal();
    }
  });
}

// ESC to close
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && instructionsModal && !instructionsModal.classList.contains("hidden")) {
    closeInstructionsModal();
  }
});


    function showStudySection(mode) {
      currentMode = mode;
      mainMenuDiv.classList.add("hidden");
      studySectionDiv.classList.remove("hidden");
      modeBadge.textContent = mode === "voice" ? "Hands-Free Mode" : "Silent Mode";
      if (mode === "silent") {
        pauseBtn.classList.add("hidden");
        resumeBtn.classList.add("hidden");
      } else {
        pauseBtn.classList.remove("hidden");
        resumeBtn.classList.remove("hidden");
      }
      isPaused = false;
      resumeBtn.disabled = true;
      pauseBtn.disabled = false;
      if (mode !== "silent") {
        pauseBtn.classList.remove("hidden");
        resumeBtn.classList.remove("hidden");
      }
      updateDeckBadge();
    }

    backToMenuBtn.addEventListener("click", async () => {
      await stopAllAudio();
      showMainMenu();
    });

    pauseBtn.addEventListener("click", async () => {
  if (currentMode === "silent") return;
  isPaused = true;

  // NEW: make Resume replay the SAME card in hands-free mode
  if (currentMode === "voice" && currentCard) {
    restartCardOnResumeVoice = true;
  }
await stopAllAudio(); 
  clearStudyAheadGapTimer();
  clearQuestionDelayTimer();
    clearAutoGoodNextCardTimer();

  pauseBtn.disabled = true;
  resumeBtn.disabled = false;
  if (currentMode === "voice") {
    setVoiceSkipToAnswerEnabled(false);
  }
  setStatus("Paused study session. Say 'resume study session' or tap Resume.");

  // keep listening while paused when paused via button
  if (currentMode === "voice" && speechSupported && recognition) {
    listenForCommand(handleVoiceTranscript);
  }
});

    resumeBtn.addEventListener("click", () => {
  if (currentMode === "silent") return;
  if (!currentMode) return;

  isPaused = false;
  pauseBtn.disabled = false;
  resumeBtn.disabled = true;

  if (currentMode === "voice") {
    // NEW: replay the paused card instead of advancing
    if (restartCardOnResumeVoice && currentCard) {
      restartCardOnResumeVoice = false;
      restartCurrentCardVoiceFlow();
      return;
    }
    runVoiceLoop();
  } else {
    runSilentLoop();
  }
});

if (studyAddCardBtn) {
  studyAddCardBtn.addEventListener("click", () => {
    if (!currentDeckId) return;
    openAddCardModal();
    // closeAddCardModal() will handle resuming the suspended card
  });
}

if (addCardModalCloseBtn) addCardModalCloseBtn.addEventListener("click", closeAddCardModal);
if (addCardModalCancelBtn) addCardModalCancelBtn.addEventListener("click", closeAddCardModal);

// Close when clicking backdrop
if (addCardModal) {
  addCardModal.addEventListener("click", (e) => {
    if (e.target && e.target.classList && e.target.classList.contains("modalBackdrop")) {
      closeAddCardModal();
    }
  });
}

// Save card into CURRENT deck
if (addCardModalSaveBtn) {
  addCardModalSaveBtn.addEventListener("click", () => {
    const q = (addCardModalQuestion?.value || "").trim();
    const a = (addCardModalAnswer?.value || "").trim();

    if (!q || !a) {
      if (addCardModalStatus) addCardModalStatus.textContent = "Please enter both a question and an answer.";
      return;
    }

    const deck = getDeckById(currentDeckId);
    if (!deck) {
      if (addCardModalStatus) addCardModalStatus.textContent = "Deck not found.";
      return;
    }

    const id = "c_" + Date.now();
const qLang = cardQuestionLangSelect?.value || null;
const aLang = cardAnswerLangSelect?.value || null;

deck.cards.push({ id, question: q, answer: a, qLang, aLang });


    saveDecks();
    refreshDeckSelect();
    refreshCardsList();

    if (addCardModalStatus) addCardModalStatus.textContent = "Saved!";
    closeAddCardModal();
  });
}

// ESC to close
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && addCardModal && !addCardModal.classList.contains("hidden")) {
    closeAddCardModal();
  }
});
    
    function endStudySession() {
  clearStudyAheadGapTimer();
  clearQuestionDelayTimer();
  clearAnswerAfterSpeechDelay();
  if (voiceRatingButtons) {
    voiceRatingButtons.classList.add("hidden");
  }
  // Show instructions button when returning to main menu
  if (openInstructionsBtn) openInstructionsBtn.style.display = "";
  showMainMenu();
  setStatus("Study session ended.");
}

    // ===================== INLINE EDIT HELPERS =====================
    function updateCardTextInDeck(deckId, cardId, newQ, newA, newQLang = null, newALang = null) {
  const deck = getDeckById(deckId);
  if (!deck) return null;
  const card = deck.cards.find(c => c.id === cardId);
  if (!card) return null;

  card.question = newQ;
  card.answer = newA;

  // Save per-card language overrides (null means ‚Äúuse deck default‚Äù)
  card.qLang = newQLang;
  card.aLang = newALang;

  saveDecks();
  refreshDeckSelect();
  return card;
}

    // Silent mode inline edit
    silentEditToggleBtn.addEventListener("click", () => {
  if (!currentCard) return;
  silentEditQuestion.value = currentCard.question;
  silentEditAnswer.value = currentCard.answer;

  refreshCardLanguageDropdownsForCurrentDeck(currentCard);

  silentEditPanel.classList.remove("hidden");
});

    silentCancelEditBtn.addEventListener("click", () => {
      silentEditPanel.classList.add("hidden");
    });

    silentSaveEditBtn.addEventListener("click", () => {
      if (!currentCard) return;
      const q = silentEditQuestion.value.trim();
      const a = silentEditAnswer.value.trim();
      if (!q || !a) return;
const qLang = silentEditQuestionLangSelect?.value || null;
const aLang = silentEditAnswerLangSelect?.value || null;
const updated = updateCardTextInDeck(currentDeckId, currentCard.id, q, a, qLang, aLang);

      if (!updated) return;
      currentCard = updated;
      setCardContent(silentQuestionText, currentCard.question);
setCardContent(silentAnswerText, currentCard.answer);
      setCardContent(voiceQuestionText, currentCard.question);
setCardContent(voiceAnswerText, currentCard.answer);

      // refresh main card list so changes are visible there too
      refreshCardsList();

      silentEditPanel.classList.add("hidden");
      setStatus("Card updated.");
    });

    if (voiceRepeatQuestionBtn) {
      voiceRepeatQuestionBtn.addEventListener("click", () => {
        if (currentMode !== "voice" || !currentCard || isPaused) return;
        restartCurrentCardVoiceFlow();
      });
    }

    if (silentRepeatQuestionBtn) {
      silentRepeatQuestionBtn.addEventListener("click", () => {
        if (currentMode !== "silent" || !currentCard || isPaused) return;
        setFlashcardFlipped("silent", false);
        setStudyState(StudyState.SHOWING_QUESTION);
        if (showAnswerBtn) showAnswerBtn.classList.remove("hidden");
        // Keep rating buttons visible during question
        if (noScheduleChanges) {
          silentNextCardBtn.classList.remove("hidden");
        } else {
          silentNextCardBtn.classList.add("hidden");
        }
        // Don't clear hints - keep them visible
      });
    }

    // Voice mode inline edit
    if (voiceSkipToAnswerBtn) {
      voiceSkipToAnswerBtn.addEventListener("click", async () => {
        if (currentMode !== "voice" || !currentCard || isPaused) return;
        if (hasSpokenCurrentAnswer) return;

        await stopAllAudio();
        clearStudyAheadGapTimer();
        clearQuestionDelayTimer();
        clearAnswerAfterSpeechDelay();
        clearAnswerToRatingDelayTimer();
        clearAfterRatingDelayTimer();
        clearAutoGoodNextCardTimer();
        clearMicMuteTimer();

        awaitingAnswerSignal = false;
        awaitingDifficulty = false;
        inAnswerAfterSpeechDelay = false;

        speakAnswerThenAskDifficulty();
      });
    }

    voiceEditToggleBtn.addEventListener("click", () => {
      if (!currentCard) return;
      voiceEditQuestion.value = currentCard.question;
      voiceEditAnswer.value = currentCard.answer;
      voiceEditPanel.classList.remove("hidden");
    });

    voiceCancelEditBtn.addEventListener("click", () => {
      voiceEditPanel.classList.add("hidden");
    });

    voiceSaveEditBtn.addEventListener("click", () => {
      if (!currentCard) return;
      const q = voiceEditQuestion.value.trim();
      const a = voiceEditAnswer.value.trim();
      if (!q || !a) return;
const qLang = voiceEditQuestionLangSelect?.value || null;
const aLang = voiceEditAnswerLangSelect?.value || null;
const updated = updateCardTextInDeck(currentDeckId, currentCard.id, q, a, qLang, aLang);

      if (!updated) return;
      currentCard = updated;
      setCardContent(voiceQuestionText, currentCard.question);
setCardContent(voiceAnswerText, currentCard.answer);

      setCardContent(silentQuestionText, currentCard.question);
setCardContent(silentAnswerText, currentCard.answer);

      // refresh main card list so changes are visible there too
      refreshCardsList();

      voiceEditPanel.classList.add("hidden");
      setStatus("Card updated.");
    });

    // ===================== VOICE MODE =====================

  // Stop any current audio, then go to main menu immediately
async function speakAndGoToMainMenu() {
  await stopAllAudio();
  endStudySession();
}


    // NEW helper: fully restart current card flow in hands-free mode
    async function restartCurrentCardVoiceFlow() {
      if (!currentCard) return;

      await stopAllAudio();

      // Reset timers and state for this card
      clearStudyAheadGapTimer();
      clearQuestionDelayTimer();
      clearAnswerAfterSpeechDelay();
      clearAnswerToRatingDelayTimer();
      clearAfterRatingDelayTimer();
      clearAutoGoodNextCardTimer();
      clearMicMuteTimer();
      awaitingDifficulty = false;
      awaitingAnswerSignal = false;
      awaitingPostCompletionChoice = false;
      inStudyAheadAnswerGap = false;

      // Hide answer again and reset flags
      setFlashcardFlipped("voice", false);
      // Keep rating buttons visible during question
      setVoiceSkipToAnswerEnabled(false);
      hasSpokenCurrentAnswer = false;
      hasSpokenCurrentQuestion = false;

      // üö´ Disable pause/resume during repeat question
      setPauseResumeEnabled(false);
      // üö´ Disable Add Card button during repeat question
      setAddCardEnabled(false);

      setStatus("Repeating card...");
      setStudyState(StudyState.SHOWING_QUESTION);

      hasSpokenCurrentQuestion = true;
    speakWithWebTts(getPlainTextFromCard(currentCard.question), () => {
      if (isPaused) return;
      // ‚úÖ Re-enable pause/resume after repeat question finishes
      setPauseResumeEnabled(true);
      setVoiceSkipToAnswerEnabled(true);
      // üö´ Add Card stays disabled during answer window

  if (answerMode === "delay") {
    startOrResetQuestionDelayTimer();
  } else {
    // Voice answer mode: listen for user's speech to trigger answer playback
    awaitingAnswerSignal = true;
    setStudyState(StudyState.WAITING_FOR_ANSWER);
    setStatus("Listening for your answer...");
    
    // Add small delay on iOS to allow audio to fully release and voice recognition to activate
    listenForCommand(handleVoiceTranscript);
  }
});
    }

    async function handleNextCardSkip() {
  if (!currentCard || !currentDeckId) return;

  // 1) Hard stop anything that could still fire the answer later
 await stopAllAudio();               // cancels TTS + mic
  clearQuestionDelayTimer();      // kills delay-mode timer
  clearStudyAheadGapTimer();      // kills study-ahead gap window
  clearAnswerAfterSpeechDelay();  // kills ‚Äúanswer after I stop speaking‚Äù timer
  clearMicMuteTimer();            // optional safety

  // 2) Reset flow flags so nothing thinks we‚Äôre mid-step
  awaitingAnswerSignal = false;
  awaitingDifficulty = false;
  inAnswerAfterSpeechDelay = false;

  // 3) Hide answer UI (we‚Äôre skipping it)
  setFlashcardFlipped("voice", false);
  if (voiceRatingButtons) voiceRatingButtons.classList.add("hidden");

  // 4) Apply EASY only when schedule changes are enabled
  if (!noScheduleChanges) {
    const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, "easy");
    if (nextState && nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES) {
      queueCardForAgain(currentDeckId, currentCard);
    }
  }

  // 5) Advance
  setStudyState(StudyState.IDLE);
  runVoiceLoop();
}


    function normalizeCmdText(x) {
  return String(x || "")
    .toLowerCase()
    // ‚úÖ allow digits too, so "10" survives
    .replace(/[^a-z0-9\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}
function isNextCardCommand(text) {
  const t = normalizeCmdText(text);
  return (
    t === "go to next card" ||
    t === "go next card" ||       // optional: forgiving variation
    t === "go to the next card"   // optional: forgiving variation
  );
}


// tiny Levenshtein distance (fast enough for 1‚Äì2 word commands)
function levenshtein(a, b) {
  if (a === b) return 0;
  const al = a.length, bl = b.length;
  if (!al) return bl;
  if (!bl) return al;

  const dp = Array.from({ length: al + 1 }, () => new Array(bl + 1).fill(0));
  for (let i = 0; i <= al; i++) dp[i][0] = i;
  for (let j = 0; j <= bl; j++) dp[0][j] = j;

  for (let i = 1; i <= al; i++) {
    for (let j = 1; j <= bl; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[i][j] = Math.min(
        dp[i - 1][j] + 1,
        dp[i][j - 1] + 1,
        dp[i - 1][j - 1] + cost
      );
    }
  }
  return dp[al][bl];
}
function parseMuteSeconds(text) {
  const t = normalizeCmdText(text);

  // Accept ‚Äú10‚Äù, ‚Äúten‚Äù, ‚Äú20‚Äù, ‚Äútwenty‚Äù, etc.
  const map = {
    "10": 10, "ten": 10,
    "20": 20, "twenty": 20,
    "30": 30, "thirty": 30,
    "40": 40, "forty": 40,
    "50": 50, "fifty": 50,
    "60": 60, "sixty": 60,
  };

  // Look for any token that matches
  const parts = t.split(" ");
  for (const p of parts) {
    if (map[p]) return map[p];
  }

  // Handle phrases like "20 seconds"
  if (t.includes("10")) return 10;
  if (t.includes("20")) return 20;
  if (t.includes("30")) return 30;
  if (t.includes("40")) return 40;
  if (t.includes("50")) return 50;
  if (t.includes("60")) return 60;

  return null;
}

function parseRatingFromText(text) {
  const t = normalizeCmdText(text);
  if (!t) return null;

  // Prefer matching the FIRST word for rating commands (reduces false hits)
  const first = t.split(" ")[0] || "";

  // Direct phrase matches
  if (t.includes("repeat question") || t.includes("repeat answer")) return null; // handled elsewhere
  if (t === "main menu") return null; // handled elsewhere

  // Easy wins
  if (t.includes("again")) return "again";
  if (t.includes("hard")) return "hard";
  if (t.includes("easy")) return "easy";

  // ‚ÄúGood‚Äù synonyms / common mishears
  // (Web Speech often returns could/hood/gud/go when you say "good")
  const goodLike = new Set([
    "good", "fine", 
    "could", "hood", "gud", "go", "goo", "gould"
  ]);
  if (goodLike.has(first) || t.includes(" good ") || t.endsWith(" good")) return "good";

  // Fuzzy match the FIRST word to the 4 commands
  const targets = ["again", "hard", "good", "easy"];
  let best = null;
  let bestDist = 999;

  for (const cmd of targets) {
    const d = levenshtein(first, cmd);
    if (d < bestDist) {
      bestDist = d;
      best = cmd;
    }
  }

  // Thresholds: short words need tighter thresholds
  // - good/easy/hard: allow distance 1 (e.g., gud -> good)
  // - again: allow distance 2 (it‚Äôs longer)
  if (best === "again" && bestDist <= 2) return "again";
  if (best !== "again" && bestDist <= 1) return best;

  return null;
}

    // Helper: detect "main menu" style commands
function isMainMenuCommand(text) {
  const t = normalizeCmdText(text);
  return t === "main menu";
}

// Stop any current audio, then go to main menu (optionally speak)
async function speakAndGoToMainMenu(withConfirmation = false) {
  await stopAllAudio();
  if (withConfirmation) {
    speakSafe("Going to the main menu.", async () => {
      await stopAllAudio();
      endStudySession();
    });
    return;
  }
  endStudySession();
}

async function handleGlobalVoiceCommands(text) {
  const t = text.toLowerCase();

  // üîÅ Repeat question ‚Äî allowed in ANY voice state when we have a card
  if (t.includes("repeat question") && currentMode === "voice" && currentCard) {
    restartCurrentCardVoiceFlow();
    return true;
  }

  // üîÅ Repeat answer ‚Äî allowed whenever we've already shown an answer
  if (t.includes("repeat answer") && currentMode === "voice" && currentCard) {
    if (noScheduleChanges && studyAheadSession) {
      await stopAllAudio();
      clearStudyAheadGapTimer();
      inStudyAheadAnswerGap = true;
      studyAheadRepeatAnswerActive = true;
      pendingStudyAheadAdvance = false;
      stopListeningForCommand();
    }
    // üö´ Disable Add Card button during repeat answer
    setAddCardEnabled(false);
    // ‚úÖ Pause/resume stays enabled during repeat answer (already enabled)
     speakPlainAnswerWithCardLang("", () => {
    if (isPaused) return;

         if (noScheduleChanges && studyAheadSession) {
      studyAheadRepeatAnswerActive = false;
      pendingStudyAheadAdvance = false;
      startStudyAheadAnswerWindow(true);
      return;
    }

         if (awaitingDifficulty && !noScheduleChanges) {
      const detailed = !hasSpokenInstructionsOnce || !skipInstructionsAfterFirst;
      hasSpokenInstructionsOnce = true;
      const promptText = detailed
        ? "How was that. Say again, hard, good, or easy."
        : "How was that.";
      // ‚úÖ Re-enable Add Card button after repeat answer finishes (back to rating window)
      setAddCardEnabled(true);
      stopListeningForCommand();
      speak(promptText, () => startDifficultyListening());
      return;
    }

      if (awaitingPostCompletionChoice) {
      speakSafe("Say main menu to go back.", () => {
        listenForCommand(handleVoiceTranscript);
      });
      return;
    }

    if (currentMode === "voice") {
      listenForCommand(handleVoiceTranscript);
    }
  });
  return true;
}

  // üßä Pause study session ‚Äì pause IMMEDIATELY (before speaking)
if (
  t.includes("pause study session") ||
  (t.includes("pause") && (t.includes("study") || t.includes("session")))
) {
  if (currentMode === "voice" && !isPaused) {

    // ‚úÖ pause right now (not inside speak callback)
    isPaused = true;

    // ‚úÖ ensure resume replays same card
    if (currentCard) restartCardOnResumeVoice = true;

    // ‚úÖ kill anything that could advance the session
    await stopAllAudio();
    clearStudyAheadGapTimer();
    clearQuestionDelayTimer();
    clearAnswerAfterSpeechDelay();

    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
    setStatus("Paused study session. Say 'resume study session' or tap Resume.");

    // optional: quick confirmation, but it won't affect pause state
    speakSafe("Paused study session.", () => {
      // keep listening while paused so you can say "resume study session"
      listenForCommand(handleVoiceTranscript);
    });
  }
  return true;
}

  // ‚ñ∂Ô∏è Resume study session ‚Äì allowed anytime we‚Äôre paused
  if (
    t.includes("resume study session") ||
    (t.includes("resume") && (t.includes("study") || t.includes("session")))
  ) {
    if (isPaused) {
  speakSafe("Resuming study session.", () => {
    isPaused = false;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;

    if (currentMode === "voice") {
      if (restartCardOnResumeVoice && currentCard) {
        restartCardOnResumeVoice = false;
        restartCurrentCardVoiceFlow();
        return;
      }
      runVoiceLoop();
    } else if (currentMode === "silent") {
      runSilentLoop();
    }
  });
}
    return true;
  }

  // üè† Main menu ‚Äì now allowed in ANY voice state (normal or study-ahead)
   if (isMainMenuCommand(t) && currentMode === "voice") {
    speakAndGoToMainMenu(true);
    return true;
  }

  // ‚ùå End study session
  if (t.includes("end study session")) {
    endStudySession();
    return true;
  }

  return false;
}

 async function handleVoiceTranscript(text) {
  console.log("[VOICE] handleVoiceTranscript called with text:", text, { awaitingAnswerSignal, awaitingDifficulty, inAnswerAfterSpeechDelay });
  

  // If paused, only allow resume command, ignore all other input (mic stays on)
  if (isPaused) {
    const t = text.toLowerCase();
    if (
      t.includes("resume study session") ||
      (t.includes("resume") && (t.includes("study") || t.includes("session")))
    ) {
      speakSafe("Resuming study session.", () => {
        isPaused = false;
        pauseBtn.disabled = false;
        resumeBtn.disabled = true;
        if (currentMode === "voice") {
          if (restartCardOnResumeVoice && currentCard) {
            restartCardOnResumeVoice = false;
            restartCurrentCardVoiceFlow();
            return;
          }
          runVoiceLoop();
        } else if (currentMode === "silent") {
          runSilentLoop();
        }
      });
    } else {
      // Stay paused, keep listening indefinitely
      setStatus("Paused study session. Say 'resume study session' or tap Resume.");
      listenForCommand(handleVoiceTranscript);
    }
    return;
  }

  // If we are waiting to play the answer after speech ended, ANY transcript resets the countdown
  if (inAnswerAfterSpeechDelay) {
    if (isNextCardCommand(text)) { handleNextCardSkip(); return; }
    if (normalizeCmdText(text).length > 0) {
      startOrResetAnswerAfterSpeechDelay();
      return;
    }
  }

  // If we are waiting to play the answer after a delay, reset the timer on any speech
  if (currentMode === "voice" && answerMode === "delay" && questionDelayTimerId !== null) {
    if (normalizeCmdText(text).length > 0) {
      if (autoGoodMode) {
        setStatus("You may not give voice commands in this mode.");
      } else {
        setStatus("Wait until after answer to give voice commands in this answer behavior mode.");
      }
      startOrResetQuestionDelayTimer();
      return;
    }
  }

  // ‚úÖ IMPORTANT: await the async global handler
  if (await handleGlobalVoiceCommands(text)) return;

  // ‚úÖ Next card = skip answer + auto-easy (or just advance in study-ahead)
  if (isNextCardCommand(text) && currentMode === "voice") {
    handleNextCardSkip().catch(console.error);
    return;
  }
  // ===== Mic mute command: ONLY during voice-answer gap (after question, before answer) =====
if (awaitingAnswerSignal && currentMode === "voice") {
  const t = normalizeCmdText(text);

  if (t === "skip to answer" && answerMode === "voice") {
    awaitingAnswerSignal = false;
    clearAnswerAfterSpeechDelay();
    clearQuestionDelayTimer();
    stopListeningForCommand();
    speakAnswerThenAskDifficulty();
    return;
  }

  if (isMainMenuCommand(t)) {
    awaitingAnswerSignal = false;
    speakAndGoToMainMenu(true);
    return;
  }

  if (!awaitingMuteSeconds && (t === "mute microphone" || t.includes("mute microphone"))) {
    awaitingMuteSeconds = true;

    // Speak the allowed options and then listen for a number
    speakSafe("10, 20, 30, 40, 50, or 60 seconds?", () => {
      listenForCommand((numText) => {
        const n = parseMuteSeconds(numText);
        if (!n) {
          // reprompt once (safe, minimal)
          speakSafe("Please say 10, 20, 30, 40, 50, or 60.", () => {
            awaitingMuteSeconds = true;
            listenForCommand((numText2) => {
              const n2 = parseMuteSeconds(numText2);
              awaitingMuteSeconds = false;
              if (!n2) {
                speakSafe("Okay, not muting.", () => {
                  // resume listening for the answer
                  if (!isPaused && awaitingAnswerSignal) {
                    setStatus("Listening for your answer...");
                    listenForCommand(handleVoiceTranscript);
                  }
                });
                return;
              }
              startMicMute(n2);
            });
          });
          return;
        }

        awaitingMuteSeconds = false;
        startMicMute(n);
      });
    });

    return; // important: don‚Äôt fall through
  }
  
  // ‚úÖ If we get here while awaitingAnswerSignal is true, the user said something OTHER than "mute microphone"
  // So proceed with playing the answer
  console.log("[VOICE] User spoke in voice-answer mode (not mute), calling startOrResetAnswerAfterSpeechDelay");
  const wantsAnswer = t === "answer" || t === "play answer" || t === "show answer" || t.endsWith(" answer");
  if (!wantsAnswer) {
    setStatus("Say 'answer', 'play answer', or 'show answer' when you're ready.");
    listenForCommand(handleVoiceTranscript);
    return;
  }
  awaitingAnswerSignal = false;
  startOrResetAnswerAfterSpeechDelay();
  return;
}

  // If we were in the study-ahead answer gap, we no longer need a special case here;
  // main menu / repeat answer are already handled globally.

  // If we're choosing what to do after finishing all due cards
  if (awaitingPostCompletionChoice) {
    const wantsMainMenu = isMainMenuCommand(text);
    const wantsStudyAhead = text.includes("study ahead") || text.includes("study-ahead");

    if (wantsMainMenu) {
      awaitingPostCompletionChoice = false;
      speakAndGoToMainMenu();
      return;
    }

    if (!wantsStudyAhead) {
      // User said something else - silently ignore and keep listening
      listenForCommand(handleVoiceTranscript);
      return;
    }

    // Enter study-ahead mode (no schedule changes)
    awaitingPostCompletionChoice = false;
    studyAheadSession = true;
    noScheduleChanges = true;
    studyAheadPromptedOnceVoice = false;

    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    setVoiceSkipToAnswerEnabled(false);
    speak(
      "Okay, entering study ahead mode. These reviews will not change your future schedule.",
      () => {
        runVoiceLoop();
      }
    );
    return;
  }

  // If we're waiting for the user to say "I'm ready" in voice-answer mode

  // Difficulty / rating flow (normal, schedule-changing mode only)
  if (awaitingDifficulty) {
    const t = text.toLowerCase();
      if (isNextCardCommand(text)) { handleNextCardSkip(); return; }

    // Main menu commands are already handled globally, but just in case:
    if (isMainMenuCommand(t)) {
      awaitingDifficulty = false;
      speakAndGoToMainMenu();
      return;
    }

    // In study-ahead (noScheduleChanges) we should never be here,
    // but if we are, just re-prompt for main menu.
    if (noScheduleChanges) {
      speakSafe("Say main menu to go to the main menu.", () => {
        listenForCommand(handleVoiceTranscript);
      });
      return;
    }

    const ratingKey = parseRatingFromText(text);
    const trimmed = (text || "").trim().toLowerCase();
    const tooSoon = Date.now() - lastDifficultyPromptAt < difficultyPromptGraceMs;
    const ratingWords = ["again", "hard", "good", "easy"].filter(w => trimmed.includes(w)).length;
    const promptEcho =
      trimmed.includes("how was that") ||
      trimmed.includes("say again") ||
      ratingWords >= 2;

    if (ratingKey) {
      if (promptEcho && tooSoon) {
        startDifficultyListening();
        return;
      }
    } else {
      // User said something that's not a valid rating - silently keep listening
      startDifficultyListening();
      return;
    }

    // Apply scheduling normally
    // Apply scheduling normally (this records the rating)
const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, ratingKey);
if (nextState && nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES) {
  queueCardForAgain(currentDeckId, currentCard);
}

awaitingDifficulty = false;
if (voiceRatingButtons) {
  voiceRatingButtons.classList.add("hidden");
  clearVoiceHints();
}

// ‚úÖ NEW: echo the rating word with mic OFF, then continue
echoRatingThenContinue(ratingKey, () => {
  if (isPaused) return; // safety
  runVoiceLoopAfterRating();
});

return;
  }

  // Fallback: keep listening for the next command in voice mode
  if (currentMode === "voice") {
    listenForCommand(handleVoiceTranscript);
  }
}

    function describeAutoModeBehavior() {
      switch (autoModeBehavior) {
        case "again":
          return "mark each card as again";
        case "hard":
          return "mark each card as hard";
        case "good":
          return "mark each card as good";
        case "easy":
          return "mark each card as easy";
        case "tomorrow":
          return "push each card to show again tomorrow";
        default:
          return "mark each card as good";
      }
    }

    // ‚úÖ NEW: speak back the chosen rating (echo) with mic OFF, then continue
function echoRatingThenContinue(ratingKey, next) {
  // Normalize what we speak back (exactly the rating word)
  const spoken =
    ratingKey === "again" ? "again" :
    ratingKey === "hard"  ? "hard"  :
    ratingKey === "good"  ? "good"  :
    ratingKey === "easy"  ? "easy"  :
    null;

  if (!spoken) {
    // fallback: just continue
    next && next();
    return;
  }

  // Hard stop any active listening and prevent re-starts during the echo
  keepListening = false;
  if (recognition) {
    try { recognition.stop(); } catch (_) {}
  }

  // Mic OFF during echo
  const prevMicMuted = isMicMuted;
  isMicMuted = true;

  // üö´ Disable pause/resume during rating confirmation
  setPauseResumeEnabled(false);
  // üö´ Disable Add Card button during rating echo and next card transition
  setAddCardEnabled(false);

  // Optional: disable onscreen rating buttons during echo (prevents accidental taps)
  setVoiceRatingButtonsEnabled(false);

  // Speak the rating word, then continue
  speakWithWebTts(spoken, () => {
    // Restore mic state
    isMicMuted = prevMicMuted;

    // Re-enable rating buttons (though you usually hide them right after)
    setVoiceRatingButtonsEnabled(true);
    // ‚úÖ Pause/resume stays disabled until next card's question finishes

    next && next();
  }, { lang: "en-US" });
}

function speakAnswerThenAskDifficulty() {
  if (!currentCard) return;

  clearQuestionDelayTimer();

  hasSpokenCurrentAnswer = true;
  setStudyState(StudyState.SHOWING_ANSWER);

  setFlashcardFlipped("voice", true);
  setCardContent(voiceAnswerText, currentCard.answer);

  // ‚úÖ Pause/resume stays enabled during answer window and answer audio
  // (already enabled after question finished)

  // ‚úÖ get language for the ANSWER
  const deck = getDeckById(currentDeckId);
  const { aLang } = getCardLangs(deck, currentCard);

  // Prepare answer text with optional question restatement
  let answerText = getPlainTextFromCard(currentCard.answer);
  if (restateQuestionEnabled && currentCard.question) {
    const questionText = getPlainTextFromCard(currentCard.question);
    const statementPrefix = questionToStatement(questionText);
    if (statementPrefix) {
      answerText = statementPrefix + ' ' + answerText;
    }
  }

  // üîä Speak the answer in its language
  stopListeningForCommand();
  speakWithWebTts(
    answerText,
    async () => {
      if (isPaused) return;
      // ‚úÖ Pause/resume stays enabled during rating prompt

      // ===== STUDY-AHEAD HANDS-FREE: always respect the study-ahead gap and never ask for rating =====
      if (noScheduleChanges && studyAheadSession) {
        startStudyAheadAnswerWindow(false);
        return;
      }

      // ===== Automatic mode for pure hands-free, no commands =====
      if (autoGoodMode) {
        // Only schedule in normal mode; never schedule in noScheduleChanges mode
        if (!noScheduleChanges) {
          const behaviorRating = autoModeBehavior || "good";

          if (autoModeBehavior === "tomorrow") {
            applyTomorrowScheduling(currentDeckId, currentCard.id);
          } else {
            const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, behaviorRating);
            if (
              nextState &&
              nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES
            ) {
              queueCardForAgain(currentDeckId, currentCard);
            }
          }
        }

                 // ‚úÖ Auto-good mode: wait 5 seconds before the next question
  setStudyState(StudyState.IDLE);

  clearAutoGoodNextCardTimer();
  autoGoodNextCardTimerId = setTimeout(() => {
    autoGoodNextCardTimerId = null;
    if (!isPaused) runVoiceLoop();
  }, 5000);

  return;
      }

      // ===== Normal hands-free flow: show rating buttons, prompt again/hard/good/easy, then listen =====
      const startDifficultyPrompt = () => {
        awaitingDifficulty = true;
        if (voiceRatingButtons) {
          voiceRatingButtons.classList.remove("hidden");
          if (!noScheduleChanges) updateVoiceDueHints();
        }
        setVoiceSkipToAnswerEnabled(true);
        // ‚úÖ Enable Add Card button during rating window
        setAddCardEnabled(true);

        const detailed = !hasSpokenInstructionsOnce || !skipInstructionsAfterFirst;
        hasSpokenInstructionsOnce = true;

        const promptText = detailed
          ? "How was that. Say again, hard, good, or easy."
          : "How was that.";

        setStatus(promptText);

        // ‚úÖ Speak the prompt in English (or change if you want)
        stopListeningForCommand();
        speakWithWebTts(
          promptText,
          () => {
            if (!isPaused) startDifficultyListening();
          },
          { lang: "en-US" }
        );
      };

      clearAnswerToRatingDelayTimer();
      const delayMs = Math.max(0, Number(answerToRatingDelayMs || 0));
      if (delayMs > 0) {
        setStudyState(StudyState.WAITING_FOR_RATING);
        answerToRatingDueMs = Date.now() + delayMs;
        answerToRatingDelayTimerId = setTimeout(() => {
          answerToRatingDelayTimerId = null;
          answerToRatingDueMs = 0;
          if (!isPaused) startDifficultyPrompt();
        }, delayMs);
      } else {
        answerToRatingDueMs = 0;
        startDifficultyPrompt();
      }
    },
    { lang: aLang }
  );
}

    // NEW: Study-ahead answer window ‚Äì gives you time to say "repeat answer" or "main menu"
    function startStudyAheadAnswerWindow(restartOnly) {
      if (isPaused) return;
      clearStudyAheadGapTimer();
      inStudyAheadAnswerGap = true;

      const startListeningAndTimer = () => {
        // Don't listen for commands during the study-ahead gap countdown
        // This prevents speaking from resetting the timer
        // Global commands (pause, main menu) are still handled via button taps
        
        // Start countdown display
        const startTime = Date.now();
        const updateCountdown = () => {
          const elapsed = Date.now() - startTime;
          const remaining = Math.max(0, Math.ceil((studyAheadGapMs - elapsed) / 1000));
          if (remaining > 0) {
            setStatus(`Next question in ${remaining} second${remaining !== 1 ? 's' : ''}...`);
          } else {
            setStatus('');
          }
        };
        updateCountdown(); // Show immediately
        studyAheadCountdownInterval = setInterval(updateCountdown, 1000);
        
        studyAheadGapTimerId = setTimeout(() => {
          inStudyAheadAnswerGap = false;
          studyAheadGapTimerId = null;
          if (studyAheadCountdownInterval !== null) {
            clearInterval(studyAheadCountdownInterval);
            studyAheadCountdownInterval = null;
          }
          setStatus('');
          if (studyAheadRepeatAnswerActive) {
            pendingStudyAheadAdvance = true;
            return;
          }
          if (!isPaused && currentMode === "voice" && !awaitingPostCompletionChoice) {
            runVoiceLoop();
          }
        }, studyAheadGapMs);
      };

      if (!restartOnly && !studyAheadPromptedOnceVoice) {
        studyAheadPromptedOnceVoice = true;
        setVoiceSkipToAnswerEnabled(false);
        speakSafe("You are in study ahead mode. You can say repeat answer, repeat question, pause study session, resume study session, or main menu before the next card.", () => {
          if (isPaused) return;
          startListeningAndTimer();
        });
      } else {
        startListeningAndTimer();
      }
    }

    // NEW helper: randomized next-card picker for normal (schedule-changing) mode
    function pickRandomNextCardNormal(dueCards, lastId, isSilentMode) {
      // Remove duplicates between reviewQueue and dueCards
      const uniqueDue = dueCards.filter(card =>
        !reviewQueue.some(r => r.id === card.id)
      );

      const reviewCandidates = reviewQueue.slice();
      const dueCandidates = uniqueDue;

      // Helper: check if a card is "new" (no schedule entry)
      function isNewCard(card) {
        const key = scheduleKey(currentDeckId, card.id);
        return !schedule[key];
      }

      // Helper: check if a card has short interval (‚â§10 min)
      function hasShortInterval(card) {
        const key = scheduleKey(currentDeckId, card.id);
        const s = schedule[key];
        if (!s) return false;
        const normalized = normalizeScheduleEntry(s);
        return normalized.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES;
      }

      function pickFromPool(pool) {
        if (pool.length === 0) return null;
        let candidates = pool;
        if (pool.length > 1 && lastId) {
          const filtered = pool.filter(c => c.id !== lastId);
          if (filtered.length > 0) {
            candidates = filtered;
          }
        }
        const idx = Math.floor(Math.random() * (candidates.length));
        return candidates[idx];
      }

      function chooseRandom() {
        if (reviewCandidates.length === 0 && dueCandidates.length === 0) return null;

        // üö® NEW: Prevent back-to-back new cards
        const lastWasNew = lastId && dueCandidates.some(c => c.id === lastId && isNewCard(c));
        let reviewPool = reviewCandidates;
        let duePool = dueCandidates;

        if (lastWasNew) {
          // Filter out new cards from due pool unless it's the only option
          const nonNewDue = dueCandidates.filter(c => !isNewCard(c));
          if (nonNewDue.length > 0 || reviewCandidates.length > 0) {
            duePool = nonNewDue;
          }
        }

        let poolType;
        if (reviewPool.length && duePool.length) {
          // 50/50 mix when both exist
          poolType = Math.random() < 0.5 ? "review" : "due";
        } else if (reviewPool.length) {
          poolType = "review";
        } else {
          poolType = "due";
        }

        let candidate = pickFromPool(poolType === "review" ? reviewPool : duePool);

        // If we couldn't get a candidate from that pool (e.g., only lastId and we're avoiding it),
        // fall back to the other pool if possible.
        if (!candidate && poolType === "review") {
          candidate = pickFromPool(duePool);
        } else if (!candidate && poolType === "due") {
          candidate = pickFromPool(reviewPool);
        }

        // In silent mode we prefer never to repeat the same card back-to-back
        // when there are other options. The picker above already tries to avoid
        // lastId when pool size > 1, so at this point if candidate === lastId,
        // it means it's the only card available globally.
        return candidate;
      }

      const chosen = chooseRandom();

      if (chosen && reviewQueue.length > 0) {
        // If we picked from reviewQueue, remove it so it can be re-queued later
        const idx = reviewQueue.findIndex(c => c.id === chosen.id);
        if (idx !== -1) {
          reviewQueue.splice(idx, 1);
        }
      }

      return chosen;
    }

    function runVoiceLoop() {
      if (isPaused) {
        setStatus("Paused study session.");
        return;
      }

      // üö´ Disable pause/resume buttons at start of new card
      setPauseResumeEnabled(false);

        stopListeningForCommand(); // ‚úÖ ensure nothing is listening from study-ahead gap

      clearStudyAheadGapTimer();
      clearQuestionDelayTimer();
      clearAnswerAfterSpeechDelay();
      const deck = getDeckById(currentDeckId);
      if (!deck || deck.cards.length === 0) {
        if (voiceQuestionText) voiceQuestionText.textContent = "";
        if (voiceAnswerText) voiceAnswerText.textContent = "";
        setFlashcardFlipped("voice", false);

        setStudyState(StudyState.IDLE);
        speakSafe("This deck has no cards.", () => {
          awaitingPostCompletionChoice = true;
          speakSafe("Say main menu to go back.", () =>
            listenForCommand(handleVoiceTranscript)
          );
        });
        return;
      }

      const allowAhead = studyAheadSession;
      const includeOverdue = !noScheduleChanges;
      const lastId = currentCard ? currentCard.id : null;

      let nextCard = null;

      // If resuming after main menu, show the same card first
      if (currentCard && currentMode === null) {
        nextCard = currentCard;
        currentMode = "voice"; // or "silent" if needed
      } else if (noScheduleChanges && allowAhead) {
        if (!aheadQueue || aheadQueue.length === 0) {
          aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
          aheadQueueIndex = 0;
        }
        if (aheadQueueIndex < aheadQueue.length) {
          nextCard = aheadQueue[aheadQueueIndex++];
        } else {
          nextCard = null;
        }
      } else {
        // Normal schedule-changing mode with randomized mixing
        const dueCards = getDueCardsForDeck(currentDeckId, false, includeOverdue);
        const { overdue, due } = splitOverdueAndDue(currentDeckId, dueCards);

        // üö® Always exhaust overdue cards first
        if (overdue.length > 0) {
          nextCard = pickRandomNextCardNormal(overdue, lastId, false);
        } else {
          nextCard = pickRandomNextCardNormal(due, lastId, false);
        }
      }

      if (!nextCard && !allowAhead) {
  // Finished all due cards (normal mode)
  if (autoEnterStudyAhead) {
    // Automatically enter study-ahead mode
    studyAheadSession = true;
    noScheduleChanges = true;
    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    setStudyState(StudyState.IDLE);
    setVoiceSkipToAnswerEnabled(false);
    speak(
      "Congratulations, you are all caught up, no more cards are due today. Entering study ahead mode.",
      () => {
        runVoiceLoop();
      }
    );
    return;
  }

  // Old behavior: ask if they want study-ahead
  setStudyState(StudyState.IDLE);
  awaitingPostCompletionChoice = true;
  setVoiceSkipToAnswerEnabled(false);
  speak(
    "Congratulations, you are all caught up, no more cards are due today.",
    () => {
      speak(
        "If you'd like to go back to the main menu, say 'main menu'. Otherwise, say 'study ahead mode' to enter study ahead mode, which lets you review all cards in this deck without affecting their future due dates.",
        () => {
          listenForCommand(handleVoiceTranscript);
        }
      );
    }
  );
  return;
} else if (!nextCard && allowAhead) {
  // Finished all cards in study-ahead mode
  if (noScheduleChanges && studyAheadSession && loopStudyAhead) {
    // Automatically loop study-ahead again (no extra prompt)
    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    if (aheadQueue.length > 0) {
      setStudyState(StudyState.IDLE);
      runVoiceLoop();
      return;
    }
    // If for some reason there are no cards, fall through to message below
  }

  setStudyState(StudyState.IDLE);
  awaitingPostCompletionChoice = true;
  setVoiceSkipToAnswerEnabled(false);
  speak(
    "There are no more cards available to study in this deck right now.",
    () => {
      speakSafe("Say main menu to go back, or study ahead to enter review all cards in this deck again.", () =>
        listenForCommand(handleVoiceTranscript)
      );
    }
  );
  return;
}

      currentCard = nextCard;
      setStatus("Studying card...");
      hasSpokenCurrentQuestion = false;
      hasSpokenCurrentAnswer = false;
      setVoiceSkipToAnswerEnabled(false);

      setCardContent(voiceQuestionText, currentCard.question);
setCardContent(voiceAnswerText, currentCard.answer);

      setFlashcardFlipped("voice", false);
      voiceEditPanel.classList.add("hidden");

      // üö® Enable edit button now that we have a card to edit
      if (voiceEditToggleBtn) voiceEditToggleBtn.disabled = false;
      // ‚ö†Ô∏è Add Card button controlled by setAddCardEnabled() throughout the flow
      if (studyInstructionsBtn) studyInstructionsBtn.disabled = false;
   // Show rating buttons immediately AND make them clickable right away
if (!noScheduleChanges && !autoGoodMode && voiceRatingButtons) {
  voiceRatingButtons.classList.remove("hidden");
  setVoiceRatingButtonsEnabled(true);
  updateVoiceDueHints();
} else if (voiceRatingButtons) {
  voiceRatingButtons.classList.add("hidden");
  clearVoiceHints();
}

      hasSpokenCurrentQuestion = true;
setStudyState(StudyState.SHOWING_QUESTION);

// üîä Use the same MP3-capable helper for the question
const { qLang } = getCardLangs(deck, currentCard);

speakWithWebTts(
  getPlainTextFromCard(currentCard.question),
  () => {
    if (isPaused) return;
    // ‚úÖ Enable pause/resume after question audio finishes
    setPauseResumeEnabled(true);
    setVoiceSkipToAnswerEnabled(true);
    // üö´ Add Card stays disabled during answer window

      if (answerMode === "delay") {
        // In delay mode, don't listen for commands during the delay period
        // Mic is disabled during countdown - use buttons for pause/main menu if needed
        startOrResetQuestionDelayTimer();
      } else {
      awaitingAnswerSignal = true;
      setStudyState(StudyState.WAITING_FOR_ANSWER);
      setStatus("Listening for your answer...");
      listenForCommand(handleVoiceTranscript);
    }
  },
  { lang: qLang }
);
    }

    // ===================== SILENT MODE =====================
    function clearSilentHints() {
      hintAgain.textContent = "";
      hintHard.textContent = "";
      hintGood.textContent = "";
      hintEasy.textContent = "";
    }

    function clearVoiceHints() {
      voiceHintAgain.textContent = "";
      voiceHintHard.textContent = "";
      voiceHintGood.textContent = "";
      voiceHintEasy.textContent = "";
    }

    function updateSilentDueHints() {
      if (!currentCard || noScheduleChanges) {
        clearSilentHints();
        return;
      }
      const deckId = currentDeckId;
      const cardId = currentCard.id;

      // "Again" always means ~5 minutes (back to ladder level 1)
      hintAgain.textContent = "5 min >";

      const hardMinutes = previewIntervalMinutes(deckId, cardId, "hard");
      const goodMinutes = previewIntervalMinutes(deckId, cardId, "good");
      const easyMinutes = previewIntervalMinutes(deckId, cardId, "easy");

      function formatInterval(minutes) {
        if (minutes < 60) {
          const m = Math.max(1, Math.round(minutes));
          return m + " min";
        }
        const hours = minutes / 60;
        if (hours < 24) {
          const h = Math.max(1, Math.round(hours));
          return h + " hr" + (h === 1 ? "" : "s");
        }
        const days = minutes / MINUTES_PER_DAY;
        if (days < 14) {
          const d = Math.max(1, Math.round(days));
          return d + " day" + (d === 1 ? "" : "s");
        }
        const weeks = days / 7;
        const w = Math.max(1, Math.round(weeks));
        return w + " wk" + (w === 1 ? "" : "s");
      }

      hintHard.textContent = "Next in " + formatInterval(hardMinutes);
      hintGood.textContent = "Next in " + formatInterval(goodMinutes);
      hintEasy.textContent = "Next in " + formatInterval(easyMinutes);
    }

    function updateVoiceDueHints() {
      if (!currentCard || noScheduleChanges) {
        clearVoiceHints();
        return;
      }
      const deckId = currentDeckId;
      const cardId = currentCard.id;

      // "Again" always means ~5 minutes (back to ladder level 1)
      voiceHintAgain.textContent = "5 min >";

      const hardMinutes = previewIntervalMinutes(deckId, cardId, "hard");
      const goodMinutes = previewIntervalMinutes(deckId, cardId, "good");
      const easyMinutes = previewIntervalMinutes(deckId, cardId, "easy");

      function formatInterval(minutes) {
        if (minutes < 60) {
          const m = Math.max(1, Math.round(minutes));
          return m + " min";
        }
        const hours = minutes / 60;
        if (hours < 24) {
          const h = Math.max(1, Math.round(hours));
          return h + " hr" + (h === 1 ? "" : "s");
        }
        const days = minutes / MINUTES_PER_DAY;
        if (days < 14) {
          const d = Math.max(1, Math.round(days));
          return d + " day" + (d === 1 ? "" : "s");
        }
        const weeks = days / 7;
        const w = Math.max(1, Math.round(weeks));
        return w + " wk" + (w === 1 ? "" : "s");
      }

      voiceHintHard.textContent = "Next in " + formatInterval(hardMinutes);
      voiceHintGood.textContent = "Next in " + formatInterval(goodMinutes);
      voiceHintEasy.textContent = "Next in " + formatInterval(easyMinutes);
    }

    function runSilentLoop() {
      if (isPaused) {
        setStatus("Paused study session.");
        return;
      }
      const deck = getDeckById(currentDeckId);
      if (!deck || deck.cards.length === 0) {
        setStatus("This deck has no cards.");
        silentQuestionText.textContent = "";
        silentQuestion.classList.remove("hidden");
        setFlashcardFlipped("silent", false);
        showAnswerBtn.classList.remove("hidden");
        silentRatingButtons.classList.add("hidden");
        silentNextCardBtn.classList.add("hidden");
        clearSilentHints();
        silentCompletionControls.classList.add("hidden");
        silentEditPanel.classList.add("hidden");
        setStudyState(StudyState.IDLE);
        return;
      }
      const allowAhead = studyAheadSession;
      const includeOverdue = !noScheduleChanges;
      const lastId = currentCard ? currentCard.id : null;

      let nextCard = null;

      // Study-ahead (no schedule changes) uses aheadQueue
      if (noScheduleChanges && allowAhead) {
        if (!aheadQueue || aheadQueue.length === 0) {
          aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
          aheadQueueIndex = 0;
        }
        if (aheadQueueIndex < aheadQueue.length) {
          nextCard = aheadQueue[aheadQueueIndex++];
        } else {
          nextCard = null;
        }
      } else {
        // Normal schedule-changing mode (silent) with randomized mixing
        const dueCards = getDueCardsForDeck(currentDeckId, false, includeOverdue);
const { overdue, due } = splitOverdueAndDue(currentDeckId, dueCards);

if (overdue.length > 0) {
  nextCard = pickRandomNextCardNormal(overdue, lastId, true);
} else {
  nextCard = pickRandomNextCardNormal(due, lastId, true);
}
      }

      if (!nextCard && !allowAhead) {
  // Finished all due cards (normal mode)
  if (autoEnterStudyAhead) {
    setStatus("Congratulations, you are all caught up. Entering study ahead mode.");
    studyAheadSession = true;
    noScheduleChanges = true;

    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    silentCompletionControls.classList.add("hidden");
    silentNextCardBtn.classList.remove("hidden");
    setStudyState(StudyState.IDLE);
    runSilentLoop();
    return;
  }

  // Old behavior: show completion controls
  setStatus(
    "Congratulations, you are all caught up, no more cards are due today."
  );
  silentQuestionText.textContent = "";
  silentQuestion.classList.add("hidden");
  setFlashcardFlipped("silent", false);
  showAnswerBtn.classList.add("hidden");
  silentRatingButtons.classList.add("hidden");
  silentNextCardBtn.classList.add("hidden");
  clearSilentHints();
  pauseBtn.classList.add("hidden");
  resumeBtn.classList.add("hidden");
  silentCompletionControls.classList.remove("hidden");
  silentEditPanel.classList.add("hidden");
  setStudyState(StudyState.IDLE);
  return;
} else if (!nextCard && allowAhead) {
  // Finished all cards in study-ahead mode
  if (noScheduleChanges && studyAheadSession && loopStudyAhead) {
    aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
    aheadQueueIndex = 0;

    if (aheadQueue.length > 0) {
      setStudyState(StudyState.IDLE);
      runSilentLoop();
      return;
    }
    // fall through if somehow there are still no cards
  }

  setStatus("There are no more cards available to study in this deck right now.");
  silentQuestionText.textContent = "";
  silentQuestion.classList.add("hidden");
  setFlashcardFlipped("silent", false);
  showAnswerBtn.classList.add("hidden");
  silentRatingButtons.classList.add("hidden");
  silentNextCardBtn.classList.add("hidden");
  clearSilentHints();
  silentCompletionControls.classList.add("hidden");
  silentEditPanel.classList.add("hidden");
  setStudyState(StudyState.IDLE);
  return;
}

      silentCompletionControls.classList.add("hidden");
      silentQuestion.classList.remove("hidden");
      showAnswerBtn.classList.remove("hidden");
      pauseBtn.classList.add("hidden");
      resumeBtn.classList.add("hidden");

      currentCard = nextCard;
      setStatus("Studying card...");
      setCardContent(silentQuestionText, currentCard.question);
    setCardContent(silentAnswerText, currentCard.answer);
      setFlashcardFlipped("silent", false);
      if (noScheduleChanges) {
        silentRatingButtons.classList.add("hidden");
      } else {
        silentRatingButtons.classList.remove("hidden");
        updateSilentDueHints();
      }
      clearSilentHints();
      silentEditPanel.classList.add("hidden");

      setCardContent(voiceQuestionText, currentCard.question);
  setCardContent(voiceAnswerText, currentCard.answer);
  setVoiceSkipToAnswerEnabled(false);

      if (noScheduleChanges) {
        silentNextCardBtn.classList.remove("hidden");
      } else {
        silentNextCardBtn.classList.add("hidden");
      }

      setStudyState(StudyState.SHOWING_QUESTION);
    }

    showAnswerBtn.addEventListener("click", () => {
      if (!currentCard) return;

      // study-ahead silent: tap once to show answer, second tap goes next
      if (noScheduleChanges && isFlashcardFlipped("silent")) {
        setFlashcardFlipped("silent", false);
        clearSilentHints();
        setStudyState(StudyState.IDLE);
        runSilentLoop();
        return;
      }

      setFlashcardFlipped("silent", true);
      setStudyState(StudyState.SHOWING_ANSWER);
      if (noScheduleChanges) {
        silentRatingButtons.classList.add("hidden");
        clearSilentHints();
      } else {
        silentRatingButtons.classList.remove("hidden");
        updateSilentDueHints();
        setStudyState(StudyState.WAITING_FOR_RATING);
      }
    });

    silentNextCardBtn.addEventListener("click", () => {
      if (!currentCard) return;
      setFlashcardFlipped("silent", false);
      clearSilentHints();
      setStudyState(StudyState.IDLE);
      runSilentLoop();
    });

    silentRatingButtons.addEventListener("click", (e) => {
      const btn = e.target;
      if (!btn.dataset.rating || !currentCard) return;
      const ratingKey = btn.dataset.rating;
      if (!noScheduleChanges) {
        const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, ratingKey);
        if (nextState && nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES) {
          queueCardForAgain(currentDeckId, currentCard);
        }
      }
      setStudyState(StudyState.IDLE);
      runSilentLoop();
    });

        // Rating buttons for voice (hands-free) mode ‚Äì optional tap instead of speaking
    if (voiceRatingButtons) {
  voiceRatingButtons.addEventListener("click", async (e) => {
    const btn = e.target.closest("button[data-voice-rating]");
    if (!btn || !currentCard) return;

    const ratingKey = btn.dataset.voiceRating;

    clearQuestionDelayTimer();
    clearStudyAheadGapTimer();
    awaitingAnswerSignal = false;
    awaitingDifficulty = false;

    // üö´ Disable Add Card button when rating button is clicked
    setAddCardEnabled(false);

    await stopAllAudio();

    if (!noScheduleChanges) {
      const nextState = applyAnkiScheduling(currentDeckId, currentCard.id, ratingKey);
      if (nextState && nextState.intervalMinutes <= SHORT_REVIEW_THRESHOLD_MINUTES) {
        queueCardForAgain(currentDeckId, currentCard);
      }
    }

    voiceRatingButtons.classList.add("hidden");
    clearVoiceHints();
    runVoiceLoopAfterRating();
  });
}

    silentMainMenuBtn.addEventListener("click", () => {
      silentCompletionControls.classList.add("hidden");
      endStudySession();
    });

    silentStudyAheadBtn.addEventListener("click", () => {
      silentCompletionControls.classList.add("hidden");
      studyAheadSession = true;
      noScheduleChanges = true;

      aheadQueue = shuffleArray(getDueCardsForDeck(currentDeckId, true, false));
      aheadQueueIndex = 0;

      silentQuestion.classList.remove("hidden");
      showAnswerBtn.classList.remove("hidden");
      pauseBtn.classList.add("hidden");
      resumeBtn.classList.add("hidden");
      silentNextCardBtn.classList.remove("hidden");
      runSilentLoop();
    });

    startSilentBtn.addEventListener("click", () => {
      ensureBgMusicPlayback();
      saveLastMode("silent");
if (selectedDeckId) saveLastDeckId(selectedDeckId);
      currentDeckId = selectedDeckId;
      if (!currentDeckId) return;
      skipInstructionsAfterFirst = !!skipInstructionsAfterFirstCheckbox.checked;
      autoEnterStudyAhead = !!autoEnterStudyAheadCheckbox.checked;
loopStudyAhead = !!loopStudyAheadCheckbox.checked;

      // Start in normal due-today mode; study-ahead entered from completion controls
      studyAheadSession = false;
      noScheduleChanges = false;
      reviewQueue = [];
      aheadQueue = [];
      aheadQueueIndex = 0;
      silentCompletionControls.classList.add("hidden");
      silentNextCardBtn.classList.add("hidden");

      silentUI.classList.remove("hidden");
      voiceUI.classList.add("hidden");

      // ‚úÖ Enable Add Card button for silent study mode (always available)
      if (studyAddCardBtn) studyAddCardBtn.disabled = false;

      // Hide instructions button during study
      if (openInstructionsBtn) openInstructionsBtn.style.display = "none";

      showStudySection("silent");
      runSilentLoop();
    });

    // ===================== INIT & AUTO MODE WIRING =====================
    // Disable rating select when automatic mode is off (UX polish)
    autoRatingSelect.disabled = true;
    autoGoodToggle.addEventListener("change", () => {
      autoRatingSelect.disabled = !autoGoodToggle.checked;
    });

    function describeAutoIntro() {
      const behaviorRating = autoModeBehavior || "good";
      let ratingText;
      
      switch (behaviorRating) {
        case "again":
          ratingText = "again";
          break;
        case "hard":
          ratingText = "hard";
          break;
        case "easy":
          ratingText = "easy";
          break;
        case "tomorrow":
          ratingText = "to show again tomorrow";
          break;
        case "good":
        default:
          ratingText = "good";
          break;
      }
      
      if (answerMode === "voice") {
        // Play answer after speaking mode
        return "Entering study session. I will read the question, then you will say answer to play the answer, or you may say any other voice command. I will say the answer, then I will rate each card as " + ratingText + ".";
      } else {
        // Delay mode
        if (behaviorRating === "tomorrow") {
          return "Entering automatic study session. I will read a question, then I will read the answer. I will then rate each card to show again tomorrow.";
        }
        return "Entering automatic study session. I will read a question, then I will read the answer. I will then rate each card as " + ratingText + ".";
      }
    }

    // >>> MODIFIED: add async + inline mic permission request here <<<
    // >>> REPLACE your existing startVoiceBtn handler with this whole block <<<
startVoiceBtn.addEventListener("click", async () => {
  ensureBgMusicPlayback();
  saveLastMode("voice");
  if (selectedDeckId) saveLastDeckId(selectedDeckId);

  // ‚úÖ Set autoGoodMode/options EARLY so we can use it for conditional initialization
  autoModeBehavior = autoRatingSelect.value || "good";
  autoGoodMode = !!autoGoodToggle.checked;
  autoEnterStudyAhead = !!autoEnterStudyAheadCheckbox.checked;
  loopStudyAhead = !!loopStudyAheadCheckbox.checked;

  // ‚úÖ Determine answer mode (needed to decide if we need VoiceCommands)
  const selectedAnswerMode = answerModeVoiceRadio.checked ? "voice" : "delay";

  // ‚úÖ Only initialize VoiceCommands if we actually need voice input
  // Skip if in auto-good mode WITH delay answer (no STT needed)
  // But DO initialize if answer mode is "voice" (need to detect when user speaks)
  const needsVoiceCommands = !autoGoodMode || selectedAnswerMode === "voice";

  // ‚úÖ Deck id: fall back to dropdown value if selectedDeckId isn't set
  currentDeckId = selectedDeckId || (deckSelect ? deckSelect.value : null);
  if (!currentDeckId) {
    alert("Please select a deck first.");
    return;
  }


  // ‚úÖ Browser mic permission (web version: always request if needed)
  if (
    (typeof isNativeApp === "undefined" || !isNativeApp) &&
    needsVoiceCommands &&
    navigator.mediaDevices &&
    navigator.mediaDevices.getUserMedia
  ) {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      if (stream && stream.getTracks) stream.getTracks().forEach((t) => t.stop());
      console.log("Microphone permission requested.");
    } catch (err) {
      console.error("Microphone permission error:", err);
      alert(
        "Microphone access is required for hands-free study in the browser. " +
        "Please enable it in your browser's site settings and try again."
      );
      return;
    }
  }

  // If we need voice commands but have NO native plugin and NO browser STT, we can't proceed
 if (needsVoiceCommands && !speechSupported) {
    alert("Speech recognition not supported in this environment.");
    return;
  }

  // ‚úÖ Clean slate (prevents ‚Äúnothing happens‚Äù due to stale timers/audio)
  await stopAllAudio();
  clearStudyAheadGapTimer();
  clearQuestionDelayTimer();
  clearAnswerAfterSpeechDelay();

  skipInstructionsAfterFirst = !!skipInstructionsAfterFirstCheckbox.checked;
  disableOpeningPrompt = !!disableOpeningPromptCheckbox.checked;
  hasSpokenInstructionsOnce = false;

  // Start in normal ‚Äúdue today‚Äù mode; study-ahead only after completion
  studyAheadSession = false;
  noScheduleChanges = false;
  studyAheadPromptedOnceVoice = false;
  reviewQueue = [];
  aheadQueue = [];
  aheadQueueIndex = 0;
  hasSpokenCurrentQuestion = false;
  hasSpokenCurrentAnswer = false;

  // üö® Disable edit button until first card question is shown
  if (voiceEditToggleBtn) voiceEditToggleBtn.disabled = true;
  if (studyAddCardBtn) studyAddCardBtn.disabled = true;
  if (studyInstructionsBtn) studyInstructionsBtn.disabled = true;

  // Determine answer mode from user selection (NOT forced by autoGoodMode)
  // autoGoodMode just changes HOW we rate, not WHEN we show the answer
  answerMode = answerModeVoiceRadio.checked ? "voice" : "delay";

  const secs = parseInt(answerDelaySecondsInput.value, 10);
  answerDelayMs = isNaN(secs) ? 4000 : Math.max(1, Math.min(60, secs)) * 1000;

  const gapSecs = parseInt(studyAheadGapSecondsInput.value, 10);
  studyAheadGapMs = isNaN(gapSecs) ? 4000 : Math.max(1, Math.min(60, gapSecs)) * 1000;

  // Switch UI into voice mode
  voiceUI.classList.remove("hidden");
  silentUI.classList.add("hidden");
  showStudySection("voice");
  setStudyState(StudyState.IDLE);

  // Hide instructions button during study
  if (openInstructionsBtn) openInstructionsBtn.style.display = "none";

  // Check if we should skip opening prompt
  if (disableOpeningPrompt) {
    // Skip intro, go straight to first question
    runVoiceLoop();
  } else {
    // üö´ Disable pause/resume during opening prompt
    setPauseResumeEnabled(false);
    // üö´ Disable skip-to-answer during opening prompt
    setVoiceSkipToAnswerEnabled(false);
    // üö´ Disable Add Card button during opening prompt
    setAddCardEnabled(false);

    let intro;
    if (autoGoodMode) {
      intro = describeAutoIntro();
    } else if (answerMode === "voice") {
      // Play answer after speaking mode
      intro = "Starting study session. I will read a question, then you will say \"answer\" to play the answer or you may say any other voice command. I will play the answer, then I will ask you for your rating. You may then give your rating, or any other voice command. Voice commands only work after I ask you a question or after I ask you for your rating. You may disable these instructions in study options for future study sessions.";
    } else {
      // Delay mode (play answer after X seconds)
      const delaySecs = Math.round(answerDelayMs / 1000);
      intro = "Starting study session. I will read a question, then after " + delaySecs + " seconds, I will say the answer. I will ask you for your rating. You may then give your rating or any other voice command. Voice commands only work after I ask you for your rating. You may disable these instructions in study options for future study sessions.";
    }

    // ‚úÖ Don't pre-check cards here; let runVoiceLoop be the single source of truth
    speak(intro, () => {
      runVoiceLoop();
    });
  }
});

    // <<< END MODIFIED HANDLER <<<

    if (studyInstructionsBtn) {
      studyInstructionsBtn.addEventListener("click", () => {
        openInstructionsModal();
        // After closing the modal, restart the current card (re-read question)
        if (currentMode === "voice" && typeof runVoiceLoop === "function") {
          setTimeout(() => runVoiceLoop(), 250);
        }
      });
}

 async function init() {

  // 1) Check session early - if no session, redirect to login
  try {
    const { data: sessionData, error: sessErr } = await supabaseClient.auth.getSession();
    const session = sessionData?.session || null;

    console.log("[BOOT] getSession()", {
      hasSession: !!session,
      sessErr: sessErr ? { message: sessErr.message, name: sessErr.name } : null
    });

    if (!session) {
      console.warn("[BOOT] No session. Not redirecting to index.html (app mode)");
      showSessionError("No session found. Please log in again.");
      return;
    }

    // 2) Set currentUser + show auth bar
    currentUser = session.user;
    if (userEmailLabel) userEmailLabel.textContent = currentUser.email || "";
    if (authLoggedIn) authLoggedIn.classList.remove("hidden");

  } catch (e) {
    console.error("[BOOT] Session check failed:", e);
    showSessionError("Session check failed. Please log in again.");
    return;
  }

  // 3) Load local data first (fast)
  try {
    loadFromStorage();
  } catch (e) {
    console.error("loadFromStorage failed:", e);
  }

  // 4) Immediately render whatever we have locally
  try {
    if (typeof rebuildDeckUI === "function") rebuildDeckUI();
  } catch (e) {
    console.error("rebuildDeckUI (local) failed:", e);
  }

// ===== Show session error UI =====
function showSessionError(msg) {
  let el = document.getElementById("sessionErrorMsg");
  if (!el) {
    el = document.createElement("div");
    el.id = "sessionErrorMsg";
    el.style.position = "fixed";
    el.style.top = "0";
    el.style.left = "0";
    el.style.width = "100vw";
    el.style.background = "#1e293b";
    el.style.color = "#fff";
    el.style.zIndex = "99999";
    el.style.padding = "1.5rem 1rem";
    el.style.textAlign = "center";
    el.style.fontSize = "1.1rem";
    el.style.fontWeight = "bold";
    el.innerText = msg || "Session error. Please log in again.";
    document.body.appendChild(el);
  } else {
    el.innerText = msg || "Session error. Please log in again.";
    el.style.display = "block";
  }
}

  // 5) Load remote state (if logged in)
  try {
    if (currentUser && typeof loadStateFromSupabase === "function") {
      await loadStateFromSupabase();
      hasLoadedRemote = true;

      // 6) Re-render again AFTER remote arrives
      try {
        if (typeof rebuildDeckUI === "function") rebuildDeckUI();
      } catch (e) {
        console.error("rebuildDeckUI (remote) failed:", e);
      }
    } else {
      hasLoadedRemote = false;
    }
  } catch (e) {
    console.error("init remote load failed", e);
    hasLoadedRemote = false;
  }
   applyStudyPrefsToUIAndState();
  wireStudyPrefsListeners();
}

init();


  </script>
</body>
</html>